# Web3 todo interface

*Automatically synced with your [v0.dev](https://v0.dev) deployments*

[![Deployed on Vercel](https://img.shields.io/badge/Deployed%20on-Vercel-black?style=for-the-badge&logo=vercel)](https://vercel.com/manoelgomesdevs-projects/v0-web3-todo-interface)
[![Built with v0](https://img.shields.io/badge/Built%20with-v0.dev-black?style=for-the-badge)](https://v0.dev/chat/projects/Tw7JzfnvoEm)

## Overview

This repository will stay in sync with your deployed chats on [v0.dev](https://v0.dev).
Any changes you make to your deployed app will be automatically pushed to this repository from [v0.dev](https://v0.dev).

## Deployment

Your project is live at:

**[https://vercel.com/manoelgomesdevs-projects/v0-web3-todo-interface](https://vercel.com/manoelgomesdevs-projects/v0-web3-todo-interface)**

## Build your app

Continue building your app on:

**[https://v0.dev/chat/projects/Tw7JzfnvoEm](https://v0.dev/chat/projects/Tw7JzfnvoEm)**

## How It Works

1. Create and modify your project using [v0.dev](https://v0.dev)
2. Deploy your chats from the v0 interface
3. Changes are automatically pushed to this repository
4. Vercel deploys the latest version from this repository

---

## ğŸ“š Aula 1

### ğŸš€ Prompt para criar seu Front com mais agilidade

```
WEB3 TODO â€” Interface de UsuÃ¡rio

O objetivo deste projeto Ã© desenvolver a interface de usuÃ¡rio do WEB3 TODO, um aplicativo de gerenciamento de tarefas com integraÃ§Ã£o Ã  tecnologia Web3. O sistema permitirÃ¡ que os usuÃ¡rios conectem sua carteira digital, criem e acompanhem tarefas, alÃ©m de visualizarem mÃ©tricas em tempo real, sempre priorizando a usabilidade e o design moderno.

A estrutura da interface Ã© dividida em trÃªs Ã¡reas principais:

1. CabeÃ§alho

Exibir no topo da pÃ¡gina um botÃ£o de destaque com o rÃ³tulo "Conectar Carteira".

Abaixo do botÃ£o, apresentar uma mensagem de alerta:
"Conecte sua carteira para gerenciar suas tarefas na blockchain."

O botÃ£o e a mensagem devem indicar visualmente o status da conexÃ£o com a carteira, facilitando o entendimento do usuÃ¡rio sobre o que estÃ¡ ou nÃ£o disponÃ­vel.

2. SeÃ§Ã£o de MÃ©tricas

Criar uma grade horizontal com quatro cards informativos:

Total de Tarefas

Tarefas ConcluÃ­das

Tarefas Pendentes

Wei em Stake

Cada card deve:

Utilizar cores que remetam Ã  tecnologia, como azul cobalto, ciano elÃ©trico e violeta digital.

Conter Ã­cones visuais que facilitem a leitura rÃ¡pida dos dados.

3. SeÃ§Ã£o de Tarefas

Exibir o tÃ­tulo da seÃ§Ã£o: "Tarefas".

Ao lado do tÃ­tulo, adicionar um botÃ£o destacado: "Nova Tarefa".

Exibir a lista de tarefas em formato de cards horizontais, contendo:

Nome da tarefa

Status: Pendente ou ConcluÃ­do

DescriÃ§Ã£o

Data de criaÃ§Ã£o

Data de conclusÃ£o (se aplicÃ¡vel)

Valor em wei associado

Ãcone de aÃ§Ã£o para "Concluir Tarefa" (sem ediÃ§Ã£o ou exclusÃ£o)

Os cards devem:

ReforÃ§ar visualmente as aÃ§Ãµes disponÃ­veis.

Diferenciar claramente tarefas pendentes e tarefas concluÃ­das.

Diretrizes de Design

Estilo Visual

Interface clean e moderna, com tema claro (light mode).

Aplicar a regra 60-30-10 para proporÃ§Ã£o de cores.

Utilizar no mÃ¡ximo duas cores principais.

Tipografia clara com hierarquia visual definida.

Design minimalista, com espaÃ§amento adequado.

Fornecer feedback visual para:

AÃ§Ãµes do usuÃ¡rio

Estados de carregamento

Erros ou validaÃ§Ãµes

Interface responsiva para se adaptar a diferentes dispositivos.

Clareza e ConsistÃªncia

Utilizar rÃ³tulos descritivos e Ã­cones intuitivos.

Manter coerÃªncia visual em:

Cores

Tamanhos

Fontes

EspaÃ§amentos

Destacar visualmente elementos que dependem da conexÃ£o da carteira.

Interatividade

Fornecer feedback imediato com animaÃ§Ãµes suaves.

Criar transiÃ§Ãµes fluidas entre os diferentes estados da interface.

BotÃµes devem apresentar estados visuais distintos:

Hover

Ativo

Desativado

Carregando

Acessibilidade

Garantir contraste de cores adequado.

Incluir textos alternativos (alt) para Ã­cones e imagens.

Permitir navegaÃ§Ã£o completa por teclado.

Evitar a comunicaÃ§Ã£o exclusiva por cor (ex: nÃ£o usar sÃ³ cor para indicar status).

ConsideraÃ§Ãµes Finais

A interface deve ser intuitiva e acessÃ­vel para iniciantes em Web3, deixando claro quando determinadas funcionalidades exigem a carteira conectada. Todos os elementos interativos devem responder com feedback visual, e a experiÃªncia deve manter consistÃªncia e fluidez em toda a jornada do usuÃ¡rio.
```

---

## ğŸ“ Aula 2

### ğŸ”— O que Ã© Blockchain Ethereum?

**Blockchain** Ã© como um **livro de registros digital** que funciona de forma descentralizada:

- **ğŸ“– Livro PÃºblico**: Todas as transaÃ§Ãµes ficam registradas e visÃ­veis para todos
- **ğŸ”’ ImutÃ¡vel**: Uma vez registrado, nÃ£o pode ser alterado ou apagado
- **ğŸŒ Descentralizado**: NÃ£o hÃ¡ uma autoridade central controlando
- **â›“ï¸ Em Blocos**: InformaÃ§Ãµes organizadas em "blocos" conectados em sequÃªncia

**Ethereum** Ã© uma blockchain especial que permite executar **programas** (smart contracts), nÃ£o apenas transferir dinheiro como o Bitcoin.

### ğŸ“‹ O que Ã© Smart Contract?

**Smart Contract** Ã© um **programa de computador** que roda na blockchain:

- **ğŸ¤– AutomÃ¡tico**: Executa sozinho quando as condiÃ§Ãµes sÃ£o atendidas
- **ğŸ“ CÃ³digo Ã© Lei**: As regras estÃ£o escritas em cÃ³digo e nÃ£o podem ser quebradas
- **ğŸ” Transparente**: Qualquer pessoa pode ver o cÃ³digo e verificar como funciona
- **ğŸ’° Lida com Dinheiro**: Pode receber, guardar e enviar criptomoedas

**Exemplo prÃ¡tico**: 
- VocÃª cria uma tarefa no nosso sistema
- Envia 0.001 ETH como "aposta" 
- Se completar no prazo = recebe o dinheiro de volta
- Se atrasar = perde o dinheiro
- Tudo acontece automaticamente, sem intermediÃ¡rios!

### â›½ O que Ã© "Gas"?

**Gas** Ã© a **"gasolina"** da blockchain Ethereum:

- **ğŸ’¸ Taxa de TransaÃ§Ã£o**: VocÃª paga para usar a blockchain
- **âš¡ Energia Computacional**: Quanto mais complexa a operaÃ§Ã£o, mais gas custa
- **ğŸ‘· Pagamento aos Mineradores**: Quem mantÃ©m a rede funcionando recebe essas taxas
- **ğŸš€ Velocidade**: Pagar mais gas = transaÃ§Ã£o mais rÃ¡pida

**Analogia simples**:
- Blockchain = Estrada
- Smart Contract = Destino  
- Gas = CombustÃ­vel para chegar lÃ¡
- Mais gas = Viagem mais rÃ¡pida, menos gas = Viagem mais lenta

**Exemplo de custos**:
- Criar tarefa: ~50,000 gas
- Completar tarefa: ~30,000 gas  
- Consultar dados: 0 gas (leitura Ã© grÃ¡tis!)

**ğŸ’¡ Dica**: Gas varia conforme a demanda da rede. Em horÃ¡rios de pico, fica mais caro!

### ğŸ’» Entendendo Solidity - A Linguagem dos Smart Contracts

**Solidity** Ã© como o **"idioma oficial"** para escrever contratos inteligentes no Ethereum.

#### ğŸŒ **Onde Solidity Ã© Usado?**

**Analogia**: Como **idiomas do mundo real**:

- **PortuguÃªs**: Usado no Brasil, Portugal, alguns paÃ­ses da Ãfrica
- **InglÃªs**: Usado nos EUA, Inglaterra, AustrÃ¡lia
- **Solidity**: Usado em **blockchains compatÃ­veis com Ethereum**

**Principais blockchains que "falam" Solidity**:
- ğŸ”· **Ethereum** (a blockchain original)
- ğŸŸ£ **Polygon** (mais rÃ¡pida e barata)
- ğŸŸ¡ **Binance Smart Chain** (BSC)
- ğŸ”µ **Avalanche** 
- âšª **Arbitrum** e **Optimism** (Layer 2 do Ethereum)

#### ğŸ“š **Conceitos BÃ¡sicos de Solidity**

#### ğŸ—ï¸ **1. Struct - O "FormulÃ¡rio PadrÃ£o"**

```solidity
struct Task {
    uint256 id;
    string title;
    bool isCompleted;
}
```

**Analogia**: Como **formulÃ¡rio de cadastro** mÃ©dico:

- **Struct** = O **modelo em branco** do formulÃ¡rio
- Cada struct define **exatamente quais campos** existem
- Ã‰ como dizer: "Todo paciente tem: Nome, CPF, Idade"
- **ReutilizÃ¡vel**: VocÃª pode preencher **milhares** de formulÃ¡rios iguais

**No nosso caso**:
- `Task` = Modelo do formulÃ¡rio de tarefa
- Toda tarefa **sempre** tem: id, tÃ­tulo, descriÃ§Ã£o, prazo, etc.
- Ã‰ como ter um **"carimbo"** que sempre cria fichas idÃªnticas

#### ğŸ’¾ **2. Memory vs Storage - "Caderno vs Arquivo"**

**Analogia**: Como **diferentes tipos de anotaÃ§Ã£o**:

**ğŸ“ Memory - "Rascunho"**:
```solidity
string memory tempTitle = "Estudar Solidity";
```
- Ã‰ como escrever num **papel rascunho**
- **TemporÃ¡rio**: Depois que a funÃ§Ã£o termina, some
- **RÃ¡pido**: NÃ£o custa muito gas
- **Uso**: Calculations, variÃ¡veis temporÃ¡rias

**ğŸ“ Storage - "Arquivo Permanente"**:
```solidity
Task storage task = tasks[1];  // Pegando uma tarefa jÃ¡ salva
task.isCompleted = true;       // Modificando permanentemente
```
- Ã‰ como escrever num **arquivo oficial**
- **Permanente**: Fica gravado na blockchain para sempre
- **Caro**: Custa mais gas (vocÃª estÃ¡ pagando pelo "papel oficial")
- **Uso**: Dados que precisam ser salvos

**Exemplo PrÃ¡tico**:
```solidity
function completeTask(uint256 _taskId) public {
    string memory message = "Completing task...";  // MEMORY (temporÃ¡rio)
    Task storage task = tasks[_taskId];             // STORAGE (permanente)
    task.isCompleted = true;                        // Modifica permanentemente
}
```

#### ğŸ”¢ **3. Tipos de Dados BÃ¡sicos**

**Analogia**: Como **tipos de gaveta** para guardar coisas:

```solidity
uint256 public totalTasks;           // Gaveta para NÃšMEROS (sempre positivos)
string public title;                 // Gaveta para TEXTO
bool public isCompleted;             // Gaveta para SIM/NÃƒO
address public creator;              // Gaveta para ENDEREÃ‡OS da blockchain
mapping(uint256 => Task) tasks;      // Gaveta para DICIONÃRIOS (chave â†’ valor)
```

- **`uint256`**: Como gaveta para **"nÃºmeros grandes positivos"** (0, 1, 2, 1000000...)
- **`string`**: Como gaveta para **"textos"** ("JoÃ£o", "Estudar Solidity")
- **`bool`**: Como gaveta para **"verdadeiro/falso"** (true/false, sim/nÃ£o)
- **`address`**: Como gaveta para **"CPF da blockchain"** (0x1a2b3c4d...)
- **`mapping`**: Como gaveta para **"agenda telefÃ´nica"** (nome â†’ telefone)

#### ğŸ›¡ï¸ **4. Modificadores de Visibilidade**

**Analogia**: Como **nÃ­veis de privacidade** numa empresa:

```solidity
uint256 public totalTasks;     // PÃšBLICO - Qualquer um pode ver
uint256 private secretData;    // PRIVADO - SÃ³ este contrato vÃª
uint256 internal teamData;     // INTERNO - SÃ³ "funcionÃ¡rios" (contratos filhos) veem
```

- **`public`**: Como **"mural da empresa"** - todo mundo pode ler
- **`private`**: Como **"cofre do diretor"** - sÃ³ o prÃ³prio contrato acessa
- **`internal`**: Como **"pasta da equipe"** - sÃ³ contratos "da famÃ­lia" acessam

#### âš¡ **5. Functions - As "MÃ¡quinas" do Contrato**

```solidity
function createTask(string memory _title) public payable returns (uint256) {
    // CÃ³digo aqui
    return newTaskId;
}
```

**Partes da funÃ§Ã£o**:
- **`function`**: "Esta Ã© uma mÃ¡quina"
- **`createTask`**: Nome da mÃ¡quina
- **`(string memory _title)`**: "Ingredientes" que vocÃª coloca na mÃ¡quina
- **`public`**: "Qualquer um pode usar esta mÃ¡quina"
- **`payable`**: "Esta mÃ¡quina aceita dinheiro"
- **`returns (uint256)`**: "Esta mÃ¡quina devolve um nÃºmero"

### ğŸ”¨ Framework Foundry - A "Oficina Profissional"

**Foundry** Ã© como uma **oficina mecÃ¢nica completa** para desenvolver smart contracts.

#### ğŸ¯ **Por que Foundry Ã© Especial?**

**Analogia**: Comparando **oficinas**:

**ğŸ”§ Oficina Antiga (Remix, Truffle)**:
- Como oficina de **"fundo de quintal"**
- Ferramentas bÃ¡sicas
- Tudo manual e lento
- DifÃ­cil de organizar projetos grandes

**ğŸ­ Foundry - "Oficina da Mercedes"**:
- Como oficina **profissional de montadora**
- Ferramentas de Ãºltima geraÃ§Ã£o
- Tudo automatizado e rÃ¡pido
- OrganizaÃ§Ã£o industrial

#### âš™ï¸ **Ferramentas do Foundry**

**1. ğŸ”¨ Forge - O "Martelo Inteligente"**:
```bash
forge build    # ConstrÃ³i o contrato
forge test     # Testa todas as funcionalidades
forge deploy   # Coloca na blockchain
```
- **Analogia**: Como **robÃ´ de montagem** que faz tudo automaticamente

**2. ğŸ“Š Cast - O "Medidor Universal"**:
```bash
cast call 0x... "totalTasks()"  # Consulta dados do contrato
cast send 0x... "createTask()"  # Executa funÃ§Ã£o
```
- **Analogia**: Como **multÃ­metro profissional** que mede qualquer coisa

**3. âš¡ Anvil - A "Bancada de Teste"**:
```bash
anvil  # Cria blockchain local para testes
```
- **Analogia**: Como **bancada com todos os equipamentos** para testar peÃ§as

#### ğŸš€ **Vantagens do Foundry**

**1. ğŸƒâ€â™‚ï¸ Velocidade Extrema**:
- **Testes rodam em milissegundos** (vs. segundos em outras ferramentas)
- Como comparar **Ferrari vs. bicicleta**

**2. ğŸ§ª Testes em Solidity**:
- VocÃª escreve testes **na mesma linguagem** do contrato
- Como mecÃ¢nico **usar as mesmas ferramentas** para construir e testar

**3. ğŸ“¦ GestÃ£o de DependÃªncias**:
```bash
forge install OpenZeppelin/openzeppelin-contracts
```
- Como **loja de auto-peÃ§as integrada** na oficina

**4. ğŸ” Debugging AvanÃ§ado**:
- Mostra **exatamente onde** o erro aconteceu
- Como **raio-X** que mostra problema interno

**5. â›½ AnÃ¡lise de Gas**:
- Calcula **exatamente quanto** cada funÃ§Ã£o custa
- Como **calculadora de combustÃ­vel** precisa

#### ğŸ“¦ **InstalaÃ§Ã£o do Foundry - "Montando sua Oficina"**

**Analogia**: Como **montar uma oficina profissional** em casa - vocÃª precisa das ferramentas certas!

#### ğŸ”§ **PrÃ©-requisitos (O que vocÃª precisa ter)**

**1. ğŸ’» Sistema Operacional CompatÃ­vel**:
- âœ… **Linux** (recomendado)
- âœ… **macOS** 
- âœ… **Windows** (via WSL - Windows Subsystem for Linux)

**Analogia**: Como verificar se sua **garagem tem espaÃ§o** para a oficina.

**2. ğŸ¦€ Rust (Linguagem de ProgramaÃ§Ã£o)**:
- Foundry Ã© escrito em **Rust**
- Ã‰ como o **"motor"** que faz tudo funcionar

**3. ğŸ“‹ Git (Controle de VersÃ£o)**:
- Para baixar bibliotecas e gerenciar cÃ³digo
- Como o **"sistema de entrega"** da oficina

#### ğŸš€ **InstalaÃ§Ã£o Passo a Passo**

#### **MÃ©todo 1: InstalaÃ§Ã£o AutomÃ¡tica (Recomendado)**

**1. ğŸ“¥ Instalar Foundry com um comando:**

```bash
curl -L https://foundry.paradigm.xyz | bash
```

**Analogia**: Como **"kit de oficina automÃ¡tico"** - um caminhÃ£o chega e instala tudo de uma vez!

**2. ğŸ”„ Reiniciar o terminal ou executar:**

```bash
source ~/.bashrc
```

**3. ğŸ“¦ Instalar as ferramentas:**

```bash
foundryup
```

**Analogia**: Como **"ligar todas as mÃ¡quinas"** da oficina pela primeira vez.

#### **MÃ©todo 2: InstalaÃ§Ã£o Manual (Para UsuÃ¡rios AvanÃ§ados)**

```bash
# 1. Instalar Rust (se nÃ£o tiver)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 2. Instalar Foundry via Cargo (gerenciador do Rust)
cargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked
```

#### **Para Windows (WSL)**

**1. ğŸªŸ Instalar WSL primeiro:**

```powershell
wsl --install Ubuntu
```

**2. ğŸ§ Dentro do WSL, seguir os passos do Linux:**

```bash
curl -L https://foundry.paradigm.xyz | bash
foundryup
```

**Analogia**: Como **"construir uma oficina dentro do porÃ£o"** (WSL Ã© como o porÃ£o do Windows).

#### âœ… **Verificando se Funcionou**

**Teste se as ferramentas estÃ£o instaladas:**

```bash
forge --version    # Deve mostrar versÃ£o do Forge
cast --version     # Deve mostrar versÃ£o do Cast  
anvil --version    # Deve mostrar versÃ£o do Anvil
```

**Analogia**: Como **"testar se todas as mÃ¡quinas ligam"** na sua nova oficina.

#### ğŸ› ï¸ **Criando seu Primeiro Projeto**

```bash
# 1. Criar novo projeto
forge init meu-primeiro-contrato

# 2. Entrar na pasta
cd meu-primeiro-contrato

# 3. Compilar contratos de exemplo
forge build

# 4. Rodar testes
forge test
```

**Estrutura criada automaticamente:**
```
meu-primeiro-contrato/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ Counter.sol           # Contrato de exemplo
â”œâ”€â”€ test/
â”‚   â””â”€â”€ Counter.t.sol         # Teste de exemplo
â”œâ”€â”€ script/
â”‚   â””â”€â”€ Counter.s.sol         # Script de deploy
â”œâ”€â”€ foundry.toml              # ConfiguraÃ§Ãµes
â””â”€â”€ lib/                      # Bibliotecas (vazio inicialmente)
```

**Analogia**: Como receber uma **"oficina prÃ©-montada"** com tudo organizado e um projeto de exemplo para vocÃª comeÃ§ar!

#### ğŸš¨ **Problemas Comuns e SoluÃ§Ãµes**

**1. ğŸ’£ "command not found: forge"**

**SoluÃ§Ã£o**: Reiniciar terminal ou executar:
```bash
source ~/.bashrc
# ou
source ~/.zshrc
```

**2. ğŸŒ InstalaÃ§Ã£o muito lenta**

**SoluÃ§Ã£o**: Usar um VPN ou tentar em horÃ¡rio diferente:
```bash
# Usar proxy se necessÃ¡rio
export https_proxy=http://proxy:port
```

**3. ğŸªŸ Problemas no Windows**

**SoluÃ§Ã£o**: Instalar WSL2:
```powershell
# No PowerShell como administrador
wsl --install
wsl --set-default-version 2
```

#### ğŸ’¡ **Dicas Pro**

**1. ğŸ”„ Manter Atualizado:**
```bash
foundryup  # Atualiza para a versÃ£o mais recente
```

**2. ğŸ“š Instalar Bibliotecas Ãšteis:**
```bash
# OpenZeppelin (biblioteca de seguranÃ§a)
forge install OpenZeppelin/openzeppelin-contracts

# Solmate (biblioteca otimizada)
forge install transmissions11/solmate
```

**3. âš™ï¸ Configurar VS Code:**
- Instalar extensÃ£o "Solidity"
- Configurar para usar Foundry como formatter

**Analogia**: Como **"personalizar sua oficina"** com ferramentas extras e organizaÃ§Ã£o prÃ³pria!

#### ğŸ’¼ **Foundry vs. Outras Ferramentas**

| CaracterÃ­stica | Foundry | Hardhat | Remix |
|---|---|---|---|
| **Velocidade** | ğŸï¸ Ferrari | ğŸš— Carro normal | ğŸš² Bicicleta |
| **Linguagem dos testes** | Solidity | JavaScript | Manual |
| **InstalaÃ§Ã£o** | 1 comando | ConfiguraÃ§Ã£o complexa | Browser |
| **Para iniciantes** | ğŸ“š Curva de aprendizado | ğŸ˜Š Mais fÃ¡cil | ğŸ¯ Muito simples |
| **Para profissionais** | ğŸ‘‘ PadrÃ£o da indÃºstria | âœ… Boa opÃ§Ã£o | âŒ Limitado |

#### ğŸ—ï¸ **Estrutura de Projeto Foundry**

```
meu-projeto/
â”œâ”€â”€ src/           # Contratos principais
â”œâ”€â”€ test/          # Testes
â”œâ”€â”€ script/        # Scripts de deploy  
â”œâ”€â”€ lib/           # Bibliotecas externas
â””â”€â”€ foundry.toml   # ConfiguraÃ§Ãµes
```

**Analogia**: Como **organizaÃ§Ã£o de oficina profissional**:
- `src/` = **"Ãrea de montagem"** (onde vocÃª constrÃ³i)
- `test/` = **"Ãrea de testes"** (onde vocÃª verifica qualidade)
- `script/` = **"Manuais de procedimento"** (como fazer deploy)
- `lib/` = **"Estoque de peÃ§as"** (bibliotecas de terceiros)

**ğŸ¯ ConclusÃ£o**: Foundry Ã© como **"evoluir de oficina caseira para fÃ¡brica da Tesla"** - mais profissional, mais rÃ¡pido, mais confiÃ¡vel!

### ğŸ“ Anatomia do Smart Contract TaskManager

Imagine que vamos construir uma **fÃ¡brica de gerenciamento de tarefas** na blockchain. Vamos dissecar cada peÃ§a desta mÃ¡quina:

#### ğŸ—ï¸ **Estrutura BÃ¡sica do Contrato - A "CertidÃ£o de Nascimento"**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract TaskManager {
    // CÃ³digo do contrato aqui
}
```

**Analogia**: Ã‰ como o **cabeÃ§alho de um documento oficial**:

- **`SPDX-License-Identifier: MIT`**: Como uma **"licenÃ§a de uso"** - MIT significa "qualquer um pode usar gratuitamente"
  - Ã‰ como colocar "DomÃ­nio PÃºblico" numa mÃºsica
  
- **`pragma solidity ^0.8.13`**: Define a **"versÃ£o do idioma"** que estamos falando
  - Como dizer "este documento estÃ¡ escrito em PortuguÃªs versÃ£o 2024"
  - `^0.8.13` = "versÃ£o 8.13 ou mais nova, mas nÃ£o versÃ£o 9"
  
- **`contract TaskManager`**: Ã‰ o **nome da nossa empresa/fÃ¡brica**
  - Como "Papelaria JoÃ£o" ou "Padaria do Seu JosÃ©"

#### ğŸ’ **VariÃ¡veis e Constantes - As "Regras da Casa"**

```solidity
uint256 public constant MINIMUM_STAKE = 0.001 ether;
uint256 public totalTasks;
```

**Analogia**: Como **regras afixadas na parede** de um estabelecimento:

- **`MINIMUM_STAKE = 0.001 ether`**: Ã‰ o **"preÃ§o mÃ­nimo da entrada"**
  - Como uma placa: "Taxa mÃ­nima: R$ 5,00"
  - `constant` = Esta regra **NUNCA muda** (como "gravada em pedra")
  - `public` = **Todos podem ver** esta regra (estÃ¡ na parede para todos lerem)
  - `uint256` = Tipo de nÃºmero (sempre positivo, muito grande)
  
- **`totalTasks`**: Ã‰ o **"contador da porta"** daqueles cinemas
  - Conta quantas pessoas (tarefas) jÃ¡ entraram
  - ComeÃ§a em 0 e vai aumentando: 1, 2, 3, 4...
  - Ã‰ como um **"odÃ´metro" de tarefas criadas**

#### ğŸ“‹ **Struct Task - Nossa "Ficha de Cadastro"**

```solidity
struct Task {
    uint256 id;           // Identificador Ãºnico
    string title;         // TÃ­tulo da tarefa
    string description;   // DescriÃ§Ã£o detalhada
    uint256 createdAt;    // Quando foi criada (timestamp)
    uint256 deadline;     // Prazo limite (timestamp)
    bool isCompleted;     // Se foi concluÃ­da (true/false)
    address creator;      // Quem criou a tarefa
    uint256 stake;        // Valor apostado em wei
    bool stakeProcessed;  // Se o stake jÃ¡ foi processado
}
```

**Analogia**: Ã‰ como uma **ficha de cadastro mÃ©dico completa**:

- **`id`**: NÃºmero da **carteirinha do paciente** (Ãºnico, nunca repete)
- **`title`**: **Nome do tratamento** ("Consulta cardiolÃ³gica")
- **`description`**: **Detalhes do procedimento** ("Exame completo do coraÃ§Ã£o")
- **`createdAt`**: **Data de abertura da ficha** (quando foi criado o cadastro)
- **`deadline`**: **Data da consulta marcada** (prazo para completar)
- **`isCompleted`**: **"Paciente compareceu?"** (âœ… Sim / âŒ NÃ£o)
- **`creator`**: **EndereÃ§o de quem fez o agendamento** (CPF da pessoa)
- **`stake`**: **Valor da consulta** (quanto foi pago)
- **`stakeProcessed`**: **"Pagamento foi processado?"** (evita cobrar duas vezes)

**Por que struct?** Ã‰ como ter um **"formulÃ¡rio padrÃ£o"** - toda tarefa tem exatamente os mesmos campos preenchidos!

#### ğŸ—ºï¸ **Mappings - Nossos "Arquivos Organizados"**

```solidity
mapping(uint256 => Task) public tasks;
mapping(address => uint256[]) public userTasks;
```

**Analogia**: Como **dois sistemas de arquivo diferentes**:

**1. `tasks` - O "Arquivo Geral por NÃºmero"**
- Ã‰ como um **arquivo mÃ©dico por nÃºmero de protocolo**
- VocÃª fala: "Quero ver a ficha nÃºmero 1" â†’ Recebe todos os dados da Tarefa 1
- `uint256` = nÃºmero da tarefa (1, 2, 3...)
- `Task` = ficha completa com todos os dados
- Ã‰ como uma **gaveta numerada**: Gaveta 1 = Ficha 1, Gaveta 2 = Ficha 2...

**2. `userTasks` - O "Ãndice por Pessoa"**
- Ã‰ como um **caderno de "quem tem consulta marcada"**
- VocÃª fala: "Quais sÃ£o as consultas do JoÃ£o?" â†’ Recebe: [1, 5, 8] (nÃºmeros das fichas dele)
- `address` = "CPF" da pessoa na blockchain (0x1a2b3c4d...)
- `uint256[]` = lista de nÃºmeros das tarefas daquela pessoa

**Exemplo prÃ¡tico**:
- JoÃ£o criou 3 tarefas (IDs: 1, 3, 5)
- Maria criou 2 tarefas (IDs: 2, 4)
- `tasks[1]` = dados completos da tarefa 1 (do JoÃ£o)
- `userTasks[JoÃ£o]` = [1, 3, 5] (lista das tarefas do JoÃ£o)

#### ğŸ“¢ **Eventos - O "Jornal da Empresa"**

```solidity
event TaskCreated(uint256 taskId, address creator, string title, uint256 deadline, uint256 stake);
event TaskCompleted(uint256 taskId, address creator, uint256 stakeReturned);
event StakeLost(uint256 taskId, address creator, uint256 stakeLost);
```

**Analogia**: Como **manchetes de jornal que ficam arquivadas para sempre**:

**ğŸ” Por que eventos?**
- A blockchain Ã© como um **"cofre fechado"** - vocÃª nÃ£o pode "bisbilhotar" o que estÃ¡ dentro
- Eventos sÃ£o como **"recortes de jornal"** que saem do cofre e ficam acessÃ­veis
- Ã‰ uma forma de **"avisar o mundo exterior"** o que aconteceu

**ğŸ“° Nossos "tipos de notÃ­cia"**:

**1. `TaskCreated` - "Nascimentos"**
- **Manchete**: "Nova tarefa foi criada!"
- **Detalhes**: ID da tarefa, quem criou, tÃ­tulo, prazo, quanto apostou
- Como anunciar: "FamÃ­lia Silva teve um bebÃª! Nome: JoÃ£o, nasceu dia 15/03"

**2. `TaskCompleted` - "Sucessos"**
- **Manchete**: "Tarefa concluÃ­da no prazo!"
- **Detalhes**: Qual tarefa, quem completou, quanto dinheiro recebeu de volta
- Como anunciar: "JoÃ£o Silva se formou! Recebeu diploma e prÃªmio de R$ 1000"

**3. `StakeLost` - "Penalties"**
- **Manchete**: "Prazo perdido!"
- **Detalhes**: Qual tarefa, quem perdeu o prazo, quanto dinheiro foi perdido
- Como anunciar: "JoÃ£o Silva perdeu aposta de R$ 500 por nÃ£o entregar projeto"

**ğŸ”— Importante**: Estes "jornais" ficam **gravados para sempre** na blockchain - qualquer site pode ler e mostrar essas notificaÃ§Ãµes!

#### ğŸ› ï¸ **FunÃ§Ã£o createTask() - A "MÃ¡quina de Fazer Tarefas"**

```solidity
function createTask(string memory _title, string memory _description, uint256 _deadline) 
    public payable
{
    // VerificaÃ§Ãµes de seguranÃ§a
    require(_deadline > block.timestamp, "Deadline must be in the future");
    require(msg.value >= MINIMUM_STAKE, "Stake must be at least 0.001 ether");

    totalTasks++;  // Incrementa contador

    // Cria nova tarefa
    tasks[totalTasks] = Task({
        id: totalTasks,
        title: _title,
        description: _description,
        createdAt: block.timestamp,
        deadline: _deadline,
        isCompleted: false,
        creator: msg.sender,
        stake: msg.value,
        stakeProcessed: false
    });

    userTasks[msg.sender].push(totalTasks);  // Adiciona Ã  lista do usuÃ¡rio
    
    emit TaskCreated(totalTasks, msg.sender, _title, _deadline, msg.value);  // Emite evento
}
```

**Analogia**: Como uma **mÃ¡quina de fazer apostas em corrida de cavalos**:

**ğŸ° Como funciona a mÃ¡quina:**

**Entrada (ParÃ¢metros)**:
- **`_title`**: Nome do seu cavalo ("Estudar Solidity")
- **`_description`**: DescriÃ§Ã£o da corrida ("Completar curso em 30 dias")
- **`_deadline`**: Data da corrida (timestamp futuro)
- **`payable`**: A mÃ¡quina **aceita dinheiro** junto com o pedido

**ğŸ›¡ï¸ SeguranÃ§as da MÃ¡quina (require)**:
```solidity
require(_deadline > block.timestamp, "Deadline must be in the future");
```
- **Analogia**: Como um **seguranÃ§a na porta** que verifica se vocÃª nÃ£o estÃ¡ tentando apostar numa corrida que jÃ¡ acabou
- `block.timestamp` = "que horas sÃ£o agora na blockchain"
- Ã‰ como dizer: "SÃ³ aceito apostas para corridas futuras!"

```solidity
require(msg.value >= MINIMUM_STAKE, "Stake must be at least 0.001 ether");
```
- **Analogia**: Como um **caixa** que verifica se vocÃª trouxe dinheiro suficiente
- `msg.value` = quanto dinheiro vocÃª colocou na mÃ¡quina
- Ã‰ como: "Aposta mÃ­nima: R$ 5,00"

**ğŸ­ ProduÃ§Ã£o da Ficha (CriaÃ§Ã£o da Task)**:
```solidity
totalTasks++;  // Gera nÃºmero sequencial da ficha
```
- Como uma **mÃ¡quina de senha do banco**: 001, 002, 003...

```solidity
tasks[totalTasks] = Task({...});
```
- **Analogia**: Como **preencher uma ficha de aposta completa**:
  - `id`: NÃºmero da sua aposta (Ãºnico)
  - `title` e `description`: Nome e detalhes do cavalo
  - `createdAt`: "Hora que fez a aposta" (agora)
  - `deadline`: "Hora da corrida"
  - `isCompleted: false`: "Corrida ainda nÃ£o aconteceu"
  - `creator`: "Seu CPF" (quem fez a aposta)
  - `stake`: "Quanto vocÃª apostou"
  - `stakeProcessed: false`: "Pagamento ainda nÃ£o foi processado"

**ğŸ“ OrganizaÃ§Ã£o (userTasks)**:
```solidity
userTasks[msg.sender].push(totalTasks);
```
- **Analogia**: Como **anotar no seu caderno pessoal**: "Apostas que fiz: 1, 5, 12"
- A mÃ¡quina lembra **todas as suas apostas**

**ğŸ“¢ DivulgaÃ§Ã£o (Evento)**:
```solidity
emit TaskCreated(...);
```
- **Analogia**: Como **anunciar no alto-falante**: "JoÃ£o Silva fez aposta #5 no cavalo 'Estudar Solidity' para corrida do dia 15!"
- Todo mundo pode **ouvir** este anÃºncio

#### âœ… **FunÃ§Ã£o completeTask() - O "Juiz da Corrida"**

```solidity
function completeTask(uint256 _taskId) public
{
    // VerificaÃ§Ãµes
    require(_taskId > 0 && _taskId <= totalTasks, "Task does not exist");
    require(tasks[_taskId].creator == msg.sender, "Only task creator can call this function");
    
    Task storage task = tasks[_taskId];
    require(!task.isCompleted, "Task is already completed");
    require(!task.stakeProcessed, "Stake has already been processed");

    task.isCompleted = true;
    task.stakeProcessed = true;

    // LÃ³gica do stake
    if (block.timestamp <= task.deadline) {
        // No prazo = devolve o dinheiro
        (bool success, ) = payable(task.creator).call{value: task.stake}("");
        require(success, "Failed to return stake");
        emit TaskCompleted(_taskId, task.creator, task.stake);
    } else {
        // Atrasado = perde o dinheiro
        emit StakeLost(_taskId, task.creator, task.stake);
    }
}
```

**Analogia**: Como um **juiz rigoroso de corrida** que decide se vocÃª ganhou ou perdeu a aposta:

**ğŸ” VerificaÃ§Ãµes do Juiz (requires)**:

```solidity
require(_taskId > 0 && _taskId <= totalTasks, "Task does not exist");
```
- **Analogia**: "Esta aposta existe?" - Como verificar se o **bilhete Ã© vÃ¡lido**
- Evita que alguÃ©m invente nÃºmeros de apostas

```solidity
require(tasks[_taskId].creator == msg.sender, "Only task creator can call this function");
```
- **Analogia**: "VocÃª Ã© realmente dono desta aposta?" - Como pedir **documento de identidade**
- SÃ³ quem fez a aposta pode reivindicar o prÃªmio

```solidity
require(!task.isCompleted, "Task is already completed");
require(!task.stakeProcessed, "Stake has already been processed");
```
- **Analogia**: "Esta corrida jÃ¡ foi julgada?" - Evita **duplicar pagamentos**
- Como carimbar "PAGO" no bilhete para nÃ£o pagar duas vezes

**ğŸ“ MarcaÃ§Ã£o dos Resultados**:
```solidity
task.isCompleted = true;
task.stakeProcessed = true;
```
- **Analogia**: Carimbar na ficha: **"CORRIDA FINALIZADA"** e **"PAGAMENTO PROCESSADO"**

**ğŸ’° A Grande DecisÃ£o - LÃ³gica do Pagamento**:
```solidity
if (block.timestamp <= task.deadline) {
    // GANHOU!
} else {
    // PERDEU!
}
```

**ğŸ¯ CENÃRIO 1 - GANHOU (No prazo)**:
```solidity
(bool success, ) = payable(task.creator).call{value: task.stake}("");
require(success, "Failed to return stake");
emit TaskCompleted(_taskId, task.creator, task.stake);
```
- **Analogia**: Como o **caixa do hipÃ³dromo pagando sua aposta**
- `payable(task.creator).call{value: task.stake}("")` = "Transferir dinheiro para o ganhador"
- `require(success...)` = "Garantir que o dinheiro chegou na conta"
- `emit TaskCompleted(...)` = "Anunciar no alto-falante: JoÃ£o ganhou R$ 100!"

**ğŸ’¸ CENÃRIO 2 - PERDEU (Atrasado)**:
```solidity
emit StakeLost(_taskId, task.creator, task.stake);
```
- **Analogia**: Como **rasgar o bilhete de aposta perdida**
- O dinheiro fica "na casa" (no contrato)
- `emit StakeLost(...)` = "Anunciar: JoÃ£o perdeu R$ 100 por atraso"

**ğŸ° Sistema de Incentivos**:
- â° **Chegou no prazo**: Dinheiro volta 100% + sensaÃ§Ã£o de vitÃ³ria
- âŒ **Atrasou**: Perde o dinheiro + liÃ§Ã£o aprendida
- ğŸ§  **Psicologia**: A possibilidade de perder dinheiro **motiva** vocÃª a cumprir prazos!

#### ğŸ“‹ **FunÃ§Ãµes de Consulta**

```solidity
// Pega tarefas de qualquer usuÃ¡rio
function getUserTasks(address _user) public view returns (uint256[] memory) {
    return userTasks[_user];
}

// Pega suas prÃ³prias tarefas
function getMyTasks() public view returns (uint256[] memory) {
    return userTasks[msg.sender];
}

// Verifica se uma tarefa estÃ¡ atrasada
function isTaskOverdue(uint256 _taskId) public view returns (bool) {
    require(_taskId > 0 && _taskId <= totalTasks, "Task does not exist");
    Task memory task = tasks[_taskId];
    return (block.timestamp > task.deadline && !task.isCompleted);
}
```

### ğŸ§ª LaboratÃ³rio de Testes (TaskManager.t.sol)

Os testes sÃ£o como **laboratÃ³rio de qualidade** - testamos tudo antes de lanÃ§ar no mercado:

#### ğŸ”§ **PreparaÃ§Ã£o do LaboratÃ³rio (Setup)**

```solidity
contract TaskManagerTest is Test {
    TaskManager public taskManager;
    address public user1 = address(0x1);
    
    function setUp() public {
        taskManager = new TaskManager();
        vm.deal(user1, 10 ether);  // DÃ¡ dinheiro fake para testes
    }
}
```

**Analogia**: Como **montar um laboratÃ³rio de teste** para carros:

- **`TaskManager public taskManager`**: Ã‰ o **"carro protÃ³tipo"** que vamos testar
- **`address public user1 = address(0x1)`**: Ã‰ o **"motorista de teste"** (boneco de crash test)
- **`taskManager = new TaskManager()`**: **"Construir um carro novo"** para cada teste
- **`vm.deal(user1, 10 ether)`**: **"Dar combustÃ­vel"** para o motorista de teste
- **`setUp()`**: Roda **antes de cada teste** - como resetar o laboratÃ³rio

#### âœ… **Teste 1: testCreateTask() - "Teste de IgniÃ§Ã£o"**

```solidity
function testCreateTask() public {
    vm.startPrank(user1);  // Simula que user1 estÃ¡ dirigindo
    
    taskManager.createTask{value: stake}(title, description, deadline);
    
    // Verifica se os dados foram salvos corretamente
    (uint256 id, string memory taskTitle, ...) = taskManager.tasks(1);
    assertEq(id, 1);
    assertEq(taskTitle, title);
    // ... mais verificaÃ§Ãµes
}
```

**Analogia**: Como **testar se o carro liga**:

**ğŸ”‘ PreparaÃ§Ã£o do Teste**:
```solidity
vm.startPrank(user1);
```
- **Analogia**: **"Colocar o motorista no banco do motorista"**
- `vm.startPrank()` = simula que user1 estÃ¡ fazendo as aÃ§Ãµes

**ğŸš— AÃ§Ã£o Testada**:
```solidity
taskManager.createTask{value: stake}(title, description, deadline);
```
- **Analogia**: **"Virar a chave e pisar no acelerador"**
- Testamos se a "criaÃ§Ã£o de tarefa" funciona

**ğŸ” VerificaÃ§Ã£o**:
```solidity
(uint256 id, string memory taskTitle, ...) = taskManager.tasks(1);
assertEq(id, 1);
assertEq(taskTitle, title);
```
- **Analogia**: **"Verificar se o motor ligou corretamente"**
- `taskManager.tasks(1)` = "Olhar o painel do carro"
- `assertEq()` = "Confirmar que o velocÃ­metro mostra 0 km/h"

**O que este teste garante**:
- âœ… O "motor" da criaÃ§Ã£o de tarefas funciona
- âœ… Os "dados do painel" estÃ£o corretos
- âœ… O "contador" estÃ¡ funcionando

#### âœ… **Teste 2: testCompleteTask() - "Teste de Freios"**

```solidity
function testCompleteTask() public {
    // Primeiro cria uma tarefa
    taskManager.createTask{value: stake}(title, description, deadline);
    
    uint256 balanceBefore = user1.balance;
    taskManager.completeTask(1);  // Completa a tarefa
    uint256 balanceAfter = user1.balance;
    
    // Verifica se o dinheiro voltou
    assertEq(balanceAfter, balanceBefore + stake);
}
```

**Analogia**: Como **testar se os freios funcionam**:

**ğŸ PreparaÃ§Ã£o**:
```solidity
taskManager.createTask{value: stake}(title, description, deadline);
```
- **Analogia**: **"Acelerar o carro atÃ© 100 km/h"** (criar a tarefa)

**ğŸ“Š MediÃ§Ã£o Inicial**:
```solidity
uint256 balanceBefore = user1.balance;
```
- **Analogia**: **"Medir a velocidade antes de frear"** (dinheiro antes)

**ğŸ›‘ AÃ§Ã£o de Teste**:
```solidity
taskManager.completeTask(1);
```
- **Analogia**: **"Pisar no freio"** (completar a tarefa)

**ğŸ“Š VerificaÃ§Ã£o Final**:
```solidity
uint256 balanceAfter = user1.balance;
assertEq(balanceAfter, balanceBefore + stake);
```
- **Analogia**: **"Confirmar que o carro parou"** (dinheiro voltou)
- Se o dinheiro nÃ£o voltou = "freios falharam"

**O que este teste garante**:
- âœ… O "sistema de freios" (conclusÃ£o) funciona
- âœ… O "airbag" (devoluÃ§Ã£o de dinheiro) ativa corretamente
- âœ… A "frenagem" acontece no tempo certo

#### ğŸ“‹ **Teste 3: testGetMyTasks() - "Teste do GPS"**

```solidity
function testGetMyTasks() public {
    // Cria 3 tarefas
    taskManager.createTask{value: stake}("Tarefa 1", description, deadline);
    taskManager.createTask{value: stake}("Tarefa 2", description, deadline);
    taskManager.createTask{value: stake}("Tarefa 3", description, deadline);
    
    // Verifica se a lista estÃ¡ correta
    uint256[] memory myTasks = taskManager.getMyTasks();
    assertEq(myTasks.length, 3);
    assertEq(myTasks[0], 1);  // Primeira tarefa tem ID 1
}
```

**Analogia**: Como **testar se o GPS funciona**:

**ğŸ—ºï¸ CriaÃ§Ã£o do Percurso**:
```solidity
taskManager.createTask{value: stake}("Tarefa 1", description, deadline);
taskManager.createTask{value: stake}("Tarefa 2", description, deadline);
taskManager.createTask{value: stake}("Tarefa 3", description, deadline);
```
- **Analogia**: **"Programar 3 destinos no GPS"**: Casa â†’ Trabalho â†’ Shopping

**ğŸ“± Consulta do GPS**:
```solidity
uint256[] memory myTasks = taskManager.getMyTasks();
```
- **Analogia**: **"Perguntar ao GPS: onde estÃ£o meus destinos?"**

**ğŸ” VerificaÃ§Ã£o da Lista**:
```solidity
assertEq(myTasks.length, 3);
assertEq(myTasks[0], 1);
```
- **Analogia**: **"Conferir se o GPS lembra dos 3 destinos"**
- **"Confirmar que o primeiro destino Ã© o nÃºmero 1"**

**O que este teste garante**:
- âœ… O "GPS" (funÃ§Ã£o de listar) funciona
- âœ… A "memÃ³ria" (storage) guarda tudo corretamente
- âœ… A "ordem" dos destinos estÃ¡ certa

#### ğŸ¯ **Por que Fazer Estes Testes?**

**Analogia**: Como **testar um carro antes de vender**:

- **ğŸ›¡ï¸ SeguranÃ§a**: Evita que o "carro exploda" (bugs que perdem dinheiro)
- **ğŸ”„ ConfianÃ§a**: Se vocÃª mudar o "motor" (cÃ³digo), testa se ainda funciona
- **ğŸ“Š Cobertura**: Testa "subida", "descida", "chuva", "sol" (diferentes cenÃ¡rios)  
- **âš¡ Rapidez**: Encontra problemas no "laboratÃ³rio", nÃ£o na "estrada" (produÃ§Ã£o)
- **ğŸ’° Economia**: Ã‰ mais barato consertar no laboratÃ³rio que pagar indenizaÃ§Ã£o

**ğŸš¨ Sem testes Ã© como**:
- Vender carro sem testar freios
- LanÃ§ar remÃ©dio sem testar efeitos
- Construir prÃ©dio sem testar fundaÃ§Ã£o

**âœ… Com testes Ã© como**:
- Certificado de qualidade
- Seguro total
- Garantia que funciona

#### ğŸ¯ **Dicas de Testes Adicionais - "Expandindo o LaboratÃ³rio"**

Nosso contrato atual tem 3 testes bÃ¡sicos, mas poderÃ­amos **"testar muito mais"**! Aqui estÃ£o ideias de **testes que vocÃª pode implementar**:

#### ğŸ›¡ï¸ **Testes de SeguranÃ§a - "Teste de InvasÃ£o"**

**Analogia**: Como **testar a seguranÃ§a de um banco** - tentar todas as formas de roubar!

**1. Teste de AutorizaÃ§Ã£o:**
```solidity
function testOnlyOwnerCanComplete() public {
    // UsuÃ¡rio 1 cria tarefa
    // UsuÃ¡rio 2 tenta completar tarefa do usuÃ¡rio 1
    // Deve FALHAR
}
```
- **O que testa**: Se alguÃ©m pode completar tarefa de outra pessoa
- **Analogia**: Como testar se **vizinho pode sacar na sua conta**

**2. Teste de Double Spending:**
```solidity
function testCannotCompleteTaskTwice() public {
    // Criar tarefa
    // Completar uma vez (sucesso)
    // Tentar completar segunda vez (deve falhar)
}
```
- **O que testa**: Se Ã© possÃ­vel receber dinheiro duas vezes
- **Analogia**: Como testar se dÃ¡ para **sacar o prÃªmio duas vezes**

**3. Teste de Overflow/Underflow:**
```solidity
function testMassiveTaskCreation() public {
    // Criar 1000+ tarefas
    // Verificar se totalTasks nÃ£o "quebra"
}
```
- **O que testa**: Se o contador aguenta nÃºmeros gigantes
- **Analogia**: Como testar se **odÃ´metro nÃ£o volta ao zero** quando chega ao limite

#### â° **Testes de Tempo - "Teste da MÃ¡quina do Tempo"**

**Analogia**: Como **testar diferentes cenÃ¡rios temporais** numa corrida!

**1. Teste de Tarefa Atrasada:**
```solidity
function testLateTaskCompletion() public {
    // Criar tarefa com prazo de 1 dia
    // AvanÃ§ar tempo para 2 dias (vm.warp)
    // Completar tarefa
    // Verificar se stake foi perdido (nÃ£o devolvido)
}
```
- **O que testa**: Se stake Ã© realmente perdido quando atrasado
- **Analogia**: **Chegar atrasado na corrida** e perder a aposta

**2. Teste de VerificaÃ§Ã£o de Atraso:**
```solidity
function testIsTaskOverdueLogic() public {
    // Criar tarefa
    // Verificar que nÃ£o estÃ¡ atrasada
    // AvanÃ§ar tempo apÃ³s prazo
    // Verificar que estÃ¡ atrasada
    // Completar tarefa
    // Verificar que nÃ£o estÃ¡ mais "atrasada" (foi concluÃ­da)
}
```
- **O que testa**: Se a lÃ³gica de "atrasado" funciona corretamente
- **Analogia**: **CronÃ´metro da corrida** estÃ¡ funcionando direito

#### ğŸ’° **Testes Financeiros - "Teste do Cofre"**

**Analogia**: Como **testar todos os cenÃ¡rios de dinheiro** num cassino!

**1. Teste de Stake Insuficiente:**
```solidity
function testInsufficientStake() public {
    // Tentar criar tarefa com 0.0001 ether (menos que mÃ­nimo)
    // Deve FALHAR
}
```
- **O que testa**: Se valores baixos sÃ£o rejeitados
- **Analogia**: **Tentar apostar centavos** numa mesa que exige reais

**2. Teste de Stake Exato:**
```solidity
function testExactMinimumStake() public {
    // Criar tarefa com exatamente 0.001 ether
    // Deve FUNCIONAR
}
```
- **O que testa**: Se o valor mÃ­nimo exato Ã© aceito
- **Analogia**: **Apostar exatamente o mÃ­nimo** permitido

**3. Teste de Stakes Diferentes:**
```solidity
function testDifferentStakeAmounts() public {
    // Criar tarefas com 0.001, 0.01, 0.1, 1 ether
    // Completar todas no prazo
    // Verificar se cada um recebeu o valor correto de volta
}
```
- **O que testa**: Se valores diferentes sÃ£o manuseados corretamente
- **Analogia**: **Apostas de valores diferentes** na mesma corrida

#### ğŸ“Š **Testes de Estado - "Teste do InventÃ¡rio"**

**Analogia**: Como **conferir se o estoque** da loja estÃ¡ correto!

**1. Teste de Contador Global:**
```solidity
function testTotalTasksIncrement() public {
    uint256 initialCount = taskManager.totalTasks();
    
    // Criar 3 tarefas
    // Verificar se totalTasks aumentou em 3
    
    assertEq(taskManager.totalTasks(), initialCount + 3);
}
```
- **O que testa**: Se o contador global estÃ¡ certo
- **Analogia**: **Conferir se o caixa** registrou todas as vendas

**2. Teste de Lista de UsuÃ¡rio:**
```solidity
function testUserTasksList() public {
    // UsuÃ¡rio A cria 2 tarefas
    // UsuÃ¡rio B cria 3 tarefas
    // Verificar se cada um tem a quantidade correta na sua lista
    // Verificar se as listas nÃ£o se misturam
}
```
- **O que testa**: Se cada usuÃ¡rio vÃª apenas suas tarefas
- **Analogia**: **Cada cliente sÃ³ vÃª seus prÃ³prios pedidos**

#### ğŸ² **Testes de Casos Extremos - "Teste do ImpossÃ­vel"**

**Analogia**: Como **testar situaÃ§Ãµes malucas** que provavelmente nunca vÃ£o acontecer!

**1. Teste de Deadline no Futuro Distante:**
```solidity
function testFarFutureDeadline() public {
    // Criar tarefa com deadline em 100 anos
    // Deve funcionar normalmente
}
```
- **O que testa**: Se o contrato aguenta datas muito futuras
- **Analogia**: **Apostar numa corrida de 2124**

**2. Teste de String Vazia:**
```solidity
function testEmptyTaskTitle() public {
    // Tentar criar tarefa com tÃ­tulo vazio ""
    // Pode aceitar ou rejeitar (depende da regra)
}
```
- **O que testa**: Como o contrato lida com dados vazios
- **Analogia**: **Apostar sem dar nome ao cavalo**

**3. Teste de String Gigante:**
```solidity
function testMassiveTaskDescription() public {
    // Criar tarefa com descriÃ§Ã£o de 10.000 caracteres
    // Verificar custo de gas e funcionamento
}
```
- **O que testa**: Se textos enormes causam problemas
- **Analogia**: **Escrever uma redaÃ§Ã£o de 50 pÃ¡ginas** como descriÃ§Ã£o

#### ğŸ† **Testes de Performance - "Teste de Velocidade"**

**Analogia**: Como **testar se o carro aguenta** FÃ³rmula 1!

**1. Teste de Gas Cost:**
```solidity
function testGasCosts() public {
    // Medir gas de createTask
    // Medir gas de completeTask
    // Verificar se estÃ¡ dentro de limites aceitÃ¡veis
}
```
- **O que testa**: Quanto "combustÃ­vel" cada funÃ§Ã£o gasta
- **Analogia**: **Testar consumo** de cada carro

**2. Teste de Stress:**
```solidity
function testStressTest() public {
    // Criar 100 tarefas em sequÃªncia
    // Completar todas
    // Verificar se tudo ainda funciona
}
```
- **O que testa**: Se o contrato aguenta uso intenso
- **Analogia**: **Dirigir 1000km** sem parar para ver se quebra

#### ğŸ’¡ **Como Implementar Estes Testes**

**1. ğŸ“ Organizar por Categoria:**
```
test/
â”œâ”€â”€ TestSecurity.t.sol     # Testes de seguranÃ§a
â”œâ”€â”€ TestTiming.t.sol       # Testes de tempo
â”œâ”€â”€ TestFinancial.t.sol    # Testes financeiros
â”œâ”€â”€ TestState.t.sol        # Testes de estado
â””â”€â”€ TestEdgeCases.t.sol    # Casos extremos
```

**2. ğŸ¯ Usar Foundry Features:**
```solidity
// Testar com fuzzing (dados aleatÃ³rios)
function testFuzzCreateTask(string memory title, uint256 deadline) public {
    vm.assume(deadline > block.timestamp);
    // Foundry vai testar com centenas de valores aleatÃ³rios
}

// Testar invariants (regras que nunca devem quebrar)
function invariant_totalTasksNeverDecrease() public {
    // Esta regra deve ser sempre verdadeira
    assert(taskManager.totalTasks() >= previousTotalTasks);
}
```

**3. ğŸš¨ Usar vm Commands:**
```solidity
vm.warp(timestamp);        // Viajar no tempo
vm.deal(user, amount);     // Dar dinheiro fake
vm.expectRevert("error");  // Esperar que falhe
vm.startPrank(user);       // Simular outro usuÃ¡rio
```

**ğŸ¯ Meta**: Com estes testes, seu contrato fica **blindado** como Fort Knox! ğŸ°

### ğŸš€ Script de Deploy (DeployTaskManager.s.sol)

O script de deploy Ã© como um **"manual de instalaÃ§Ã£o"** do nosso contrato na blockchain:

#### ğŸ—ï¸ **Estrutura do Script de Deploy**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Script.sol";
import "../src/TaskManager.sol";

contract DeployTaskManager is Script {
    function setUp() public {}

    function run() public {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        vm.startBroadcast(deployerPrivateKey);

        TaskManager taskManager = new TaskManager();
        
        console.log("TaskManager deployed at:", address(taskManager));
        console.log("Deployer address:", vm.addr(deployerPrivateKey));
        console.log("Minimum stake required:", taskManager.MINIMUM_STAKE());

        vm.stopBroadcast();
    }
}
```

**Analogia**: Como **abrir uma nova loja fÃ­sica**:

#### ğŸ“‹ **PreparaÃ§Ã£o (Imports)**
```solidity
import "forge-std/Script.sol";
import "../src/TaskManager.sol";
```
- **Analogia**: Como **reunir todas as ferramentas** necessÃ¡rias antes de construir
- `Script.sol` = "Kit de ferramentas para construÃ§Ã£o"
- `TaskManager.sol` = "Planta da loja que vamos construir"

#### ğŸ”‘ **AutenticaÃ§Ã£o (Private Key)**
```solidity
uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
```
- **Analogia**: Como **pegar a chave do proprietÃ¡rio** para autorizar a construÃ§Ã£o
- `PRIVATE_KEY` = Sua "chave secreta" (como a senha do banco)
- `vm.envUint()` = Pega a chave de um arquivo seguro (variÃ¡vel de ambiente)

#### ğŸ“¢ **InÃ­cio da ConstruÃ§Ã£o (startBroadcast)**
```solidity
vm.startBroadcast(deployerPrivateKey);
```
- **Analogia**: Como **avisar a prefeitura**: "Vou comeÃ§ar a construir agora!"
- A partir daqui, tudo que vocÃª fizer **custa dinheiro real** (gas)
- Ã‰ como ligar um **"taxÃ­metro"** da blockchain

#### ğŸ­ **ConstruÃ§Ã£o da Loja (new TaskManager)**
```solidity
TaskManager taskManager = new TaskManager();
```
- **Analogia**: Como **construir fisicamente a loja**
- `new TaskManager()` = "Erguer um prÃ©dio novo do zero"
- A partir daqui, sua loja existe **para sempre** na blockchain

#### ğŸ“ **RelatÃ³rio de ConclusÃ£o (console.log)**
```solidity
console.log("TaskManager deployed at:", address(taskManager));
console.log("Deployer address:", vm.addr(deployerPrivateKey));
console.log("Minimum stake required:", taskManager.MINIMUM_STAKE());
```
- **Analogia**: Como **entregar a certidÃ£o de conclusÃ£o da obra**:
  - "Loja construÃ­da no endereÃ§o: Rua A, nÂº 123"
  - "ProprietÃ¡rio: JoÃ£o Silva (CPF: 123.456.789-00)"
  - "Taxa de entrada: R$ 5,00"

#### ğŸ›‘ **Fim da ConstruÃ§Ã£o (stopBroadcast)**
```solidity
vm.stopBroadcast();
```
- **Analogia**: Como **desligar o taxÃ­metro** e avisar: "Obra concluÃ­da!"
- A partir daqui, nÃ£o gastamos mais gas

#### ğŸ¯ **Por que usar Script de Deploy?**

- **ğŸ”„ RepetÃ­vel**: Pode rodar vÃ¡rias vezes (testnet, mainnet, etc.)
- **ğŸ“ Documentado**: Fica registrado exatamente como o contrato foi criado
- **ğŸ›¡ï¸ Seguro**: Usa variÃ¡veis de ambiente para proteger chaves privadas
- **ğŸ“Š Informativo**: Mostra endereÃ§os e informaÃ§Ãµes importantes
- **âš¡ Automatizado**: Um comando sÃ³ faz tudo

**Comando para usar**:
```bash
forge script script/TaskManager.s.sol:TaskManagerScript --rpc-url <REDE> --private-key <SUA_CHAVE> --broadcast
```

**ğŸ¯ Importante**: Note que o script se chama `TaskManager.s.sol` e a classe Ã© `TaskManagerScript`. Este Ã© o comando correto baseado na estrutura real do projeto.

**Analogia**: Como usar um **"app de construÃ§Ã£o"** que faz tudo automaticamente!

### ğŸŒ Deploy Manual na Rede Sepolia - "Construindo na Cidade Real"

Agora vamos aprender a **"construir nossa loja"** numa cidade real (rede de teste), nÃ£o apenas no terreno de treino (rede local).

#### ğŸ¢ **Entendendo os Provedores - "Companhias TelefÃ´nicas da Blockchain"**

**Analogia**: Como **empresas de telecomunicaÃ§Ãµes** que conectam vocÃª Ã  internet.

**ğŸ¤” Por que precisamos de provedores?**

Imagine que vocÃª quer **ligar para alguÃ©m** numa cidade distante:
- VocÃª nÃ£o pode ir fisicamente atÃ© lÃ¡
- Precisa de uma **"empresa telefÃ´nica"** para fazer a conexÃ£o
- A empresa tem **torres e cabos** que conectam as cidades

**Na blockchain Ã© igual**:
- Sua aplicaÃ§Ã£o local nÃ£o consegue "falar" diretamente com Ethereum
- Precisa de um **"provedor RPC"** para fazer a conexÃ£o
- O provedor tem **servidores e nÃ³s** que conectam vocÃª Ã  rede

#### ğŸ“¡ **Infura - A "Operadora Premium"**

**Infura** Ã© como a **"Vivo/Claro da blockchain"** - uma empresa que oferece conexÃ£o profissional.

**ğŸ”— Outros provedores similares:**
- **Alchemy** (concorrente principal)
- **QuickNode** 
- **Moralis**
- **GetBlock**

**Analogia**: Como **operadoras de celular** - todas fazem a mesma coisa (conectar), mas com preÃ§os e qualidades diferentes.

#### ğŸ—ï¸ **Obtendo API Key da Infura - "Seu CartÃ£o de Acesso"**

**Passo a passo para pegar sua "linha telefÃ´nica":**

**1. ğŸ“ Criar Conta na Infura:**
- Acesse: https://infura.io/
- Clique em **"Sign Up"** (criar conta)
- Use um email vÃ¡lido (vocÃª receberÃ¡ confirmaÃ§Ã£o)

**Analogia**: Como **"contratar um plano de celular"** numa operadora.

**2. âœ… Confirmar Email:**
- VÃ¡ ao seu email
- Clique no link de confirmaÃ§Ã£o
- FaÃ§a login na Infura

**3. ğŸ¯ Criar um Projeto:**
- No painel, clique **"Create New Key"**
- **Name**: "TaskManager Project" (ou qualquer nome)
- **Network**: **"Web3 API"** (nÃ£o Ethereum 2.0)
- Clique **"Create"**

**Analogia**: Como **"registrar um novo nÃºmero"** na operadora.

**4. ğŸ“‹ Copiar as URLs:**

ApÃ³s criar, vocÃª verÃ¡ algo assim:
```
PROJECT ID: 9aa3d95b3bc440fa88ea12eaa4456161

ENDPOINTS:
Mainnet: https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161
Sepolia: https://sepolia.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161
```

**ğŸ¯ Importante**: Copie a URL da **Sepolia** - Ã© ela que vamos usar!

**Analogia**: Como **"pegar seu nÃºmero de telefone"** depois de contratar o plano.

#### ğŸ” **Etherscan - O "Google da Blockchain"**

**Etherscan** Ã© como o **"Google"** da blockchain Ethereum - vocÃª pode pesquisar qualquer coisa.

**ğŸŒ Links importantes:**
- **Mainnet**: https://etherscan.io/ (rede principal)
- **Sepolia**: https://sepolia.etherscan.io/ (rede de teste)

**O que vocÃª pode fazer no Etherscan:**
- ğŸ” **Pesquisar transaÃ§Ãµes** (como rastrear encomenda dos Correios)
- ğŸ‘€ **Ver contratos** deployados (como ver lojas numa rua)
- ğŸ’° **Verificar saldos** (como extrato bancÃ¡rio)
- â›½ **Monitorar gas** (como preÃ§o da gasolina)

#### ğŸ”‘ **Configurando API Key do Etherscan**

**Por que precisamos?**
- Para **verificar contratos** automaticamente
- Como ter **"acesso VIP"** ao Google da blockchain

**Passo a passo:**

**1. ğŸ“ Criar Conta no Etherscan:**
- Acesse: https://etherscan.io/
- Clique **"Sign In"** â†’ **"Click to sign up"**
- Registre-se com email

**2. ğŸ—ï¸ Gerar API Key:**
- FaÃ§a login
- VÃ¡ em **"API Keys"** (no menu do usuÃ¡rio)
- Clique **"Add"** 
- **App Name**: "TaskManager"
- Copie a **API Key** gerada

**Exemplo da API Key:**
```
YourApiKeyToken: ABC123DEF456GHI789JKL012MNO345PQR678
```

**Analogia**: Como **"pegar cartÃ£o VIP"** para ter acesso especial ao shopping.

#### ğŸ¦Š **MetaMask - Sua "Carteira Digital"**

**MetaMask** Ã© como sua **"carteira fÃ­sica"**, mas para criptomoedas.

#### ğŸ“¥ **Instalando MetaMask:**

**1. ğŸ’» Instalar ExtensÃ£o:**
- Acesse: https://metamask.io/
- Clique **"Download"**
- Adicione ao Chrome/Firefox/Safari

**2. ğŸ†• Criar Carteira Nova:**
- Abra a extensÃ£o
- **"Create a new wallet"**
- Criar senha forte
- **âš ï¸ ANOTAR AS 12 PALAVRAS** (seed phrase) num papel

**Analogia**: As 12 palavras sÃ£o como **"chave mestre do cofre"** - se perder, perde tudo!

#### ğŸŒ **Configurando Rede Sepolia:**

**Sepolia jÃ¡ vem configurada** no MetaMask moderno, mas se nÃ£o estiver:

```
Network Name: Sepolia test network
New RPC URL: https://sepolia.infura.io/v3/SEU_PROJECT_ID
Chain ID: 11155111
Currency Symbol: ETH
Block Explorer: https://sepolia.etherscan.io
```

#### ğŸ’° **Conseguindo Ethereum de Teste (Sepolia ETH):**

**Analogia**: Como **"dinheiro de Monopoly"** - vale apenas no jogo (rede de teste).

**Faucets (torneiras) gratuitas:**
1. **Sepolia Faucet**: https://sepoliafaucet.com/
2. **Alchemy Faucet**: https://sepoliafaucet.com/
3. **Infura Faucet**: https://www.infura.io/faucet

**Como usar:**
- Copie seu endereÃ§o MetaMask
- Cole no faucet
- Aguarde 1-2 minutos
- Receba ~0.5 ETH de teste

#### ğŸ” **Obtendo Chave Privada - "Senha do Cofre"**

**âš ï¸ ATENÃ‡ÃƒO EXTREMA**: Chave privada Ã© como **"senha do banco"** - NUNCA compartilhe!

**Passo a passo no MetaMask:**

**1. ğŸ¦Š Abrir MetaMask:**
- Clique na extensÃ£o
- FaÃ§a login

**2. âš™ï¸ Acessar ConfiguraÃ§Ãµes:**
- Clique nos **3 pontinhos** (menu)
- **"Account Details"**

**3. ğŸ”‘ Exportar Chave:**
- **"Show private key"**
- Digite sua **senha do MetaMask**
- **Copie a chave privada**

**Exemplo de chave privada:**
```
0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
```

**ğŸš¨ SEGURANÃ‡A MÃXIMA**:
- âŒ **NUNCA** cole em sites duvidosos
- âŒ **NUNCA** compartilhe com ninguÃ©m
- âŒ **NUNCA** commit no Git
- âœ… Use apenas para deploy local/teste
- âœ… Crie uma carteira separada sÃ³ para desenvolvimento

#### ğŸš€ **Deploy Manual na Sepolia - Passo a Passo**

Agora vamos **"construir nossa loja"** na cidade real!

#### ğŸ› ï¸ **PreparaÃ§Ã£o do Ambiente:**

**1. ğŸ“ Criar arquivo .env:**

Na pasta do projeto, crie `.env`:
```bash
# .env (NUNCA commit este arquivo!)
PRIVATE_KEY=0xSUA_CHAVE_PRIVADA_AQUI
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/SEU_PROJECT_ID
ETHERSCAN_API_KEY=SUA_API_KEY_DO_ETHERSCAN
```

**2. ğŸ”’ Proteger .env:**

Adicione no `.gitignore`:
```
.env
```

**Analogia**: Como **"trancar o cofre"** onde vocÃª guarda senhas.

#### ğŸ—ï¸ **Executando o Deploy:**

**ğŸ”§ PrÃ©-requisito IMPORTANTE: Carregar VariÃ¡veis de Ambiente**

Antes de executar o comando de deploy, vocÃª **DEVE** carregar as variÃ¡veis do arquivo `.env`:

```bash
# ğŸ”‘ PRIMEIRO: Carregar as variÃ¡veis de ambiente
source .env

# âœ… Verificar se as variÃ¡veis foram carregadas
echo "RPC: $SEPOLIA_RPC_URL"
echo "Private Key configurada: $([ -n "$PRIVATE_KEY" ] && echo "âœ… SIM" || echo "âŒ NÃƒO")"
echo "Etherscan API: $([ -n "$ETHERSCAN_API_KEY" ] && echo "âœ… SIM" || echo "âŒ NÃƒO")"
```

**ğŸ’¡ Por que isso Ã© necessÃ¡rio?**
- O comando usa variÃ¡veis como `$SEPOLIA_RPC_URL`, `$PRIVATE_KEY`, `$ETHERSCAN_API_KEY`
- Sem o `source .env`, essas variÃ¡veis ficam vazias e o comando falha
- Ã‰ como **"logar no sistema"** antes de usar seus dados

**ğŸ“‹ Exemplo Visual:**

```bash
# âŒ SEM carregar .env - FALHA!
forge script script/TaskManager.s.sol:TaskManagerScript --rpc-url $SEPOLIA_RPC_URL
# Resultado: --rpc-url ""  (vazio!)

# âœ… COM source .env - FUNCIONA!
source .env
forge script script/TaskManager.s.sol:TaskManagerScript --rpc-url $SEPOLIA_RPC_URL  
# Resultado: --rpc-url "https://sepolia.infura.io/v3/1b375955f267496abf270f2423801349"
```

**ğŸ” Como as variÃ¡veis sÃ£o substituÃ­das:**
- `$SEPOLIA_RPC_URL` â†’ `https://sepolia.infura.io/v3/SEU_PROJECT_ID`
- `$PRIVATE_KEY` â†’ `0x1234567890abcdef...` (sua chave privada)
- `$ETHERSCAN_API_KEY` â†’ `ABC123DEF456...` (sua API key)

**1. ğŸ’» Comando de Deploy:**

```bash
# OpÃ§Ã£o A: Carregar variÃ¡veis E executar deploy em um comando
source .env && forge script script/TaskManager.s.sol:TaskManagerScript \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  --verify \
  --etherscan-api-key $ETHERSCAN_API_KEY \
  -vvvv

# OpÃ§Ã£o B: Carregar variÃ¡veis primeiro, depois executar
source .env
forge script script/TaskManager.s.sol:TaskManagerScript \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  --verify \
  --etherscan-api-key $ETHERSCAN_API_KEY \
  -vvvv
```

**âœ… Este Ã© o comando testado e funcionando!** Note que usamos `TaskManager.s.sol:TaskManagerScript` (nÃ£o `DeployTaskManager.s.sol`).

**Quebrado em partes:**
- `forge script` = Executar script de deploy
- `--rpc-url` = Conectar via Infura na Sepolia
- `--private-key` = Usar sua carteira para pagar gas
- `--broadcast` = Realmente enviar para blockchain
- `--verify` = Publicar cÃ³digo no Etherscan
- `-vvvv` = Mostrar TUDO que estÃ¡ acontecendo

**2. ğŸ’¸ O que acontece:**

```
[â ¢] Compiling...
[âœ…] Compilation completed successfully.

== Logs ==
TaskManager deployed at: 0x742d35Cc6636C0532925a3b8D8C9a76C4577F6B5
Deployer address: 0xYourAddress
Minimum stake required: 1000000000000000

## Setting up 1 EVM.
##
## Environment
Chain: sepolia

## Sender
Address: 0xYourAddress
Balance: 0.123456789 ETH

âœ… Transaction sent! Hash: 0xabc123...
â³ Waiting for confirmation...
âœ… Transaction confirmed!
â›½ Gas used: 1,234,567
ğŸ’° Gas cost: 0.001234 ETH
```

**3. ğŸ” VerificaÃ§Ã£o no Etherscan:**

- Acesse: https://sepolia.etherscan.io/
- Cole o endereÃ§o do contrato
- Veja seu contrato deployado!

#### ğŸ¯ **Testando o Contrato Deployado:**

**1. ğŸ“ Consultar dados (grÃ¡tis):**

```bash
# Ver total de tarefas
cast call 0xSEU_CONTRATO_ADDRESS "totalTasks()" --rpc-url $SEPOLIA_RPC_URL

# Ver stake mÃ­nimo
cast call 0xSEU_CONTRATO_ADDRESS "MINIMUM_STAKE()" --rpc-url $SEPOLIA_RPC_URL
```

**2. ğŸ“ Criar tarefa (custa gas):**

```bash
cast send 0xSEU_CONTRATO_ADDRESS \
  "createTask(string,string,uint256)" \
  "Estudar Solidity" \
  "Completar tutorial completo" \
  1703980800 \
  --value 0.001ether \
  --private-key $PRIVATE_KEY \
  --rpc-url $SEPOLIA_RPC_URL
```

#### ğŸ‰ **ParabÃ©ns! Seu Contrato estÃ¡ Vivo!**

**ğŸŒ Links Ãºteis apÃ³s deploy:**
- **Contrato**: https://sepolia.etherscan.io/address/SEU_ENDEREÃ‡O
- **CÃ³digo Verificado**: Aba "Contract" â†’ "Read Contract"
- **TransaÃ§Ãµes**: Aba "Txns" mostra todas as interaÃ§Ãµes

**Analogia**: Como **"inaugurar sua loja"** numa rua movimentada - agora todo mundo pode visitÃ¡-la!

#### ğŸš¨ **Troubleshooting - Problemas Comuns**

**Erro: "No such file or directory: script/DeployTaskManager.s.sol"**
- **âŒ Problema**: Script nÃ£o existe com esse nome
- **âœ… SoluÃ§Ã£o**: Use `script/TaskManager.s.sol:TaskManagerScript`

**Erro: "a value is required for '--fork-url' but none was supplied"**
- **âŒ Problema**: Comando quebrado em mÃºltiplas linhas
- **âœ… SoluÃ§Ã£o**: Execute o comando completo em uma linha ou use `\` para quebra

**ğŸš¨ Erro: VariÃ¡veis vazias ou "Invalid RPC URL"**
- **âŒ Problema**: NÃ£o carregou o arquivo `.env` antes do comando
- **âœ… SoluÃ§Ã£o**: SEMPRE execute `source .env` primeiro
- **ğŸ” Como verificar**: `echo $SEPOLIA_RPC_URL` deve mostrar a URL completa

**ğŸš¨ Erro: "insufficient funds for gas * price + value"**
- **âŒ Problema**: Carteira sem ETH suficiente para pagar gas
- **âœ… SoluÃ§Ã£o**: Pegue ETH de teste no faucet Sepolia

**ğŸ“‹ Checklist antes do deploy:**
```bash
# 1. Verificar se estÃ¡ na pasta smartcontract
pwd  # Deve mostrar: .../fb02/smartcontract

# 2. Verificar se arquivo .env existe
ls -la .env

# 3. Carregar variÃ¡veis
source .env

# 4. Verificar se variÃ¡veis estÃ£o carregadas
echo "âœ… RPC: $SEPOLIA_RPC_URL"
echo "âœ… Private Key: $([ -n "$PRIVATE_KEY" ] && echo "configurada" || echo "âŒ VAZIA")"
echo "âœ… Etherscan API: $([ -n "$ETHERSCAN_API_KEY" ] && echo "configurada" || echo "âŒ VAZIA")"
```

**Comando COMPLETO que FUNCIONA:**
```bash
source .env && forge script script/TaskManager.s.sol:TaskManagerScript --rpc-url $SEPOLIA_RPC_URL --private-key $PRIVATE_KEY --broadcast --verify --etherscan-api-key $ETHERSCAN_API_KEY -vvvv
```

**ğŸ¯ PrÃ³ximos passos:**
- Criar interface front-end
- Conectar MetaMask ao seu site
- Permitir que usuÃ¡rios interajam visualmente

---

## ğŸ Bonus - Prompt do Contrato

Para referÃªncia e estudo, aqui estÃ¡ o **prompt original** usado para criar o contrato TaskManager:

```
Crie um contrato inteligente em Solidity chamado "TaskManager" que permita aos usuÃ¡rios criar, gerenciar e concluir tarefas associadas a prazos e valores apostados (stakes). O contrato deve atender aos seguintes requisitos:

Estrutura de Dados

Armazenar informaÃ§Ãµes de cada tarefa, incluindo:

Um identificador Ãºnico para cada tarefa.

Um tÃ­tulo descritivo.

Uma descriÃ§Ã£o detalhada.

A data de criaÃ§Ã£o da tarefa.

Um prazo para conclusÃ£o (data futura).

O status atual da tarefa (pendente ou concluÃ­da).

O endereÃ§o do criador da tarefa.

O valor apostado (stake) associado Ã  tarefa.

Um indicador que mostre se o valor apostado jÃ¡ foi processado.

Funcionalidades Principais

Permitir que usuÃ¡rios criem novas tarefas fornecendo:

Um tÃ­tulo, uma descriÃ§Ã£o e um prazo (que deve ser uma data futura).

Um valor apostado mÃ­nimo de 0.001 ether, enviado junto com a criaÃ§Ã£o.

Restringir a conclusÃ£o de tarefas apenas ao criador da tarefa.

Processar o valor apostado da seguinte forma:

Devolver o valor ao criador se a tarefa for concluÃ­da antes do prazo.

Considerar o valor perdido se o prazo expirar sem conclusÃ£o.

Oferecer uma maneira de os usuÃ¡rios consultarem todas as tarefas que eles prÃ³prios criaram.

Possibilitar a verificaÃ§Ã£o se uma tarefa estÃ¡ atrasada com base no prazo e no tempo atual.

Disponibilizar informaÃ§Ãµes gerais, como:

O nÃºmero total de tarefas criadas no contrato.

O saldo total de ether atualmente armazenado no contrato.

NotificaÃ§Ãµes

Gerar notificaÃ§Ãµes pÃºblicas (eventos) nos seguintes casos:

Quando uma nova tarefa Ã© criada.

Quando uma tarefa Ã© concluÃ­da.

Quando o valor apostado Ã© perdido devido ao atraso.

SeguranÃ§a

Garantir que as transferÃªncias de ether sejam feitas de forma segura, verificando se foram concluÃ­das com sucesso.

EspecificaÃ§Ãµes TÃ©cnicas

Utilizar a versÃ£o 0.8.13 do Solidity.

Incluir a licenÃ§a MIT no inÃ­cio do cÃ³digo.

Usar estruturas de mapeamento para organizar as tarefas e associÃ¡-las aos respectivos criadores.

Fornecer uma forma de consultar os detalhes completos de uma tarefa especÃ­fica.

Incluir uma maneira de determinar se uma tarefa estÃ¡ atrasada em relaÃ§Ã£o ao prazo.

Permitir consulta ao nÃºmero total de tarefas criadas e ao saldo atual do contrato.
```

**ğŸ’¡ Dica**: Este prompt pode servir como **base** para criar outros contratos similares ou para **estudar** como traduzir requisitos em cÃ³digo Solidity!

---

### ğŸ“Œ **AtualizaÃ§Ã£o: Deploy Corrigido**

**âœ… Deploy Funcional**: O comando de deploy foi corrigido e testado com sucesso!
- **Contrato**: TaskManager deployado em: `0xb17d39826a1b83f7685de1ebc924b3185b677383`
- **Rede**: Sepolia Testnet
- **Hash**: `0x317b05ffccb85fad4a670cdee712c2f908322101767e78b4ad809e4b0fe8d10e`
- **Verificado**: âœ… CÃ³digo verificado no Etherscan

**ğŸ”— Ver contrato**: [https://sepolia.etherscan.io/address/0xb17d39826a1b83f7685de1ebc924b3185b677383](https://sepolia.etherscan.io/address/0xb17d39826a1b83f7685de1ebc924b3185b677383)

#### ğŸ”‘ **LEMBRE-SE: Sempre Carregar VariÃ¡veis de Ambiente!**

**âš ï¸ ERRO MAIS COMUM**: Esquecer de executar `source .env` antes do deploy.

**âœ… PROCESSO CORRETO:**
1. `cd smartcontract` (entrar na pasta do smart contract)
2. `source .env` (carregar variÃ¡veis)
3. Executar comando de deploy
4. âœ¨ Deploy funciona perfeitamente!

**ğŸ’¡ Dica**: Sempre que abrir um novo terminal, execute `source .env` novamente, pois as variÃ¡veis sÃ³ ficam carregadas na sessÃ£o atual do terminal.

---

## ğŸ¯ Aula 3 - IntegraÃ§Ã£o Frontend com Smart Contract

### ğŸŒ‰ **Construindo a Ponte entre Seu Site e a Blockchain**

**Analogia**: Imagine que vocÃª tem um **restaurante fÃ­sico** (smart contract) e quer criar um **aplicativo de delivery** (frontend). VocÃª precisa de uma **"ponte"** para conectar os dois mundos!

**ğŸ”— O que vamos fazer nesta aula:**
- Conectar nosso site Next.js com o smart contract deployado
- Usar **wagmi** e **viem** para fazer essa conexÃ£o
- Criar funÃ§Ãµes simples para interagir com a blockchain
- Fazer tudo funcionar **sem complicaÃ§Ã£o**

#### ğŸ§© **As PeÃ§as do Quebra-CabeÃ§a**

Antes de comeÃ§ar, vamos entender **o que cada ferramenta faz**:

```
ğŸ  Seu Site (Next.js)     ğŸŒ‰ Ponte (wagmi + viem)     ğŸª Smart Contract (Blockchain)
     â”‚                           â”‚                           â”‚
     â”‚ "Quero criar tarefa"       â”‚                           â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Traduz para blockchain   â”‚
     â”‚                           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Executa createTask()
     â”‚                           â”‚                           â”‚
     â”‚ "Mostrar minhas tarefas"   â”‚                           â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Consulta dados           â”‚
     â”‚                           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Retorna lista [1,2,3]
     â”‚                           â”‚                           â”‚
     â”‚ Exibe na interface âœ¨      â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                           â”‚
```

### ğŸ“š **Entendendo Wagmi e Viem - Os "Tradutores MÃ¡gicos"**

#### ğŸ£ **Wagmi - O "Pescador de Dados da Blockchain"**

**Analogia**: **Wagmi** Ã© como um **"assistente pessoal"** que fica buscando informaÃ§Ãµes na blockchain e traz prontas para seu site.

**ğŸ¤” O que wagmi faz na prÃ¡tica:**

```typescript
// âœ¨ MÃGICA DO WAGMI
const { address, isConnected } = useAccount()  // Pega dados da carteira
const { data: balance } = useBalance()         // Pesca o saldo
const { data: tasks } = useReadContract()      // LÃª dados do contrato
```

**Analogia detalhada:**
- **`useAccount()`**: Como um **"recepcionista"** que sabe quem estÃ¡ logado
  - "Ah, o senhor JoÃ£o (endereÃ§o 0x123...) estÃ¡ aqui!"
  
- **`useBalance()`**: Como um **"caixa eletrÃ´nico"** que mostra seu saldo
  - "Senhor JoÃ£o, vocÃª tem R$ 150,00 na conta"
  
- **`useReadContract()`**: Como um **"consultor"** que vai no banco de dados buscar informaÃ§Ã£o
  - "Senhor JoÃ£o, vocÃª tem 3 tarefas cadastradas: [1, 2, 3]"

#### ğŸ”„ **Como Wagmi Funciona Automaticamente**

```typescript
// ğŸ¤– WAGMI TRABALHANDO 24/7
function MeuComponente() {
  const { data: minhasTarefas } = useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'getMyTasks'
  })
  
  // âœ¨ WAGMI AUTOMÃTICO:
  // - Verifica dados a cada 4 segundos
  // - Se mudou algo na blockchain, atualiza automÃ¡tico
  // - Mostra "loading" enquanto busca
  // - Guarda cache para nÃ£o buscar toda hora
  
  return <div>VocÃª tem {minhasTarefas?.length} tarefas</div>
}
```

**ğŸ§  Por que isso Ã© incrÃ­vel:**
- **AtualizaÃ§Ã£o automÃ¡tica**: Se criar nova tarefa, a lista atualiza sozinha
- **Cache inteligente**: NÃ£o fica fazendo a mesma consulta mil vezes
- **Loading states**: Mostra "carregando..." automÃ¡tico
- **Zero configuraÃ§Ã£o**: Funciona sem vocÃª programar nada complexo

#### âš¡ **Viem - O "Tradutor da Linguagem Blockchain"**

**Analogia**: **Viem** Ã© como um **"tradutor simultÃ¢neo"** que converte suas instruÃ§Ãµes em JavaScript para a "linguagem" da blockchain.

**ğŸ—£ï¸ TraduÃ§Ã£o em tempo real:**

```typescript
// ğŸ—£ï¸ VOCÃŠ FALA (JavaScript):
await writeContract({
  address: CONTRACT_ADDRESS,
  abi: CONTRACT_ABI,
  functionName: 'createTask',
  args: ['Estudar React', 'Terminar curso', deadline],
  value: parseEther('0.001')  // 0.001 ETH
})

// ğŸ¤– VIEM TRADUZ PARA BLOCKCHAIN:
// "Chamar funÃ§Ã£o createTask no contrato 0x123... 
//  com parÃ¢metros ('Estudar React', 'Terminar curso', 1703980800)
//  enviando 1000000000000000 wei (0.001 ETH)"
```

**ğŸ¯ O que viem faz especificamente:**

**1. ğŸ”¢ ConversÃ£o de NÃºmeros:**
```typescript
// VocÃª escreve (fÃ¡cil):
parseEther('0.001')  // 0.001 ETH

// Viem converte para (formato blockchain):
'1000000000000000'   // 1000000000000000 wei
```

**2. ğŸ“ PreparaÃ§Ã£o de Dados:**
```typescript
// VocÃª escreve:
args: ['Estudar React', 'Terminar curso', deadline]

// Viem empacota para blockchain:
encodeFunctionData({...}) // Dados em formato hexadecimal
```

**3. ğŸ” Assinatura de TransaÃ§Ãµes:**
```typescript
// VocÃª clica "Enviar"
// Viem + MetaMask fazem toda a criptografia e assinatura digital
```

#### ğŸ¤ **Como Wagmi e Viem Trabalham Juntos**

**Analogia**: Como um **"app de delivery"** completo:

```
ğŸ“± SEU APP          ğŸšš WAGMI           âš¡ VIEM            ğŸª BLOCKCHAIN
     â”‚                  â”‚                  â”‚                    â”‚
ğŸ“ "Criar tarefa"      â”‚                  â”‚                    â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                  â”‚                    â”‚
     â”‚                  â”‚ Prepara dados    â”‚                    â”‚
     â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                    â”‚
     â”‚                  â”‚                  â”‚ Assina transaÃ§Ã£o   â”‚
     â”‚                  â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
     â”‚                  â”‚                  â”‚                    â”‚ Executa
     â”‚                  â”‚ Monitora status  â”‚                    â”‚ createTask()
     â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                    â”‚
ğŸ“Š Atualiza interface  â”‚                  â”‚                    â”‚
     â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                  â”‚                    â”‚
     â”‚                  â”‚                  â”‚                    â”‚
```

**DivisÃ£o de responsabilidades:**
- **ğŸ“± Seu App**: Interface bonita e experiÃªncia do usuÃ¡rio
- **ğŸšš Wagmi**: Gerencia estado, cache, atualizaÃ§Ãµes automÃ¡ticas
- **âš¡ Viem**: ComunicaÃ§Ã£o direta e traduÃ§Ã£o para blockchain
- **ğŸª Blockchain**: Executa o cÃ³digo e guarda os dados

### ğŸ› ï¸ **Passo 1: InstalaÃ§Ã£o das DependÃªncias**

#### ğŸ“¦ **1.1 DependÃªncias Web3**

```bash
# ğŸ“¦ Bibliotecas principais para Web3
pnpm add wagmi viem

# ğŸ”„ Gerenciamento de estado (cache inteligente)
pnpm add @tanstack/react-query

# ğŸ”Œ Conectores para carteiras
pnpm add @wagmi/connectors
```

#### ğŸ¨ **1.2 Componentes UI com shadcn**

**Analogia**: Como usar uma **"loja de componentes prontos"** ao invÃ©s de fazer tudo do zero!

```bash
# ğŸ¯ Inicializar shadcn (se ainda nÃ£o foi feito)
npx shadcn@latest init

# ğŸ“‹ Instalar componentes necessÃ¡rios
npx shadcn@latest add dialog
npx shadcn@latest add label  
npx shadcn@latest add button
npx shadcn@latest add input
npx shadcn@latest add textarea
npx shadcn@latest add card
npx shadcn@latest add badge
npx shadcn@latest add tooltip
npx shadcn@latest add alert
```

**ğŸ¤” Por que usar shadcn:**
- âœ… **Componentes prontos**: NÃ£o precisa criar Dialog, Label, etc. manualmente
- âœ… **Tipos TypeScript**: JÃ¡ vem com tipagem perfeita
- âœ… **CustomizÃ¡vel**: VocÃª pode modificar o cÃ³digo depois
- âœ… **AcessÃ­vel**: Segue padrÃµes de acessibilidade
- âœ… **Consistente**: Visual uniforme em todo o app

**ğŸ¤” Por que cada biblioteca Web3:**

- **`wagmi`**: O "assistente pessoal" que busca dados da blockchain
- **`viem`**: O "tradutor" que converte JavaScript â†” Blockchain  
- **`@tanstack/react-query`**: A "memÃ³ria inteligente" que guarda dados
- **`@wagmi/connectors`**: Os "adaptadores" para diferentes carteiras

### ğŸ—ï¸ **Passo 2: ConfiguraÃ§Ã£o da ConexÃ£o Web3**

Vamos criar o arquivo que **configura toda a conexÃ£o** com a blockchain:

#### ğŸ“ **Criar `lib/web3.ts`**

```typescript
// lib/web3.ts - Nossa "Central de ConexÃµes"

// ğŸ“¦ Importa as ferramentas necessÃ¡rias
import { createConfig, http } from 'wagmi'
import { sepolia } from 'wagmi/chains'
import { metaMask, walletConnect } from 'wagmi/connectors'

// ğŸ”‘ ConfiguraÃ§Ãµes (substitua pelos seus valores)
const projectId = 'SEU_WALLETCONNECT_PROJECT_ID' // De https://cloud.walletconnect.com
const alchemyApiKey = 'SUA_ALCHEMY_API_KEY'      // De https://alchemy.com

// âš™ï¸ ConfiguraÃ§Ã£o principal - nossa "receita de conexÃ£o"
export const config = createConfig({
  // ğŸŒ Em qual blockchain vamos trabalhar
  chains: [sepolia],
  
  // ğŸ”Œ Quais carteiras podem conectar
  connectors: [
    metaMask(),                     // MetaMask (mais popular)
    walletConnect({ projectId }),   // WalletConnect (carteiras mobile)
  ],
  
  // ğŸŒ Como conectar na internet da blockchain
  transports: {
    [sepolia.id]: http(`https://eth-sepolia.g.alchemy.com/v2/${alchemyApiKey}`)
  },
})

// ğŸ“ EndereÃ§o do nosso smart contract (copie do deploy)
export const CONTRACT_ADDRESS = '0xSEU_ENDERECO_DO_CONTRATO_AQUI'

// ğŸ“‹ ABI - "Manual de instruÃ§Ãµes" do contrato
export const CONTRACT_ABI = [
  // ğŸ“ FunÃ§Ã£o: createTask (criar nova tarefa)
  {
    "inputs": [
      { "internalType": "string", "name": "_title", "type": "string" },
      { "internalType": "string", "name": "_description", "type": "string" },
      { "internalType": "uint256", "name": "_deadline", "type": "uint256" }
    ],
    "name": "createTask",
    "outputs": [],
    "stateMutability": "payable",  // â† Aceita ETH junto
    "type": "function"
  },
  
  // âœ… FunÃ§Ã£o: completeTask (marcar como concluÃ­da)
  {
    "inputs": [
      { "internalType": "uint256", "name": "_taskId", "type": "uint256" }
    ],
    "name": "completeTask",
    "outputs": [],
    "stateMutability": "nonpayable", // â† SÃ³ executa, nÃ£o recebe ETH
    "type": "function"
  },
  
  // ğŸ‘€ FunÃ§Ã£o: getMyTasks (buscar minhas tarefas)
  {
    "inputs": [],
    "name": "getMyTasks",
    "outputs": [
      { "internalType": "uint256[]", "name": "", "type": "uint256[]" }
    ],
    "stateMutability": "view",  // â† SÃ³ lÃª, nÃ£o modifica nada
    "type": "function"
  },
  
  // ğŸ” FunÃ§Ã£o: tasks (buscar uma tarefa especÃ­fica)
  {
    "inputs": [
      { "internalType": "uint256", "name": "", "type": "uint256" }
    ],
    "name": "tasks",
    "outputs": [
      { "internalType": "uint256", "name": "id", "type": "uint256" },
      { "internalType": "string", "name": "title", "type": "string" },
      { "internalType": "string", "name": "description", "type": "string" },
      { "internalType": "uint256", "name": "createdAt", "type": "uint256" },
      { "internalType": "uint256", "name": "deadline", "type": "uint256" },
      { "internalType": "bool", "name": "isCompleted", "type": "bool" },
      { "internalType": "address", "name": "creator", "type": "address" },
      { "internalType": "uint256", "name": "stake", "type": "uint256" },
      { "internalType": "bool", "name": "stakeProcessed", "type": "bool" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  
  // ğŸ”¢ FunÃ§Ã£o: totalTasks (total de tarefas criadas)
  {
    "inputs": [],
    "name": "totalTasks",
    "outputs": [
      { "internalType": "uint256", "name": "", "type": "uint256" }
    ],
    "stateMutability": "view",
    "type": "function"
  }
] as const
```

**ğŸ¤” O que cada parte faz:**

- **`config`**: A "receita" de como conectar na blockchain
- **`CONTRACT_ADDRESS`**: O "endereÃ§o" onde nosso contrato mora
- **`CONTRACT_ABI`**: O "manual" com todas as funÃ§Ãµes disponÃ­veis

### ğŸ¯ **Passo 3: Configurar Provedores no App**

Como seu `layout.tsx` jÃ¡ estÃ¡ configurado, precisamos apenas criar o **Provider Web3** isolado:

#### ğŸ“ **Criar `providers/Web3Provider.tsx`**

```typescript
// providers/Web3Provider.tsx - Provider Web3 isolado

'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from '@/lib/web3'
import { useState, ReactNode } from 'react'

interface Web3ProviderProps {
  children: ReactNode
}

export function Web3Provider({ children }: Web3ProviderProps) {
  // ğŸ§  Cria a "memÃ³ria inteligente" (cache)
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        // âš¡ ConfiguraÃ§Ãµes otimizadas para Web3
        refetchOnWindowFocus: false,
        retry: 1,
        staleTime: 1000 * 60 * 5, // 5 minutos
      },
    },
  }))

  return (
    {/* ğŸ”§ WAGMI: Fornece conexÃ£o Web3 para todo o app */}
    <WagmiProvider config={config}>
      {/* ğŸ—„ï¸ QUERY: Gerencia cache e atualizaÃ§Ãµes automÃ¡ticas */}
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    </WagmiProvider>
  )
}
```

#### ğŸ“ **Manter `app/layout.tsx` sem "use client"**

Seu layout atual jÃ¡ estÃ¡ correto! Ele usa o `Web3Provider` que criamos acima:

```typescript
// app/layout.tsx - MantÃ©m como estÃ¡ (sem 'use client')

import { Web3Provider } from '@/providers/Web3Provider'
import { Toaster } from '@/components/ui/toaster'
import type { Metadata } from 'next'
import './globals.css'

export const metadata: Metadata = {
  title: 'TaskManager DApp',
  description: 'Gerencie suas tarefas na blockchain Ethereum (Sepolia)',
  // ... resto das configuraÃ§Ãµes
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="pt-BR">
      <body className="min-h-screen bg-background font-sans antialiased">
        <Web3Provider>
          <main className="relative flex min-h-screen flex-col">
            {children}
          </main>
          <Toaster />
        </Web3Provider>
      </body>
    </html>
  )
}
```

**ğŸ¯ Vantagens desta estrutura:**
- âœ… **Layout Server Component**: Pode usar metadata, otimizaÃ§Ãµes SSR
- âœ… **Provider isolado**: Web3 sÃ³ carrega onde necessÃ¡rio
- âœ… **ConfiguraÃ§Ã£o otimizada**: Cache configurado para blockchain
- âœ… **Tipos seguros**: TypeScript funcionando perfeitamente

**Analogia**: Ã‰ como **"ter a fiaÃ§Ã£o elÃ©trica principal"** (layout) e um **"quadro de forÃ§a especializado"** (Web3Provider) para aparelhos que precisam de energia especial!

### ğŸ£ **Passo 4: Criar Hooks Customizados**

Vamos criar **"assistentes especializados"** para cada tarefa do nosso app:

#### ğŸ“ **Criar `hooks/useTaskManager.ts`**

```typescript
// hooks/useTaskManager.ts - Nossos "assistentes especialistas"

import { useReadContract, useWriteContract, useAccount } from 'wagmi'
import { CONTRACT_ADDRESS, CONTRACT_ABI } from '@/lib/web3'
import { parseEther } from 'viem'

// ğŸ£ Hook: Buscar minhas tarefas
export function useMyTasks() {
  const { address } = useAccount()
  
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'getMyTasks',
    account: address,
    // âœ¨ WAGMI AUTOMÃTICO:
    // - Atualiza a cada 4 segundos
    // - Para de buscar se usuÃ¡rio nÃ£o conectado
    // - Guarda resultado em cache
  })
}

// ğŸ” Hook: Buscar dados de uma tarefa especÃ­fica
export function useTask(taskId: number | undefined) {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'tasks',
    args: taskId ? [BigInt(taskId)] : undefined,
    enabled: !!taskId, // SÃ³ busca se taskId existir
  })
}

// ğŸ“Š Hook: Buscar total de tarefas no sistema
export function useTotalTasks() {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'totalTasks',
  })
}

// âœï¸ Hook: Criar nova tarefa
export function useCreateTask() {
  const { writeContract, isPending, error } = useWriteContract()
  
  const createTask = async (
    title: string, 
    description: string, 
    deadline: Date,
    stakeAmount: string = '0.001' // ETH
  ) => {
    try {
      // ğŸ—“ï¸ Converte data para timestamp
      const deadlineTimestamp = Math.floor(deadline.getTime() / 1000)
      
      // ğŸ“ Chama funÃ§Ã£o do contrato
      await writeContract({
        address: CONTRACT_ADDRESS,
        abi: CONTRACT_ABI,
        functionName: 'createTask',
        args: [title, description, BigInt(deadlineTimestamp)],
        value: parseEther(stakeAmount), // Converte ETH para Wei
      })
      
      console.log('âœ… Tarefa criada com sucesso!')
      
    } catch (err) {
      console.error('âŒ Erro ao criar tarefa:', err)
      throw err
    }
  }
  
  return {
    createTask,
    isPending, // true = transaÃ§Ã£o sendo processada
    error      // detalhes do erro, se houver
  }
}

// âœ… Hook: Completar tarefa
export function useCompleteTask() {
  const { writeContract, isPending, error } = useWriteContract()
  
  const completeTask = async (taskId: number) => {
    try {
      await writeContract({
        address: CONTRACT_ADDRESS,
        abi: CONTRACT_ABI,
        functionName: 'completeTask',
        args: [BigInt(taskId)],
      })
      
      console.log('âœ… Tarefa completada!')
      
    } catch (err) {
      console.error('âŒ Erro ao completar tarefa:', err)
      throw err
    }
  }
  
  return {
    completeTask,
    isPending,
    error
  }
}

// ğŸ”— Hook: Status da conexÃ£o
export function useWeb3Status() {
  const { address, isConnected } = useAccount()
  
  return {
    address,
    isConnected,
    // EndereÃ§o formatado para exibiÃ§Ã£o
    shortAddress: address ? `${address.slice(0, 6)}...${address.slice(-4)}` : null
  }
}
```

**Analogia**: Cada hook Ã© como um **"funcionÃ¡rio especializado"**:

- **`useMyTasks`**: "SecretÃ¡rio" que sempre sabe suas tarefas
- **`useTask`**: "Arquivista" que busca dados de tarefa especÃ­fica  
- **`useCreateTask`**: "Assistente de criaÃ§Ã£o" que registra novas tarefas
- **`useCompleteTask`**: "Supervisor" que marca tarefas como concluÃ­das
- **`useWeb3Status`**: "Recepcionista" que sabe quem estÃ¡ logado

### ğŸ¨ **Passo 5: Adaptar o Frontend Existente para Web3**

Como vocÃª jÃ¡ tem uma interface bonita funcionando, vamos **integrar Web3 gradualmente** mantendo seu design atual:

#### ğŸ“ **Atualizar `app/page.tsx` - IntegraÃ§Ã£o Completa**

```typescript
// app/page.tsx - PÃ¡gina principal com integraÃ§Ã£o Web3

"use client"

import type React from "react"
import { useState, useMemo, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { AlertCircle, CheckCircle2, ListTodo, Loader, Coins, PlusCircle, CheckSquare, Wallet } from "lucide-react"

// ğŸ”§ Imports Web3
import { useConnect, useDisconnect, useAccount, useBalance } from 'wagmi'
import { useMyTasks, useTask, useCompleteTask, useCreateTask, useWeb3Status } from '@/hooks/useTaskManager'
import { CreateTaskModal } from '@/components/CreateTaskModal'

// Tipagem adaptada para Web3
type Task = {
  id: number
  name: string
  description: string
  status: "Pendente" | "ConcluÃ­do"
  creationDate: string
  completionDate: string | null
  wei: number
  deadline?: string
  isOverdue?: boolean
}

export default function Web3TodoPage() {
  const [showCreateModal, setShowCreateModal] = useState(false)
  
  // ğŸ”— Hooks Web3
  const { connectors, connect } = useConnect()
  const { disconnect } = useDisconnect()
  const { isConnected, shortAddress, address } = useWeb3Status()
  const { data: taskIds, isLoading: loadingTasks } = useMyTasks()
  const { data: balance } = useBalance({ address })

  // ğŸ¯ Converter dados da blockchain para formato do componente
  const tasks = useMemo(() => {
    if (!taskIds || !isConnected) return []
    
    // Em uma implementaÃ§Ã£o real, vocÃª buscaria cada tarefa individualmente
    // Por simplicidade, vamos simular algumas tarefas quando conectado
    return [
      {
        id: 1,
        name: "Estudar Solidity",
        description: "Completar curso de desenvolvimento de smart contracts",
        status: "Pendente" as const,
        creationDate: "2025-01-15",
        completionDate: null,
        wei: 1000000000000000, // 0.001 ETH em wei
        deadline: "2025-01-25",
        isOverdue: false
      },
      {
        id: 2,
        name: "Deploy na Sepolia",
        description: "Fazer deploy do contrato na rede de teste",
        status: "ConcluÃ­do" as const,
        creationDate: "2025-01-10",
        completionDate: "2025-01-12",
        wei: 2000000000000000, // 0.002 ETH em wei
      }
    ]
  }, [taskIds, isConnected])

  const handleConnectWallet = () => {
    if (isConnected) {
      disconnect()
    } else {
      // Conecta com o primeiro conector disponÃ­vel (MetaMask)
      const metamask = connectors.find(c => c.name === 'MetaMask')
      if (metamask) {
        connect({ connector: metamask })
      }
    }
  }

  const metrics = useMemo(() => {
    const total = tasks.length
    const concluidas = tasks.filter((t) => t.status === "ConcluÃ­do").length
    const pendentes = total - concluidas
    const weiInStake = tasks.filter((t) => t.status === "Pendente").reduce((sum, task) => sum + task.wei, 0)
    return { total, concluidas, pendentes, weiInStake }
  }, [tasks])

  return (
    <TooltipProvider>
      <div className="min-h-screen bg-gray-50 text-gray-900">
        <main className="container mx-auto p-4 sm:p-6 lg:p-8">
          {/* CabeÃ§alho */}
          <header className="mb-8">
            <div className="flex flex-col sm:flex-row justify-between items-center gap-4">
              <h1 className="text-3xl font-bold text-gray-800">WEB3 TODO</h1>
              <div className="flex items-center gap-2">
                {isConnected && (
                  <div className="flex flex-col items-end text-sm">
                    <span className="text-green-600 font-medium">{shortAddress}</span>
                    <span className="text-gray-500">
                      {balance ? `${Number(balance.formatted).toFixed(4)} ETH` : '0 ETH'}
                    </span>
                  </div>
                )}
                <Button
                  onClick={handleConnectWallet}
                  className={`transition-all duration-300 ${
                    isConnected ? "bg-green-600 hover:bg-green-700" : "bg-violet-600 hover:bg-violet-700"
                  }`}
                >
                  <Wallet className="mr-2 h-4 w-4" />
                  {isConnected ? "Carteira Conectada" : "Conectar Carteira"}
                </Button>
              </div>
            </div>
            {!isConnected && (
              <Alert
                variant="destructive"
                className="mt-4 border-yellow-500/50 text-yellow-700 [&>svg]:text-yellow-700"
              >
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>AtenÃ§Ã£o</AlertTitle>
                <AlertDescription>Conecte sua carteira para gerenciar suas tarefas na blockchain.</AlertDescription>
              </Alert>
            )}
          </header>

          {/* SeÃ§Ã£o de MÃ©tricas */}
          <section className="mb-10">
            <div className="grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-4">
              <MetricCard
                title="Total de Tarefas"
                value={metrics.total}
                icon={<ListTodo className="h-6 w-6 text-violet-500" />}
              />
              <MetricCard
                title="Tarefas ConcluÃ­das"
                value={metrics.concluidas}
                icon={<CheckCircle2 className="h-6 w-6 text-cyan-500" />}
              />
              <MetricCard
                title="Tarefas Pendentes"
                value={metrics.pendentes}
                icon={<Loader className="h-6 w-6 text-yellow-500" />}
              />
              <MetricCard
                title="ETH em Stake"
                value={`${(metrics.weiInStake / 1e18).toFixed(3)} ETH`}
                icon={<Coins className="h-6 w-6 text-indigo-500" />}
              />
            </div>
          </section>

          {/* SeÃ§Ã£o de Tarefas */}
          <section>
            <div className="flex justify-between items-center mb-6">
              <h2 className="text-2xl font-semibold text-gray-800">Tarefas</h2>
              <Tooltip>
                <TooltipTrigger asChild>
                  <div className="inline-block">
                    <Button 
                      disabled={!isConnected} 
                      className="bg-violet-600 hover:bg-violet-700 disabled:opacity-50"
                      onClick={() => setShowCreateModal(true)}
                    >
                      <PlusCircle className="mr-2 h-4 w-4" />
                      Nova Tarefa
                    </Button>
                  </div>
                </TooltipTrigger>
                {!isConnected && (
                  <TooltipContent>
                    <p>Conecte sua carteira para criar tarefas.</p>
                  </TooltipContent>
                )}
              </Tooltip>
            </div>
            
            <div className="space-y-4">
              {loadingTasks && isConnected ? (
                <div className="text-center p-8">
                  <Loader className="animate-spin h-8 w-8 mx-auto mb-4" />
                  <p>Carregando tarefas da blockchain...</p>
                </div>
              ) : tasks.length === 0 && isConnected ? (
                <div className="text-center p-8">
                  <p className="text-gray-500">VocÃª ainda nÃ£o tem tarefas. Crie sua primeira!</p>
                </div>
              ) : (
                tasks.map((task) => (
                  <Web3TaskCard 
                    key={task.id} 
                    task={task} 
                    isConnected={isConnected} 
                  />
                ))
              )}
              
              {!isConnected && (
                <div className="text-center p-8">
                  <AlertCircle className="h-12 w-12 mx-auto mb-4 text-gray-400" />
                  <p className="text-gray-500">Conecte sua carteira para ver suas tarefas</p>
                </div>
              )}
            </div>
          </section>
        </main>
      </div>
      
      {/* Modal de Criar Tarefa */}
      <CreateTaskModal 
        open={showCreateModal} 
        onClose={() => setShowCreateModal(false)} 
      />
    </TooltipProvider>
  )
}

// Componente para os cards de mÃ©trica (mantido igual)
function MetricCard({ title, value, icon }: { title: string; value: string | number; icon: React.ReactNode }) {
  return (
    <Card className="transition-shadow duration-300 hover:shadow-lg">
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium text-gray-500">{title}</CardTitle>
        {icon}
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
      </CardContent>
    </Card>
  )
}

// Componente para os cards de tarefa Web3
function Web3TaskCard({
  task,
  isConnected,
}: { 
  task: Task
  isConnected: boolean 
}) {
  const { completeTask, isPending } = useCompleteTask()
  const isCompleted = task.status === "ConcluÃ­do"
  
  const handleComplete = async () => {
    if (!isConnected) return
    
    try {
      await completeTask(task.id)
      // A UI serÃ¡ atualizada automaticamente pelo wagmi
    } catch (error) {
      console.error('Erro ao completar tarefa:', error)
    }
  }
  
  return (
    <Card className={`transition-all duration-300 ${
      isCompleted ? "bg-gray-100/80 border-gray-200" : 
      task.isOverdue ? "bg-red-50/80 border-red-200" : "bg-white"
    }`}>
      <CardContent className="p-4 sm:p-6">
        <div className="flex flex-col sm:flex-row justify-between items-start gap-4">
          <div className="flex-1">
            <div className="flex items-center gap-3 mb-2">
              <h3 className={`text-lg font-semibold ${isCompleted ? "text-gray-500 line-through" : "text-gray-900"}`}>
                {task.name}
              </h3>
              <Badge
                variant={isCompleted ? "default" : task.isOverdue ? "destructive" : "secondary"}
                className={`text-xs font-medium ${
                  isCompleted
                    ? "bg-cyan-100 text-cyan-800 border-cyan-200"
                    : task.isOverdue 
                      ? "bg-red-100 text-red-800 border-red-200"
                      : "bg-yellow-100 text-yellow-800 border-yellow-200"
                }`}
              >
                {isCompleted ? "ConcluÃ­do" : task.isOverdue ? "Atrasada" : "Pendente"}
              </Badge>
            </div>
            <p className={`text-sm text-gray-600 ${isCompleted ? "text-gray-500" : ""}`}>
              {task.description}
            </p>
            <div className="mt-3 flex flex-wrap gap-x-4 gap-y-1 text-xs text-gray-500">
              <span>Criado em: {new Date(task.creationDate).toLocaleDateString("pt-BR")}</span>
              {task.completionDate && (
                <span>ConcluÃ­do em: {new Date(task.completionDate).toLocaleDateString("pt-BR")}</span>
              )}
              {task.deadline && (
                <span>Prazo: {new Date(task.deadline).toLocaleDateString("pt-BR")}</span>
              )}
              <span className="flex items-center gap-1">
                <Coins className="h-3 w-3" /> 
                {(task.wei / 1e18).toFixed(3)} ETH
              </span>
            </div>
          </div>
          {!isCompleted && (
            <Tooltip>
              <TooltipTrigger asChild>
                <div className="inline-block">
                  <Button
                    variant="outline"
                    size="icon"
                    onClick={handleComplete}
                    disabled={!isConnected || isPending}
                    aria-label="Concluir Tarefa"
                    className="border-violet-300 text-violet-600 hover:bg-violet-50 hover:text-violet-700 disabled:opacity-50"
                  >
                    {isPending ? (
                      <Loader className="h-5 w-5 animate-spin" />
                    ) : (
                      <CheckSquare className="h-5 w-5" />
                    )}
                  </Button>
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>
                  {!isConnected 
                    ? "Conecte a carteira para concluir" 
                    : isPending 
                      ? "Processando transaÃ§Ã£o..."
                      : "Concluir Tarefa"
                  }
                </p>
              </TooltipContent>
            </Tooltip>
          )}
        </div>
      </CardContent>
    </Card>
  )
}
```

#### ğŸ“ **Criar `components/CreateTaskModal.tsx`**

```typescript
// components/CreateTaskModal.tsx - Modal para criar tarefas

'use client'

import { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Label } from '@/components/ui/label'
import { Loader } from 'lucide-react'
import { useCreateTask } from '@/hooks/useTaskManager'

interface CreateTaskModalProps {
  open: boolean
  onClose: () => void
}

export function CreateTaskModal({ open, onClose }: CreateTaskModalProps) {
  const [title, setTitle] = useState('')
  const [description, setDescription] = useState('')
  const [deadline, setDeadline] = useState('')
  const [stakeAmount, setStakeAmount] = useState('0.001')
  
  const { createTask, isPending } = useCreateTask()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    try {
      const deadlineDate = new Date(deadline)
      await createTask(title, description, deadlineDate, stakeAmount)
      
      // Limpa formulÃ¡rio e fecha modal
      setTitle('')
      setDescription('')
      setDeadline('')
      setStakeAmount('0.001')
      onClose()
      
    } catch (error) {
      console.error('Erro ao criar tarefa:', error)
    }
  }

  // Gera data mÃ­nima (hoje + 1 hora)
  const minDateTime = new Date(Date.now() + 60 * 60 * 1000).toISOString().slice(0, 16)

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>ğŸ¯ Nova Tarefa na Blockchain</DialogTitle>
        </DialogHeader>
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="title">TÃ­tulo da Tarefa</Label>
            <Input
              id="title"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder="Ex: Estudar Solidity"
              required
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="description">DescriÃ§Ã£o</Label>
            <Textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Descreva o que precisa ser feito..."
              rows={3}
              required
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="deadline">Prazo Final</Label>
            <Input
              id="deadline"
              type="datetime-local"
              value={deadline}
              onChange={(e) => setDeadline(e.target.value)}
              min={minDateTime}
              required
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="stake">Valor do Stake (ETH)</Label>
            <Input
              id="stake"
              type="number"
              step="0.001"
              min="0.001"
              value={stakeAmount}
              onChange={(e) => setStakeAmount(e.target.value)}
              placeholder="0.001"
              required
            />
            <p className="text-xs text-gray-500">
              ğŸ’¡ MÃ­nimo: 0.001 ETH â€¢ VocÃª recupera se completar no prazo!
            </p>
          </div>
          
          <div className="flex justify-end gap-3 pt-4">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancelar
            </Button>
            <Button type="submit" disabled={isPending} className="bg-violet-600 hover:bg-violet-700">
              {isPending ? (
                <>
                  <Loader className="mr-2 h-4 w-4 animate-spin" />
                  Criando...
                </>
              ) : (
                'Criar Tarefa'
              )}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}
```

### ğŸ¨ **Passo 6: Adaptar o Frontend Existente para Web3**

Como vocÃª jÃ¡ tem uma interface bonita funcionando, vamos **integrar Web3 gradualmente** mantendo seu design atual:

#### ğŸ“ **Atualizar `app/page.tsx` - IntegraÃ§Ã£o Completa**

```typescript
// app/page.tsx - PÃ¡gina principal com integraÃ§Ã£o Web3

"use client"

import type React from "react"
import { useState, useMemo } from "react"
import { Button } from "@/components/ui/button"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { AlertCircle, CheckCircle2, ListTodo, Loader, Coins, PlusCircle, CheckSquare, Wallet } from "lucide-react"

// ğŸ”§ Imports Web3
import { useConnect, useDisconnect, useAccount, useBalance } from 'wagmi'
import { useMyTasks, useCompleteTask, useWeb3Status } from '@/hooks/useTaskManager'
import { CreateTaskModal } from '@/components/CreateTaskModal'

// Tipagem adaptada para Web3
type Task = {
  id: number
  name: string
  description: string
  status: "Pendente" | "ConcluÃ­do"
  creationDate: string
  completionDate: string | null
  wei: number
  deadline?: string
  isOverdue?: boolean
}

export default function Web3TodoPage() {
  const [showCreateModal, setShowCreateModal] = useState(false)
  
  // ğŸ”— Hooks Web3
  const { connectors, connect } = useConnect()
  const { disconnect } = useDisconnect()
  const { isConnected, shortAddress, address } = useWeb3Status()
  const { data: taskIds, isLoading: loadingTasks } = useMyTasks()
  const { data: balance } = useBalance({ address })

  // ğŸ¯ Converter dados da blockchain para formato do componente
  const tasks = useMemo(() => {
    if (!taskIds || !isConnected) return []
    
    // ğŸ”„ IMPLEMENTAÃ‡ÃƒO REAL: Buscar cada tarefa individualmente
    // Por enquanto retorna array vazio, mas cada taskId seria buscado via useTask()
    return taskIds.map(id => {
      // Aqui vocÃª buscaria cada tarefa individualmente:
      // const { data: taskData } = useTask(Number(id))
      // return taskData ? formatTaskForUI(taskData) : null
      return null
    }).filter(Boolean)
  }, [taskIds, isConnected])

  const handleConnectWallet = () => {
    if (isConnected) {
      disconnect()
    } else {
      // Conecta com o primeiro conector disponÃ­vel (MetaMask)
      const metamask = connectors.find(c => c.name === 'MetaMask')
      if (metamask) {
        connect({ connector: metamask })
      }
    }
  }

  const metrics = useMemo(() => {
    const total = tasks.length
    const concluidas = tasks.filter((t) => t.status === "ConcluÃ­do").length
    const pendentes = total - concluidas
    const weiInStake = tasks.filter((t) => t.status === "Pendente").reduce((sum, task) => sum + task.wei, 0)
    return { total, concluidas, pendentes, weiInStake }
  }, [tasks])

  return (
    <TooltipProvider>
      <div className="min-h-screen bg-gray-50 text-gray-900">
        <main className="container mx-auto p-4 sm:p-6 lg:p-8">
          {/* CabeÃ§alho */}
          <header className="mb-8">
            <div className="flex flex-col sm:flex-row justify-between items-center gap-4">
              <h1 className="text-3xl font-bold text-gray-800">WEB3 TODO</h1>
              <div className="flex items-center gap-2">
                {isConnected && (
                  <div className="flex flex-col items-end text-sm">
                    <span className="text-green-600 font-medium">{shortAddress}</span>
                    <span className="text-gray-500">
                      {balance ? `${Number(balance.formatted).toFixed(4)} ETH` : '0 ETH'}
                    </span>
                  </div>
                )}
                <Button
                  onClick={handleConnectWallet}
                  className={`transition-all duration-300 ${
                    isConnected ? "bg-green-600 hover:bg-green-700" : "bg-violet-600 hover:bg-violet-700"
                  }`}
                >
                  <Wallet className="mr-2 h-4 w-4" />
                  {isConnected ? "Carteira Conectada" : "Conectar Carteira"}
                </Button>
              </div>
            </div>
            {!isConnected && (
              <Alert
                variant="destructive"
                className="mt-4 border-yellow-500/50 text-yellow-700 [&>svg]:text-yellow-700"
              >
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>AtenÃ§Ã£o</AlertTitle>
                <AlertDescription>Conecte sua carteira para gerenciar suas tarefas na blockchain.</AlertDescription>
              </Alert>
            )}
          </header>

          {/* SeÃ§Ã£o de MÃ©tricas */}
          <section className="mb-10">
            <div className="grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-4">
              <MetricCard
                title="Total de Tarefas"
                value={metrics.total}
                icon={<ListTodo className="h-6 w-6 text-violet-500" />}
              />
              <MetricCard
                title="Tarefas ConcluÃ­das"
                value={metrics.concluidas}
                icon={<CheckCircle2 className="h-6 w-6 text-cyan-500" />}
              />
              <MetricCard
                title="Tarefas Pendentes"
                value={metrics.pendentes}
                icon={<Loader className="h-6 w-6 text-yellow-500" />}
              />
              <MetricCard
                title="ETH em Stake"
                value={`${(metrics.weiInStake / 1e18).toFixed(3)} ETH`}
                icon={<Coins className="h-6 w-6 text-indigo-500" />}
              />
            </div>
          </section>

          {/* SeÃ§Ã£o de Tarefas */}
          <section>
            <div className="flex justify-between items-center mb-6">
              <h2 className="text-2xl font-semibold text-gray-800">Tarefas</h2>
              <Tooltip>
                <TooltipTrigger asChild>
                  <div className="inline-block">
                    <Button 
                      disabled={!isConnected} 
                      className="bg-violet-600 hover:bg-violet-700 disabled:opacity-50"
                      onClick={() => setShowCreateModal(true)}
                    >
                      <PlusCircle className="mr-2 h-4 w-4" />
                      Nova Tarefa
                    </Button>
                  </div>
                </TooltipTrigger>
                {!isConnected && (
                  <TooltipContent>
                    <p>Conecte sua carteira para criar tarefas.</p>
                  </TooltipContent>
                )}
              </Tooltip>
            </div>
            
            <div className="space-y-4">
              {loadingTasks && isConnected ? (
                <div className="text-center p-8">
                  <Loader className="animate-spin h-8 w-8 mx-auto mb-4" />
                  <p>Carregando tarefas da blockchain...</p>
                </div>
              ) : tasks.length === 0 && isConnected ? (
                <div className="text-center p-8">
                  <p className="text-gray-500">VocÃª ainda nÃ£o tem tarefas. Crie sua primeira!</p>
                </div>
              ) : (
                tasks.map((task) => (
                  <Web3TaskCard 
                    key={task.id} 
                    task={task} 
                    isConnected={isConnected} 
                  />
                ))
              )}
              
              {!isConnected && (
                <div className="text-center p-8">
                  <AlertCircle className="h-12 w-12 mx-auto mb-4 text-gray-400" />
                  <p className="text-gray-500">Conecte sua carteira para ver suas tarefas</p>
                </div>
              )}
            </div>
          </section>
        </main>
      </div>
      
      {/* Modal de Criar Tarefa */}
      <CreateTaskModal 
        open={showCreateModal} 
        onClose={() => setShowCreateModal(false)} 
      />
    </TooltipProvider>
  )
}

// Componente para os cards de mÃ©trica (mantido igual)
function MetricCard({ title, value, icon }: { title: string; value: string | number; icon: React.ReactNode }) {
  return (
    <Card className="transition-shadow duration-300 hover:shadow-lg">
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium text-gray-500">{title}</CardTitle>
        {icon}
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
      </CardContent>
    </Card>
  )
}

// Componente para os cards de tarefa Web3
function Web3TaskCard({
  task,
  isConnected,
}: { 
  task: Task
  isConnected: boolean 
}) {
  const { completeTask, isPending } = useCompleteTask()
  const isCompleted = task.status === "ConcluÃ­do"
  
  const handleComplete = async () => {
    if (!isConnected) return
    
    try {
      await completeTask(task.id)
      // A UI serÃ¡ atualizada automaticamente pelo wagmi
    } catch (error) {
      console.error('Erro ao completar tarefa:', error)
    }
  }
  
  return (
    <Card className={`transition-all duration-300 ${
      isCompleted ? "bg-gray-100/80 border-gray-200" : 
      task.isOverdue ? "bg-red-50/80 border-red-200" : "bg-white"
    }`}>
      <CardContent className="p-4 sm:p-6">
        <div className="flex flex-col sm:flex-row justify-between items-start gap-4">
          <div className="flex-1">
            <div className="flex items-center gap-3 mb-2">
              <h3 className={`text-lg font-semibold ${isCompleted ? "text-gray-500 line-through" : "text-gray-900"}`}>
                {task.name}
              </h3>
              <Badge
                variant={isCompleted ? "default" : task.isOverdue ? "destructive" : "secondary"}
                className={`text-xs font-medium ${
                  isCompleted
                    ? "bg-cyan-100 text-cyan-800 border-cyan-200"
                    : task.isOverdue 
                      ? "bg-red-100 text-red-800 border-red-200"
                      : "bg-yellow-100 text-yellow-800 border-yellow-200"
                }`}
              >
                {isCompleted ? "ConcluÃ­do" : task.isOverdue ? "Atrasada" : "Pendente"}
              </Badge>
            </div>
            <p className={`text-sm text-gray-600 ${isCompleted ? "text-gray-500" : ""}`}>
              {task.description}
            </p>
            <div className="mt-3 flex flex-wrap gap-x-4 gap-y-1 text-xs text-gray-500">
              <span>Criado em: {new Date(task.creationDate).toLocaleDateString("pt-BR")}</span>
              {task.completionDate && (
                <span>ConcluÃ­do em: {new Date(task.completionDate).toLocaleDateString("pt-BR")}</span>
              )}
              {task.deadline && (
                <span>Prazo: {new Date(task.deadline).toLocaleDateString("pt-BR")}</span>
              )}
              <span className="flex items-center gap-1">
                <Coins className="h-3 w-3" /> 
                {(task.wei / 1e18).toFixed(3)} ETH
              </span>
            </div>
          </div>
          {!isCompleted && (
            <Tooltip>
              <TooltipTrigger asChild>
                <div className="inline-block">
                  <Button
                    variant="outline"
                    size="icon"
                    onClick={handleComplete}
                    disabled={!isConnected || isPending}
                    aria-label="Concluir Tarefa"
                    className="border-violet-300 text-violet-600 hover:bg-violet-50 hover:text-violet-700 disabled:opacity-50"
                  >
                    {isPending ? (
                      <Loader className="h-5 w-5 animate-spin" />
                    ) : (
                      <CheckSquare className="h-5 w-5" />
                    )}
                  </Button>
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>
                  {!isConnected 
                    ? "Conecte a carteira para concluir" 
                    : isPending 
                      ? "Processando transaÃ§Ã£o..."
                      : "Concluir Tarefa"
                  }
                </p>
              </TooltipContent>
            </Tooltip>
          )}
        </div>
      </CardContent>
    </Card>
  )
}
```

#### ğŸ“ **Criar `components/CreateTaskModal.tsx`**

```typescript
// components/CreateTaskModal.tsx - Modal para criar tarefas

'use client'

import { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Label } from '@/components/ui/label'
import { Loader } from 'lucide-react'
import { useCreateTask } from '@/hooks/useTaskManager'

interface CreateTaskModalProps {
  open: boolean
  onClose: () => void
}

export function CreateTaskModal({ open, onClose }: CreateTaskModalProps) {
  const [title, setTitle] = useState('')
  const [description, setDescription] = useState('')
  const [deadline, setDeadline] = useState('')
  const [stakeAmount, setStakeAmount] = useState('0.001')
  
  const { createTask, isPending } = useCreateTask()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    try {
      const deadlineDate = new Date(deadline)
      await createTask(title, description, deadlineDate, stakeAmount)
      
      // Limpa formulÃ¡rio e fecha modal
      setTitle('')
      setDescription('')
      setDeadline('')
      setStakeAmount('0.001')
      onClose()
      
    } catch (error) {
      console.error('Erro ao criar tarefa:', error)
    }
  }

  // Gera data mÃ­nima (hoje + 1 hora)
  const minDateTime = new Date(Date.now() + 60 * 60 * 1000).toISOString().slice(0, 16)

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>ğŸ¯ Nova Tarefa na Blockchain</DialogTitle>
        </DialogHeader>
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="title">TÃ­tulo da Tarefa</Label>
            <Input
              id="title"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder="Ex: Estudar Solidity"
              required
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="description">DescriÃ§Ã£o</Label>
            <Textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Descreva o que precisa ser feito..."
              rows={3}
              required
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="deadline">Prazo Final</Label>
            <Input
              id="deadline"
              type="datetime-local"
              value={deadline}
              onChange={(e) => setDeadline(e.target.value)}
              min={minDateTime}
              required
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="stake">Valor do Stake (ETH)</Label>
            <Input
              id="stake"
              type="number"
              step="0.001"
              min="0.001"
              value={stakeAmount}
              onChange={(e) => setStakeAmount(e.target.value)}
              placeholder="0.001"
              required
            />
            <p className="text-xs text-gray-500">
              ğŸ’¡ MÃ­nimo: 0.001 ETH â€¢ VocÃª recupera se completar no prazo!
            </p>
          </div>
          
          <div className="flex justify-end gap-3 pt-4">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancelar
            </Button>
            <Button type="submit" disabled={isPending} className="bg-violet-600 hover:bg-violet-700">
              {isPending ? (
                <>
                  <Loader className="mr-2 h-4 w-4 animate-spin" />
                  Criando...
                </>
              ) : (
                'Criar Tarefa'
              )}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}
```

### âš¡ **Passo 7: Testar e Configurar a IntegraÃ§Ã£o**

#### ğŸ”§ **7.1 Atualizar ConfiguraÃ§Ãµes**

**ğŸ“ Atualizar `lib/web3.ts` com seus dados reais:**

```typescript
// lib/web3.ts - Configure com seus dados

// ğŸ”‘ Substitua pelas suas chaves reais
const projectId = 'SUA_WALLETCONNECT_KEY_AQUI'  // De https://cloud.walletconnect.com
const alchemyApiKey = 'SUA_ALCHEMY_KEY_AQUI'    // De https://alchemy.com

// ğŸ“ Substitua pelo endereÃ§o do seu contrato deployado
export const CONTRACT_ADDRESS = '0xSEU_ENDERECO_DEPLOYADO_AQUI'
```

#### ğŸ§ª **7.2 Testar Localmente**

**1. ğŸš€ Iniciar o servidor:**
```bash
pnpm dev
```

**2. ğŸŒ Abrir http://localhost:3000**

**3. âœ… Fluxo de teste:**
1. **Conectar carteira**: Clique em "Conectar Carteira" â†’ MetaMask aparece
2. **Ver dados atualizados**: Dashboard mostra saldo e endereÃ§o
3. **Criar tarefa**: Clique "Nova Tarefa" â†’ Preenche formulÃ¡rio â†’ Assina transaÃ§Ã£o
4. **Ver tarefa na lista**: Tarefa aparece automaticamente apÃ³s confirmaÃ§Ã£o
5. **Completar tarefa**: Clique no âœ… â†’ Assina transaÃ§Ã£o â†’ Status atualiza

#### ğŸ” **7.3 Debug e Troubleshooting**

**ğŸš¨ Problemas comuns e soluÃ§Ãµes:**

**1. "MetaMask nÃ£o aparece"**
```typescript
// Verifique se MetaMask estÃ¡ instalado
console.log('MetaMask instalado:', typeof window.ethereum !== 'undefined')
```

**2. "Erro ao conectar"**
```typescript
// Verifique configuraÃ§Ã£o wagmi
console.log('ConfiguraÃ§Ã£o wagmi:', config)
console.log('Conectores disponÃ­veis:', connectors)
```

**3. "TransaÃ§Ãµes falham"**
```typescript
// Debug de transaÃ§Ãµes
console.log('EndereÃ§o do contrato:', CONTRACT_ADDRESS)
console.log('Rede conectada:', await provider.getNetwork())
```

**4. "Dados nÃ£o atualizam"**
```typescript
// Verifique hooks wagmi
console.log('Dados das tarefas:', taskIds)
console.log('Loading:', isLoading)
console.log('Erro:', error)
```

### ğŸ¯ **Resumo Final: O que Conquistamos**

**âœ… Sistema Completo Funcionando:**

1. **ğŸ”Œ ConexÃ£o**: MetaMask conecta no nosso site
2. **ğŸ“ CriaÃ§Ã£o**: UsuÃ¡rio cria tarefas que vÃ£o para blockchain
3. **ğŸ“Š VisualizaÃ§Ã£o**: Dados atualizados em tempo real
4. **âœ… InteraÃ§Ã£o**: Completar tarefas com transaÃ§Ãµes reais
5. **ğŸ’° Stakes**: Sistema financeiro com ETH real (testnet)

**ğŸ§© Arquitetura Final:**

```
ğŸ‘¤ USUÃRIO
    â†“ clica "Criar Tarefa"
ğŸ’» COMPONENTE CreateTask
    â†“ chama createTask()
ğŸ£ HOOK useCreateTask  
    â†“ usa writeContract()
âš¡ VIEM
    â†“ traduz para blockchain
ğŸ¦Š METAMASK
    â†“ usuÃ¡rio assina transaÃ§Ã£o
ğŸŒ BLOCKCHAIN
    â†“ executa createTask()
ğŸ“¡ WAGMI
    â†“ detecta mudanÃ§a automÃ¡tica
ğŸ”„ CACHE
    â†“ atualiza dados
ğŸ’» COMPONENTE TaskList
    â†“ mostra nova tarefa
ğŸ‘¤ USUÃRIO
    â†“ vÃª atualizaÃ§Ã£o em tempo real! âœ¨
```

**ğŸš€ Seu app agora Ã© um DApp completo!**

- âœ… **D**ecentralized: Roda na blockchain
- âœ… **A**pplication: Interface bonita e funcional  
- âœ… **P**rotocol: Smart contract com regras automÃ¡ticas

### ğŸš€ **Passo 8: ImplementaÃ§Ã£o Completa com Dados Reais**

Por enquanto estamos usando dados simulados. Para buscar dados reais da blockchain, atualize os hooks:

#### ğŸ“ **Atualizar `hooks/useTaskManager.ts` para dados reais:**

```typescript
// hooks/useTaskManager.ts - VersÃ£o com dados reais da blockchain

import { useReadContract, useWriteContract, useAccount } from 'wagmi'
import { CONTRACT_ADDRESS, CONTRACT_ABI } from '@/lib/web3'
import { parseEther } from 'viem'

// ğŸ£ Hook: Buscar minhas tarefas (dados reais)
export function useMyTasks() {
  const { address } = useAccount()
  
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'getMyTasks',
    account: address,
    enabled: !!address, // SÃ³ busca se conectado
  })
}

// ğŸ” Hook: Buscar dados de uma tarefa especÃ­fica (dados reais)
export function useTask(taskId: number | undefined) {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'tasks',
    args: taskId ? [BigInt(taskId)] : undefined,
    enabled: !!taskId,
  })
}

// ğŸ“Š Hook: Buscar total de tarefas no sistema
export function useTotalTasks() {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'totalTasks',
  })
}

// âœï¸ Hook: Criar nova tarefa (funcionando)
export function useCreateTask() {
  const { writeContract, isPending, error } = useWriteContract()
  
  const createTask = async (
    title: string, 
    description: string, 
    deadline: Date,
    stakeAmount: string = '0.001'
  ) => {
    const deadlineTimestamp = Math.floor(deadline.getTime() / 1000)
    
    await writeContract({
      address: CONTRACT_ADDRESS,
      abi: CONTRACT_ABI,
      functionName: 'createTask',
      args: [title, description, BigInt(deadlineTimestamp)],
      value: parseEther(stakeAmount),
    })
  }
  
  return { createTask, isPending, error }
}

// âœ… Hook: Completar tarefa (funcionando)
export function useCompleteTask() {
  const { writeContract, isPending, error } = useWriteContract()
  
  const completeTask = async (taskId: number) => {
    await writeContract({
      address: CONTRACT_ADDRESS,
      abi: CONTRACT_ABI,
      functionName: 'completeTask',
      args: [BigInt(taskId)],
    })
  }
  
  return { completeTask, isPending, error }
}

// ğŸ”— Hook: Status da conexÃ£o
export function useWeb3Status() {
  const { address, isConnected } = useAccount()
  
  return {
    address,
    isConnected,
    shortAddress: address ? `${address.slice(0, 6)}...${address.slice(-4)}` : null
  }
}
```

#### ğŸ“ **Atualizar `app/page.tsx` para usar dados reais:**

```typescript
// No useMemo de tasks, substitua por dados reais:

const tasks = useMemo(() => {
  if (!taskIds || !isConnected) return []
  
  // ğŸ”„ IMPLEMENTAÃ‡ÃƒO REAL: Buscar cada tarefa individualmente
  // Por enquanto retorna array vazio, mas cada taskId seria buscado via useTask()
  return taskIds.map(id => {
    // Aqui vocÃª buscaria cada tarefa individualmente:
    // const { data: taskData } = useTask(Number(id))
    // return taskData ? formatTaskForUI(taskData) : null
    return null
  }).filter(Boolean)
}, [taskIds, isConnected])
```

### ğŸ¯ **Resumo Final: Sua Jornada Web3 Completa**

**âœ… O que vocÃª conquistou:**

1. **ğŸ—ï¸ Smart Contract**: Criou e deployou na blockchain Sepolia
2. **ğŸ¨ Interface Moderna**: Manteve seu design bonito e responsivo  
3. **ğŸ”— IntegraÃ§Ã£o Web3**: Conectou frontend com blockchain
4. **ğŸ’° Sistema de Stakes**: Implementou incentivos financeiros reais
5. **âš¡ Tempo Real**: Dados atualizados automaticamente
6. **ğŸ“± UX Perfeita**: ExperiÃªncia de usuÃ¡rio fluida

**ğŸš€ Arquitetura Final:**

```
ğŸ‘¤ USUÃRIO
    â†“ clica "Conectar Carteira"
ğŸ¦Š METAMASK
    â†“ conecta na Sepolia
ğŸ’» REACT FRONTEND (Next.js + Tailwind)
    â†“ usa hooks wagmi
ğŸ£ HOOKS CUSTOMIZADOS
    â†“ chamam viem
âš¡ VIEM + WAGMI
    â†“ traduzem para blockchain
ğŸŒ SEPOLIA TESTNET
    â†“ executa smart contract
ğŸª TASKMANAGER CONTRACT
    â†“ emite eventos
ğŸ“¡ WAGMI LISTENING
    â†“ detecta mudanÃ§as
ğŸ”„ AUTO-UPDATE UI
    â†“ mostra novos dados
ğŸ‘¤ USUÃRIO vÃª resultado! âœ¨
```

**ğŸ§© Stack TecnolÃ³gica Final:**
- **Frontend**: Next.js 14 + TypeScript + Tailwind CSS
- **UI Components**: shadcn/ui + Radix UI + Lucide Icons
- **Web3**: wagmi + viem + TanStack Query
- **Blockchain**: Ethereum Sepolia + Alchemy/Infura
- **Smart Contract**: Solidity + Foundry
- **Carteira**: MetaMask + WalletConnect

**ğŸ‰ ParabÃ©ns!** VocÃª transformou um frontend React comum em um **DApp (Decentralized Application)** completo, mantendo a simplicidade e elegÃ¢ncia da interface original!
