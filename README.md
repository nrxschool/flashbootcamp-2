# Web3 todo interface

*Automatically synced with your [v0.dev](https://v0.dev) deployments*

[![Deployed on Vercel](https://img.shields.io/badge/Deployed%20on-Vercel-black?style=for-the-badge&logo=vercel)](https://vercel.com/manoelgomesdevs-projects/v0-web3-todo-interface)
[![Built with v0](https://img.shields.io/badge/Built%20with-v0.dev-black?style=for-the-badge)](https://v0.dev/chat/projects/Tw7JzfnvoEm)

## Overview

This repository will stay in sync with your deployed chats on [v0.dev](https://v0.dev).
Any changes you make to your deployed app will be automatically pushed to this repository from [v0.dev](https://v0.dev).

## Deployment

Your project is live at:

**[https://vercel.com/manoelgomesdevs-projects/v0-web3-todo-interface](https://vercel.com/manoelgomesdevs-projects/v0-web3-todo-interface)**

## Build your app

Continue building your app on:

**[https://v0.dev/chat/projects/Tw7JzfnvoEm](https://v0.dev/chat/projects/Tw7JzfnvoEm)**

## How It Works

1. Create and modify your project using [v0.dev](https://v0.dev)
2. Deploy your chats from the v0 interface
3. Changes are automatically pushed to this repository
4. Vercel deploys the latest version from this repository

---

## ğŸ“š Aula 1

### ğŸš€ Prompt para criar seu Front com mais agilidade

```
WEB3 TODO â€” Interface de UsuÃ¡rio

O objetivo deste projeto Ã© desenvolver a interface de usuÃ¡rio do WEB3 TODO, um aplicativo de gerenciamento de tarefas com integraÃ§Ã£o Ã  tecnologia Web3. O sistema permitirÃ¡ que os usuÃ¡rios conectem sua carteira digital, criem e acompanhem tarefas, alÃ©m de visualizarem mÃ©tricas em tempo real, sempre priorizando a usabilidade e o design moderno.

A estrutura da interface Ã© dividida em trÃªs Ã¡reas principais:

1. CabeÃ§alho

Exibir no topo da pÃ¡gina um botÃ£o de destaque com o rÃ³tulo "Conectar Carteira".

Abaixo do botÃ£o, apresentar uma mensagem de alerta:
"Conecte sua carteira para gerenciar suas tarefas na blockchain."

O botÃ£o e a mensagem devem indicar visualmente o status da conexÃ£o com a carteira, facilitando o entendimento do usuÃ¡rio sobre o que estÃ¡ ou nÃ£o disponÃ­vel.

2. SeÃ§Ã£o de MÃ©tricas

Criar uma grade horizontal com quatro cards informativos:

Total de Tarefas

Tarefas ConcluÃ­das

Tarefas Pendentes

Wei em Stake

Cada card deve:

Utilizar cores que remetam Ã  tecnologia, como azul cobalto, ciano elÃ©trico e violeta digital.

Conter Ã­cones visuais que facilitem a leitura rÃ¡pida dos dados.

3. SeÃ§Ã£o de Tarefas

Exibir o tÃ­tulo da seÃ§Ã£o: "Tarefas".

Ao lado do tÃ­tulo, adicionar um botÃ£o destacado: "Nova Tarefa".

Exibir a lista de tarefas em formato de cards horizontais, contendo:

Nome da tarefa

Status: Pendente ou ConcluÃ­do

DescriÃ§Ã£o

Data de criaÃ§Ã£o

Data de conclusÃ£o (se aplicÃ¡vel)

Valor em wei associado

Ãcone de aÃ§Ã£o para "Concluir Tarefa" (sem ediÃ§Ã£o ou exclusÃ£o)

Os cards devem:

ReforÃ§ar visualmente as aÃ§Ãµes disponÃ­veis.

Diferenciar claramente tarefas pendentes e tarefas concluÃ­das.

Diretrizes de Design

Estilo Visual

Interface clean e moderna, com tema claro (light mode).

Aplicar a regra 60-30-10 para proporÃ§Ã£o de cores.

Utilizar no mÃ¡ximo duas cores principais.

Tipografia clara com hierarquia visual definida.

Design minimalista, com espaÃ§amento adequado.

Fornecer feedback visual para:

AÃ§Ãµes do usuÃ¡rio

Estados de carregamento

Erros ou validaÃ§Ãµes

Interface responsiva para se adaptar a diferentes dispositivos.

Clareza e ConsistÃªncia

Utilizar rÃ³tulos descritivos e Ã­cones intuitivos.

Manter coerÃªncia visual em:

Cores

Tamanhos

Fontes

EspaÃ§amentos

Destacar visualmente elementos que dependem da conexÃ£o da carteira.

Interatividade

Fornecer feedback imediato com animaÃ§Ãµes suaves.

Criar transiÃ§Ãµes fluidas entre os diferentes estados da interface.

BotÃµes devem apresentar estados visuais distintos:

Hover

Ativo

Desativado

Carregando

Acessibilidade

Garantir contraste de cores adequado.

Incluir textos alternativos (alt) para Ã­cones e imagens.

Permitir navegaÃ§Ã£o completa por teclado.

Evitar a comunicaÃ§Ã£o exclusiva por cor (ex: nÃ£o usar sÃ³ cor para indicar status).

ConsideraÃ§Ãµes Finais

A interface deve ser intuitiva e acessÃ­vel para iniciantes em Web3, deixando claro quando determinadas funcionalidades exigem a carteira conectada. Todos os elementos interativos devem responder com feedback visual, e a experiÃªncia deve manter consistÃªncia e fluidez em toda a jornada do usuÃ¡rio.
```

---

## ğŸ“ Aula 2

### ğŸ”— O que Ã© Blockchain Ethereum?

**Blockchain** Ã© como um **livro de registros digital** que funciona de forma descentralizada:

- **ğŸ“– Livro PÃºblico**: Todas as transaÃ§Ãµes ficam registradas e visÃ­veis para todos
- **ğŸ”’ ImutÃ¡vel**: Uma vez registrado, nÃ£o pode ser alterado ou apagado
- **ğŸŒ Descentralizado**: NÃ£o hÃ¡ uma autoridade central controlando
- **â›“ï¸ Em Blocos**: InformaÃ§Ãµes organizadas em "blocos" conectados em sequÃªncia

**Ethereum** Ã© uma blockchain especial que permite executar **programas** (smart contracts), nÃ£o apenas transferir dinheiro como o Bitcoin.

### ğŸ“‹ O que Ã© Smart Contract?

**Smart Contract** Ã© um **programa de computador** que roda na blockchain:

- **ğŸ¤– AutomÃ¡tico**: Executa sozinho quando as condiÃ§Ãµes sÃ£o atendidas
- **ğŸ“ CÃ³digo Ã© Lei**: As regras estÃ£o escritas em cÃ³digo e nÃ£o podem ser quebradas
- **ğŸ” Transparente**: Qualquer pessoa pode ver o cÃ³digo e verificar como funciona
- **ğŸ’° Lida com Dinheiro**: Pode receber, guardar e enviar criptomoedas

**Exemplo prÃ¡tico**: 
- VocÃª cria uma tarefa no nosso sistema
- Envia 0.001 ETH como "aposta" 
- Se completar no prazo = recebe o dinheiro de volta
- Se atrasar = perde o dinheiro
- Tudo acontece automaticamente, sem intermediÃ¡rios!

### â›½ O que Ã© "Gas"?

**Gas** Ã© a **"gasolina"** da blockchain Ethereum:

- **ğŸ’¸ Taxa de TransaÃ§Ã£o**: VocÃª paga para usar a blockchain
- **âš¡ Energia Computacional**: Quanto mais complexa a operaÃ§Ã£o, mais gas custa
- **ğŸ‘· Pagamento aos Mineradores**: Quem mantÃ©m a rede funcionando recebe essas taxas
- **ğŸš€ Velocidade**: Pagar mais gas = transaÃ§Ã£o mais rÃ¡pida

**Analogia simples**:
- Blockchain = Estrada
- Smart Contract = Destino  
- Gas = CombustÃ­vel para chegar lÃ¡
- Mais gas = Viagem mais rÃ¡pida, menos gas = Viagem mais lenta

**Exemplo de custos**:
- Criar tarefa: ~50,000 gas
- Completar tarefa: ~30,000 gas  
- Consultar dados: 0 gas (leitura Ã© grÃ¡tis!)

**ğŸ’¡ Dica**: Gas varia conforme a demanda da rede. Em horÃ¡rios de pico, fica mais caro!

### ğŸ’» Entendendo Solidity - A Linguagem dos Smart Contracts

**Solidity** Ã© como o **"idioma oficial"** para escrever contratos inteligentes no Ethereum.

#### ğŸŒ **Onde Solidity Ã© Usado?**

**Analogia**: Como **idiomas do mundo real**:

- **PortuguÃªs**: Usado no Brasil, Portugal, alguns paÃ­ses da Ãfrica
- **InglÃªs**: Usado nos EUA, Inglaterra, AustrÃ¡lia
- **Solidity**: Usado em **blockchains compatÃ­veis com Ethereum**

**Principais blockchains que "falam" Solidity**:
- ğŸ”· **Ethereum** (a blockchain original)
- ğŸŸ£ **Polygon** (mais rÃ¡pida e barata)
- ğŸŸ¡ **Binance Smart Chain** (BSC)
- ğŸ”µ **Avalanche** 
- âšª **Arbitrum** e **Optimism** (Layer 2 do Ethereum)

#### ğŸ“š **Conceitos BÃ¡sicos de Solidity**

#### ğŸ—ï¸ **1. Struct - O "FormulÃ¡rio PadrÃ£o"**

```solidity
struct Task {
    uint256 id;
    string title;
    bool isCompleted;
}
```

**Analogia**: Como **formulÃ¡rio de cadastro** mÃ©dico:

- **Struct** = O **modelo em branco** do formulÃ¡rio
- Cada struct define **exatamente quais campos** existem
- Ã‰ como dizer: "Todo paciente tem: Nome, CPF, Idade"
- **ReutilizÃ¡vel**: VocÃª pode preencher **milhares** de formulÃ¡rios iguais

**No nosso caso**:
- `Task` = Modelo do formulÃ¡rio de tarefa
- Toda tarefa **sempre** tem: id, tÃ­tulo, descriÃ§Ã£o, prazo, etc.
- Ã‰ como ter um **"carimbo"** que sempre cria fichas idÃªnticas

#### ğŸ’¾ **2. Memory vs Storage - "Caderno vs Arquivo"**

**Analogia**: Como **diferentes tipos de anotaÃ§Ã£o**:

**ğŸ“ Memory - "Rascunho"**:
```solidity
string memory tempTitle = "Estudar Solidity";
```
- Ã‰ como escrever num **papel rascunho**
- **TemporÃ¡rio**: Depois que a funÃ§Ã£o termina, some
- **RÃ¡pido**: NÃ£o custa muito gas
- **Uso**: Calculations, variÃ¡veis temporÃ¡rias

**ğŸ“ Storage - "Arquivo Permanente"**:
```solidity
Task storage task = tasks[1];  // Pegando uma tarefa jÃ¡ salva
task.isCompleted = true;       // Modificando permanentemente
```
- Ã‰ como escrever num **arquivo oficial**
- **Permanente**: Fica gravado na blockchain para sempre
- **Caro**: Custa mais gas (vocÃª estÃ¡ pagando pelo "papel oficial")
- **Uso**: Dados que precisam ser salvos

**Exemplo PrÃ¡tico**:
```solidity
function completeTask(uint256 _taskId) public {
    string memory message = "Completing task...";  // MEMORY (temporÃ¡rio)
    Task storage task = tasks[_taskId];             // STORAGE (permanente)
    task.isCompleted = true;                        // Modifica permanentemente
}
```

#### ğŸ”¢ **3. Tipos de Dados BÃ¡sicos**

**Analogia**: Como **tipos de gaveta** para guardar coisas:

```solidity
uint256 public totalTasks;           // Gaveta para NÃšMEROS (sempre positivos)
string public title;                 // Gaveta para TEXTO
bool public isCompleted;             // Gaveta para SIM/NÃƒO
address public creator;              // Gaveta para ENDEREÃ‡OS da blockchain
mapping(uint256 => Task) tasks;      // Gaveta para DICIONÃRIOS (chave â†’ valor)
```

- **`uint256`**: Como gaveta para **"nÃºmeros grandes positivos"** (0, 1, 2, 1000000...)
- **`string`**: Como gaveta para **"textos"** ("JoÃ£o", "Estudar Solidity")
- **`bool`**: Como gaveta para **"verdadeiro/falso"** (true/false, sim/nÃ£o)
- **`address`**: Como gaveta para **"CPF da blockchain"** (0x1a2b3c4d...)
- **`mapping`**: Como gaveta para **"agenda telefÃ´nica"** (nome â†’ telefone)

#### ğŸ›¡ï¸ **4. Modificadores de Visibilidade**

**Analogia**: Como **nÃ­veis de privacidade** numa empresa:

```solidity
uint256 public totalTasks;     // PÃšBLICO - Qualquer um pode ver
uint256 private secretData;    // PRIVADO - SÃ³ este contrato vÃª
uint256 internal teamData;     // INTERNO - SÃ³ "funcionÃ¡rios" (contratos filhos) veem
```

- **`public`**: Como **"mural da empresa"** - todo mundo pode ler
- **`private`**: Como **"cofre do diretor"** - sÃ³ o prÃ³prio contrato acessa
- **`internal`**: Como **"pasta da equipe"** - sÃ³ contratos "da famÃ­lia" acessam

#### âš¡ **5. Functions - As "MÃ¡quinas" do Contrato**

```solidity
function createTask(string memory _title) public payable returns (uint256) {
    // CÃ³digo aqui
    return newTaskId;
}
```

**Partes da funÃ§Ã£o**:
- **`function`**: "Esta Ã© uma mÃ¡quina"
- **`createTask`**: Nome da mÃ¡quina
- **`(string memory _title)`**: "Ingredientes" que vocÃª coloca na mÃ¡quina
- **`public`**: "Qualquer um pode usar esta mÃ¡quina"
- **`payable`**: "Esta mÃ¡quina aceita dinheiro"
- **`returns (uint256)`**: "Esta mÃ¡quina devolve um nÃºmero"

### ğŸ”¨ Framework Foundry - A "Oficina Profissional"

**Foundry** Ã© como uma **oficina mecÃ¢nica completa** para desenvolver smart contracts.

#### ğŸ¯ **Por que Foundry Ã© Especial?**

**Analogia**: Comparando **oficinas**:

**ğŸ”§ Oficina Antiga (Remix, Truffle)**:
- Como oficina de **"fundo de quintal"**
- Ferramentas bÃ¡sicas
- Tudo manual e lento
- DifÃ­cil de organizar projetos grandes

**ğŸ­ Foundry - "Oficina da Mercedes"**:
- Como oficina **profissional de montadora**
- Ferramentas de Ãºltima geraÃ§Ã£o
- Tudo automatizado e rÃ¡pido
- OrganizaÃ§Ã£o industrial

#### âš™ï¸ **Ferramentas do Foundry**

**1. ğŸ”¨ Forge - O "Martelo Inteligente"**:
```bash
forge build    # ConstrÃ³i o contrato
forge test     # Testa todas as funcionalidades
forge deploy   # Coloca na blockchain
```
- **Analogia**: Como **robÃ´ de montagem** que faz tudo automaticamente

**2. ğŸ“Š Cast - O "Medidor Universal"**:
```bash
cast call 0x... "totalTasks()"  # Consulta dados do contrato
cast send 0x... "createTask()"  # Executa funÃ§Ã£o
```
- **Analogia**: Como **multÃ­metro profissional** que mede qualquer coisa

**3. âš¡ Anvil - A "Bancada de Teste"**:
```bash
anvil  # Cria blockchain local para testes
```
- **Analogia**: Como **bancada com todos os equipamentos** para testar peÃ§as

#### ğŸš€ **Vantagens do Foundry**

**1. ğŸƒâ€â™‚ï¸ Velocidade Extrema**:
- **Testes rodam em milissegundos** (vs. segundos em outras ferramentas)
- Como comparar **Ferrari vs. bicicleta**

**2. ğŸ§ª Testes em Solidity**:
- VocÃª escreve testes **na mesma linguagem** do contrato
- Como mecÃ¢nico **usar as mesmas ferramentas** para construir e testar

**3. ğŸ“¦ GestÃ£o de DependÃªncias**:
```bash
forge install OpenZeppelin/openzeppelin-contracts
```
- Como **loja de auto-peÃ§as integrada** na oficina

**4. ğŸ” Debugging AvanÃ§ado**:
- Mostra **exatamente onde** o erro aconteceu
- Como **raio-X** que mostra problema interno

**5. â›½ AnÃ¡lise de Gas**:
- Calcula **exatamente quanto** cada funÃ§Ã£o custa
- Como **calculadora de combustÃ­vel** precisa

#### ğŸ“¦ **InstalaÃ§Ã£o do Foundry - "Montando sua Oficina"**

**Analogia**: Como **montar uma oficina profissional** em casa - vocÃª precisa das ferramentas certas!

#### ğŸ”§ **PrÃ©-requisitos (O que vocÃª precisa ter)**

**1. ğŸ’» Sistema Operacional CompatÃ­vel**:
- âœ… **Linux** (recomendado)
- âœ… **macOS** 
- âœ… **Windows** (via WSL - Windows Subsystem for Linux)

**Analogia**: Como verificar se sua **garagem tem espaÃ§o** para a oficina.

**2. ğŸ¦€ Rust (Linguagem de ProgramaÃ§Ã£o)**:
- Foundry Ã© escrito em **Rust**
- Ã‰ como o **"motor"** que faz tudo funcionar

**3. ğŸ“‹ Git (Controle de VersÃ£o)**:
- Para baixar bibliotecas e gerenciar cÃ³digo
- Como o **"sistema de entrega"** da oficina

#### ğŸš€ **InstalaÃ§Ã£o Passo a Passo**

#### **MÃ©todo 1: InstalaÃ§Ã£o AutomÃ¡tica (Recomendado)**

**1. ğŸ“¥ Instalar Foundry com um comando:**

```bash
curl -L https://foundry.paradigm.xyz | bash
```

**Analogia**: Como **"kit de oficina automÃ¡tico"** - um caminhÃ£o chega e instala tudo de uma vez!

**2. ğŸ”„ Reiniciar o terminal ou executar:**

```bash
source ~/.bashrc
```

**3. ğŸ“¦ Instalar as ferramentas:**

```bash
foundryup
```

**Analogia**: Como **"ligar todas as mÃ¡quinas"** da oficina pela primeira vez.

#### **MÃ©todo 2: InstalaÃ§Ã£o Manual (Para UsuÃ¡rios AvanÃ§ados)**

```bash
# 1. Instalar Rust (se nÃ£o tiver)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 2. Instalar Foundry via Cargo (gerenciador do Rust)
cargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked
```

#### **Para Windows (WSL)**

**1. ğŸªŸ Instalar WSL primeiro:**

```powershell
wsl --install Ubuntu
```

**2. ğŸ§ Dentro do WSL, seguir os passos do Linux:**

```bash
curl -L https://foundry.paradigm.xyz | bash
foundryup
```

**Analogia**: Como **"construir uma oficina dentro do porÃ£o"** (WSL Ã© como o porÃ£o do Windows).

#### âœ… **Verificando se Funcionou**

**Teste se as ferramentas estÃ£o instaladas:**

```bash
forge --version    # Deve mostrar versÃ£o do Forge
cast --version     # Deve mostrar versÃ£o do Cast  
anvil --version    # Deve mostrar versÃ£o do Anvil
```

**Analogia**: Como **"testar se todas as mÃ¡quinas ligam"** na sua nova oficina.

#### ğŸ› ï¸ **Criando seu Primeiro Projeto**

```bash
# 1. Criar novo projeto
forge init meu-primeiro-contrato

# 2. Entrar na pasta
cd meu-primeiro-contrato

# 3. Compilar contratos de exemplo
forge build

# 4. Rodar testes
forge test
```

**Estrutura criada automaticamente:**
```
meu-primeiro-contrato/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ Counter.sol           # Contrato de exemplo
â”œâ”€â”€ test/
â”‚   â””â”€â”€ Counter.t.sol         # Teste de exemplo
â”œâ”€â”€ script/
â”‚   â””â”€â”€ Counter.s.sol         # Script de deploy
â”œâ”€â”€ foundry.toml              # ConfiguraÃ§Ãµes
â””â”€â”€ lib/                      # Bibliotecas (vazio inicialmente)
```

**Analogia**: Como receber uma **"oficina prÃ©-montada"** com tudo organizado e um projeto de exemplo para vocÃª comeÃ§ar!

#### ğŸš¨ **Problemas Comuns e SoluÃ§Ãµes**

**1. ğŸ’£ "command not found: forge"**

**SoluÃ§Ã£o**: Reiniciar terminal ou executar:
```bash
source ~/.bashrc
# ou
source ~/.zshrc
```

**2. ğŸŒ InstalaÃ§Ã£o muito lenta**

**SoluÃ§Ã£o**: Usar um VPN ou tentar em horÃ¡rio diferente:
```bash
# Usar proxy se necessÃ¡rio
export https_proxy=http://proxy:port
```

**3. ğŸªŸ Problemas no Windows**

**SoluÃ§Ã£o**: Instalar WSL2:
```powershell
# No PowerShell como administrador
wsl --install
wsl --set-default-version 2
```

#### ğŸ’¡ **Dicas Pro**

**1. ğŸ”„ Manter Atualizado:**
```bash
foundryup  # Atualiza para a versÃ£o mais recente
```

**2. ğŸ“š Instalar Bibliotecas Ãšteis:**
```bash
# OpenZeppelin (biblioteca de seguranÃ§a)
forge install OpenZeppelin/openzeppelin-contracts

# Solmate (biblioteca otimizada)
forge install transmissions11/solmate
```

**3. âš™ï¸ Configurar VS Code:**
- Instalar extensÃ£o "Solidity"
- Configurar para usar Foundry como formatter

**Analogia**: Como **"personalizar sua oficina"** com ferramentas extras e organizaÃ§Ã£o prÃ³pria!

#### ğŸ’¼ **Foundry vs. Outras Ferramentas**

| CaracterÃ­stica | Foundry | Hardhat | Remix |
|---|---|---|---|
| **Velocidade** | ğŸï¸ Ferrari | ğŸš— Carro normal | ğŸš² Bicicleta |
| **Linguagem dos testes** | Solidity | JavaScript | Manual |
| **InstalaÃ§Ã£o** | 1 comando | ConfiguraÃ§Ã£o complexa | Browser |
| **Para iniciantes** | ğŸ“š Curva de aprendizado | ğŸ˜Š Mais fÃ¡cil | ğŸ¯ Muito simples |
| **Para profissionais** | ğŸ‘‘ PadrÃ£o da indÃºstria | âœ… Boa opÃ§Ã£o | âŒ Limitado |

#### ğŸ—ï¸ **Estrutura de Projeto Foundry**

```
meu-projeto/
â”œâ”€â”€ src/           # Contratos principais
â”œâ”€â”€ test/          # Testes
â”œâ”€â”€ script/        # Scripts de deploy  
â”œâ”€â”€ lib/           # Bibliotecas externas
â””â”€â”€ foundry.toml   # ConfiguraÃ§Ãµes
```

**Analogia**: Como **organizaÃ§Ã£o de oficina profissional**:
- `src/` = **"Ãrea de montagem"** (onde vocÃª constrÃ³i)
- `test/` = **"Ãrea de testes"** (onde vocÃª verifica qualidade)
- `script/` = **"Manuais de procedimento"** (como fazer deploy)
- `lib/` = **"Estoque de peÃ§as"** (bibliotecas de terceiros)

**ğŸ¯ ConclusÃ£o**: Foundry Ã© como **"evoluir de oficina caseira para fÃ¡brica da Tesla"** - mais profissional, mais rÃ¡pido, mais confiÃ¡vel!

### ğŸ“ Anatomia do Smart Contract TaskManager

Imagine que vamos construir uma **fÃ¡brica de gerenciamento de tarefas** na blockchain. Vamos dissecar cada peÃ§a desta mÃ¡quina:

#### ğŸ—ï¸ **Estrutura BÃ¡sica do Contrato - A "CertidÃ£o de Nascimento"**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract TaskManager {
    // CÃ³digo do contrato aqui
}
```

**Analogia**: Ã‰ como o **cabeÃ§alho de um documento oficial**:

- **`SPDX-License-Identifier: MIT`**: Como uma **"licenÃ§a de uso"** - MIT significa "qualquer um pode usar gratuitamente"
  - Ã‰ como colocar "DomÃ­nio PÃºblico" numa mÃºsica
  
- **`pragma solidity ^0.8.13`**: Define a **"versÃ£o do idioma"** que estamos falando
  - Como dizer "este documento estÃ¡ escrito em PortuguÃªs versÃ£o 2024"
  - `^0.8.13` = "versÃ£o 8.13 ou mais nova, mas nÃ£o versÃ£o 9"
  
- **`contract TaskManager`**: Ã‰ o **nome da nossa empresa/fÃ¡brica**
  - Como "Papelaria JoÃ£o" ou "Padaria do Seu JosÃ©"

#### ğŸ’ **VariÃ¡veis e Constantes - As "Regras da Casa"**

```solidity
uint256 public constant MINIMUM_STAKE = 0.001 ether;
uint256 public totalTasks;
```

**Analogia**: Como **regras afixadas na parede** de um estabelecimento:

- **`MINIMUM_STAKE = 0.001 ether`**: Ã‰ o **"preÃ§o mÃ­nimo da entrada"**
  - Como uma placa: "Taxa mÃ­nima: R$ 5,00"
  - `constant` = Esta regra **NUNCA muda** (como "gravada em pedra")
  - `public` = **Todos podem ver** esta regra (estÃ¡ na parede para todos lerem)
  - `uint256` = Tipo de nÃºmero (sempre positivo, muito grande)
  
- **`totalTasks`**: Ã‰ o **"contador da porta"** daqueles cinemas
  - Conta quantas pessoas (tarefas) jÃ¡ entraram
  - ComeÃ§a em 0 e vai aumentando: 1, 2, 3, 4...
  - Ã‰ como um **"odÃ´metro" de tarefas criadas**

#### ğŸ“‹ **Struct Task - Nossa "Ficha de Cadastro"**

```solidity
struct Task {
    uint256 id;           // Identificador Ãºnico
    string title;         // TÃ­tulo da tarefa
    string description;   // DescriÃ§Ã£o detalhada
    uint256 createdAt;    // Quando foi criada (timestamp)
    uint256 deadline;     // Prazo limite (timestamp)
    bool isCompleted;     // Se foi concluÃ­da (true/false)
    address creator;      // Quem criou a tarefa
    uint256 stake;        // Valor apostado em wei
    bool stakeProcessed;  // Se o stake jÃ¡ foi processado
}
```

**Analogia**: Ã‰ como uma **ficha de cadastro mÃ©dico completa**:

- **`id`**: NÃºmero da **carteirinha do paciente** (Ãºnico, nunca repete)
- **`title`**: **Nome do tratamento** ("Consulta cardiolÃ³gica")
- **`description`**: **Detalhes do procedimento** ("Exame completo do coraÃ§Ã£o")
- **`createdAt`**: **Data de abertura da ficha** (quando foi criado o cadastro)
- **`deadline`**: **Data da consulta marcada** (prazo para completar)
- **`isCompleted`**: **"Paciente compareceu?"** (âœ… Sim / âŒ NÃ£o)
- **`creator`**: **EndereÃ§o de quem fez o agendamento** (CPF da pessoa)
- **`stake`**: **Valor da consulta** (quanto foi pago)
- **`stakeProcessed`**: **"Pagamento foi processado?"** (evita cobrar duas vezes)

**Por que struct?** Ã‰ como ter um **"formulÃ¡rio padrÃ£o"** - toda tarefa tem exatamente os mesmos campos preenchidos!

#### ğŸ—ºï¸ **Mappings - Nossos "Arquivos Organizados"**

```solidity
mapping(uint256 => Task) public tasks;
mapping(address => uint256[]) public userTasks;
```

**Analogia**: Como **dois sistemas de arquivo diferentes**:

**1. `tasks` - O "Arquivo Geral por NÃºmero"**
- Ã‰ como um **arquivo mÃ©dico por nÃºmero de protocolo**
- VocÃª fala: "Quero ver a ficha nÃºmero 1" â†’ Recebe todos os dados da Tarefa 1
- `uint256` = nÃºmero da tarefa (1, 2, 3...)
- `Task` = ficha completa com todos os dados
- Ã‰ como uma **gaveta numerada**: Gaveta 1 = Ficha 1, Gaveta 2 = Ficha 2...

**2. `userTasks` - O "Ãndice por Pessoa"**
- Ã‰ como um **caderno de "quem tem consulta marcada"**
- VocÃª fala: "Quais sÃ£o as consultas do JoÃ£o?" â†’ Recebe: [1, 5, 8] (nÃºmeros das fichas dele)
- `address` = "CPF" da pessoa na blockchain (0x1a2b3c4d...)
- `uint256[]` = lista de nÃºmeros das tarefas daquela pessoa

**Exemplo prÃ¡tico**:
- JoÃ£o criou 3 tarefas (IDs: 1, 3, 5)
- Maria criou 2 tarefas (IDs: 2, 4)
- `tasks[1]` = dados completos da tarefa 1 (do JoÃ£o)
- `userTasks[JoÃ£o]` = [1, 3, 5] (lista das tarefas do JoÃ£o)

#### ğŸ“¢ **Eventos - O "Jornal da Empresa"**

```solidity
event TaskCreated(uint256 taskId, address creator, string title, uint256 deadline, uint256 stake);
event TaskCompleted(uint256 taskId, address creator, uint256 stakeReturned);
event StakeLost(uint256 taskId, address creator, uint256 stakeLost);
```

**Analogia**: Como **manchetes de jornal que ficam arquivadas para sempre**:

**ğŸ” Por que eventos?**
- A blockchain Ã© como um **"cofre fechado"** - vocÃª nÃ£o pode "bisbilhotar" o que estÃ¡ dentro
- Eventos sÃ£o como **"recortes de jornal"** que saem do cofre e ficam acessÃ­veis
- Ã‰ uma forma de **"avisar o mundo exterior"** o que aconteceu

**ğŸ“° Nossos "tipos de notÃ­cia"**:

**1. `TaskCreated` - "Nascimentos"**
- **Manchete**: "Nova tarefa foi criada!"
- **Detalhes**: ID da tarefa, quem criou, tÃ­tulo, prazo, quanto apostou
- Como anunciar: "FamÃ­lia Silva teve um bebÃª! Nome: JoÃ£o, nasceu dia 15/03"

**2. `TaskCompleted` - "Sucessos"**
- **Manchete**: "Tarefa concluÃ­da no prazo!"
- **Detalhes**: Qual tarefa, quem completou, quanto dinheiro recebeu de volta
- Como anunciar: "JoÃ£o Silva se formou! Recebeu diploma e prÃªmio de R$ 1000"

**3. `StakeLost` - "Penalties"**
- **Manchete**: "Prazo perdido!"
- **Detalhes**: Qual tarefa, quem perdeu o prazo, quanto dinheiro foi perdido
- Como anunciar: "JoÃ£o Silva perdeu aposta de R$ 500 por nÃ£o entregar projeto"

**ğŸ”— Importante**: Estes "jornais" ficam **gravados para sempre** na blockchain - qualquer site pode ler e mostrar essas notificaÃ§Ãµes!

#### ğŸ› ï¸ **FunÃ§Ã£o createTask() - A "MÃ¡quina de Fazer Tarefas"**

```solidity
function createTask(string memory _title, string memory _description, uint256 _deadline) 
    public payable
{
    // VerificaÃ§Ãµes de seguranÃ§a
    require(_deadline > block.timestamp, "Deadline must be in the future");
    require(msg.value >= MINIMUM_STAKE, "Stake must be at least 0.001 ether");

    totalTasks++;  // Incrementa contador

    // Cria nova tarefa
    tasks[totalTasks] = Task({
        id: totalTasks,
        title: _title,
        description: _description,
        createdAt: block.timestamp,
        deadline: _deadline,
        isCompleted: false,
        creator: msg.sender,
        stake: msg.value,
        stakeProcessed: false
    });

    userTasks[msg.sender].push(totalTasks);  // Adiciona Ã  lista do usuÃ¡rio
    
    emit TaskCreated(totalTasks, msg.sender, _title, _deadline, msg.value);  // Emite evento
}
```

**Analogia**: Como uma **mÃ¡quina de fazer apostas em corrida de cavalos**:

**ğŸ° Como funciona a mÃ¡quina:**

**Entrada (ParÃ¢metros)**:
- **`_title`**: Nome do seu cavalo ("Estudar Solidity")
- **`_description`**: DescriÃ§Ã£o da corrida ("Completar curso em 30 dias")
- **`_deadline`**: Data da corrida (timestamp futuro)
- **`payable`**: A mÃ¡quina **aceita dinheiro** junto com o pedido

**ğŸ›¡ï¸ SeguranÃ§as da MÃ¡quina (require)**:
```solidity
require(_deadline > block.timestamp, "Deadline must be in the future");
```
- **Analogia**: Como um **seguranÃ§a na porta** que verifica se vocÃª nÃ£o estÃ¡ tentando apostar numa corrida que jÃ¡ acabou
- `block.timestamp` = "que horas sÃ£o agora na blockchain"
- Ã‰ como dizer: "SÃ³ aceito apostas para corridas futuras!"

```solidity
require(msg.value >= MINIMUM_STAKE, "Stake must be at least 0.001 ether");
```
- **Analogia**: Como um **caixa** que verifica se vocÃª trouxe dinheiro suficiente
- `msg.value` = quanto dinheiro vocÃª colocou na mÃ¡quina
- Ã‰ como: "Aposta mÃ­nima: R$ 5,00"

**ğŸ­ ProduÃ§Ã£o da Ficha (CriaÃ§Ã£o da Task)**:
```solidity
totalTasks++;  // Gera nÃºmero sequencial da ficha
```
- Como uma **mÃ¡quina de senha do banco**: 001, 002, 003...

```solidity
tasks[totalTasks] = Task({...});
```
- **Analogia**: Como **preencher uma ficha de aposta completa**:
  - `id`: NÃºmero da sua aposta (Ãºnico)
  - `title` e `description`: Nome e detalhes do cavalo
  - `createdAt`: "Hora que fez a aposta" (agora)
  - `deadline`: "Hora da corrida"
  - `isCompleted: false`: "Corrida ainda nÃ£o aconteceu"
  - `creator`: "Seu CPF" (quem fez a aposta)
  - `stake`: "Quanto vocÃª apostou"
  - `stakeProcessed: false`: "Pagamento ainda nÃ£o foi processado"

**ğŸ“ OrganizaÃ§Ã£o (userTasks)**:
```solidity
userTasks[msg.sender].push(totalTasks);
```
- **Analogia**: Como **anotar no seu caderno pessoal**: "Apostas que fiz: 1, 5, 12"
- A mÃ¡quina lembra **todas as suas apostas**

**ğŸ“¢ DivulgaÃ§Ã£o (Evento)**:
```solidity
emit TaskCreated(...);
```
- **Analogia**: Como **anunciar no alto-falante**: "JoÃ£o Silva fez aposta #5 no cavalo 'Estudar Solidity' para corrida do dia 15!"
- Todo mundo pode **ouvir** este anÃºncio

#### âœ… **FunÃ§Ã£o completeTask() - O "Juiz da Corrida"**

```solidity
function completeTask(uint256 _taskId) public
{
    // VerificaÃ§Ãµes
    require(_taskId > 0 && _taskId <= totalTasks, "Task does not exist");
    require(tasks[_taskId].creator == msg.sender, "Only task creator can call this function");
    
    Task storage task = tasks[_taskId];
    require(!task.isCompleted, "Task is already completed");
    require(!task.stakeProcessed, "Stake has already been processed");

    task.isCompleted = true;
    task.stakeProcessed = true;

    // LÃ³gica do stake
    if (block.timestamp <= task.deadline) {
        // No prazo = devolve o dinheiro
        (bool success, ) = payable(task.creator).call{value: task.stake}("");
        require(success, "Failed to return stake");
        emit TaskCompleted(_taskId, task.creator, task.stake);
    } else {
        // Atrasado = perde o dinheiro
        emit StakeLost(_taskId, task.creator, task.stake);
    }
}
```

**Analogia**: Como um **juiz rigoroso de corrida** que decide se vocÃª ganhou ou perdeu a aposta:

**ğŸ” VerificaÃ§Ãµes do Juiz (requires)**:

```solidity
require(_taskId > 0 && _taskId <= totalTasks, "Task does not exist");
```
- **Analogia**: "Esta aposta existe?" - Como verificar se o **bilhete Ã© vÃ¡lido**
- Evita que alguÃ©m invente nÃºmeros de apostas

```solidity
require(tasks[_taskId].creator == msg.sender, "Only task creator can call this function");
```
- **Analogia**: "VocÃª Ã© realmente dono desta aposta?" - Como pedir **documento de identidade**
- SÃ³ quem fez a aposta pode reivindicar o prÃªmio

```solidity
require(!task.isCompleted, "Task is already completed");
require(!task.stakeProcessed, "Stake has already been processed");
```
- **Analogia**: "Esta corrida jÃ¡ foi julgada?" - Evita **duplicar pagamentos**
- Como carimbar "PAGO" no bilhete para nÃ£o pagar duas vezes

**ğŸ“ MarcaÃ§Ã£o dos Resultados**:
```solidity
task.isCompleted = true;
task.stakeProcessed = true;
```
- **Analogia**: Carimbar na ficha: **"CORRIDA FINALIZADA"** e **"PAGAMENTO PROCESSADO"**

**ğŸ’° A Grande DecisÃ£o - LÃ³gica do Pagamento**:
```solidity
if (block.timestamp <= task.deadline) {
    // GANHOU!
} else {
    // PERDEU!
}
```

**ğŸ¯ CENÃRIO 1 - GANHOU (No prazo)**:
```solidity
(bool success, ) = payable(task.creator).call{value: task.stake}("");
require(success, "Failed to return stake");
emit TaskCompleted(_taskId, task.creator, task.stake);
```
- **Analogia**: Como o **caixa do hipÃ³dromo pagando sua aposta**
- `payable(task.creator).call{value: task.stake}("")` = "Transferir dinheiro para o ganhador"
- `require(success...)` = "Garantir que o dinheiro chegou na conta"
- `emit TaskCompleted(...)` = "Anunciar no alto-falante: JoÃ£o ganhou R$ 100!"

**ğŸ’¸ CENÃRIO 2 - PERDEU (Atrasado)**:
```solidity
emit StakeLost(_taskId, task.creator, task.stake);
```
- **Analogia**: Como **rasgar o bilhete de aposta perdida**
- O dinheiro fica "na casa" (no contrato)
- `emit StakeLost(...)` = "Anunciar: JoÃ£o perdeu R$ 100 por atraso"

**ğŸ° Sistema de Incentivos**:
- â° **Chegou no prazo**: Dinheiro volta 100% + sensaÃ§Ã£o de vitÃ³ria
- âŒ **Atrasou**: Perde o dinheiro + liÃ§Ã£o aprendida
- ğŸ§  **Psicologia**: A possibilidade de perder dinheiro **motiva** vocÃª a cumprir prazos!

#### ğŸ“‹ **FunÃ§Ãµes de Consulta**

```solidity
// Pega tarefas de qualquer usuÃ¡rio
function getUserTasks(address _user) public view returns (uint256[] memory) {
    return userTasks[_user];
}

// Pega suas prÃ³prias tarefas
function getMyTasks() public view returns (uint256[] memory) {
    return userTasks[msg.sender];
}

// Verifica se uma tarefa estÃ¡ atrasada
function isTaskOverdue(uint256 _taskId) public view returns (bool) {
    require(_taskId > 0 && _taskId <= totalTasks, "Task does not exist");
    Task memory task = tasks[_taskId];
    return (block.timestamp > task.deadline && !task.isCompleted);
}
```

### ğŸ§ª LaboratÃ³rio de Testes (TaskManager.t.sol)

Os testes sÃ£o como **laboratÃ³rio de qualidade** - testamos tudo antes de lanÃ§ar no mercado:

#### ğŸ”§ **PreparaÃ§Ã£o do LaboratÃ³rio (Setup)**

```solidity
contract TaskManagerTest is Test {
    TaskManager public taskManager;
    address public user1 = address(0x1);
    
    function setUp() public {
        taskManager = new TaskManager();
        vm.deal(user1, 10 ether);  // DÃ¡ dinheiro fake para testes
    }
}
```

**Analogia**: Como **montar um laboratÃ³rio de teste** para carros:

- **`TaskManager public taskManager`**: Ã‰ o **"carro protÃ³tipo"** que vamos testar
- **`address public user1 = address(0x1)`**: Ã‰ o **"motorista de teste"** (boneco de crash test)
- **`taskManager = new TaskManager()`**: **"Construir um carro novo"** para cada teste
- **`vm.deal(user1, 10 ether)`**: **"Dar combustÃ­vel"** para o motorista de teste
- **`setUp()`**: Roda **antes de cada teste** - como resetar o laboratÃ³rio

#### âœ… **Teste 1: testCreateTask() - "Teste de IgniÃ§Ã£o"**

```solidity
function testCreateTask() public {
    vm.startPrank(user1);  // Simula que user1 estÃ¡ dirigindo
    
    taskManager.createTask{value: stake}(title, description, deadline);
    
    // Verifica se os dados foram salvos corretamente
    (uint256 id, string memory taskTitle, ...) = taskManager.tasks(1);
    assertEq(id, 1);
    assertEq(taskTitle, title);
    // ... mais verificaÃ§Ãµes
}
```

**Analogia**: Como **testar se o carro liga**:

**ğŸ”‘ PreparaÃ§Ã£o do Teste**:
```solidity
vm.startPrank(user1);
```
- **Analogia**: **"Colocar o motorista no banco do motorista"**
- `vm.startPrank()` = simula que user1 estÃ¡ fazendo as aÃ§Ãµes

**ğŸš— AÃ§Ã£o Testada**:
```solidity
taskManager.createTask{value: stake}(title, description, deadline);
```
- **Analogia**: **"Virar a chave e pisar no acelerador"**
- Testamos se a "criaÃ§Ã£o de tarefa" funciona

**ğŸ” VerificaÃ§Ã£o**:
```solidity
(uint256 id, string memory taskTitle, ...) = taskManager.tasks(1);
assertEq(id, 1);
assertEq(taskTitle, title);
```
- **Analogia**: **"Verificar se o motor ligou corretamente"**
- `taskManager.tasks(1)` = "Olhar o painel do carro"
- `assertEq()` = "Confirmar que o velocÃ­metro mostra 0 km/h"

**O que este teste garante**:
- âœ… O "motor" da criaÃ§Ã£o de tarefas funciona
- âœ… Os "dados do painel" estÃ£o corretos
- âœ… O "contador" estÃ¡ funcionando

#### âœ… **Teste 2: testCompleteTask() - "Teste de Freios"**

```solidity
function testCompleteTask() public {
    // Primeiro cria uma tarefa
    taskManager.createTask{value: stake}(title, description, deadline);
    
    uint256 balanceBefore = user1.balance;
    taskManager.completeTask(1);  // Completa a tarefa
    uint256 balanceAfter = user1.balance;
    
    // Verifica se o dinheiro voltou
    assertEq(balanceAfter, balanceBefore + stake);
}
```

**Analogia**: Como **testar se os freios funcionam**:

**ğŸ PreparaÃ§Ã£o**:
```solidity
taskManager.createTask{value: stake}(title, description, deadline);
```
- **Analogia**: **"Acelerar o carro atÃ© 100 km/h"** (criar a tarefa)

**ğŸ“Š MediÃ§Ã£o Inicial**:
```solidity
uint256 balanceBefore = user1.balance;
```
- **Analogia**: **"Medir a velocidade antes de frear"** (dinheiro antes)

**ğŸ›‘ AÃ§Ã£o de Teste**:
```solidity
taskManager.completeTask(1);
```
- **Analogia**: **"Pisar no freio"** (completar a tarefa)

**ğŸ“Š VerificaÃ§Ã£o Final**:
```solidity
uint256 balanceAfter = user1.balance;
assertEq(balanceAfter, balanceBefore + stake);
```
- **Analogia**: **"Confirmar que o carro parou"** (dinheiro voltou)
- Se o dinheiro nÃ£o voltou = "freios falharam"

**O que este teste garante**:
- âœ… O "sistema de freios" (conclusÃ£o) funciona
- âœ… O "airbag" (devoluÃ§Ã£o de dinheiro) ativa corretamente
- âœ… A "frenagem" acontece no tempo certo

#### ğŸ“‹ **Teste 3: testGetMyTasks() - "Teste do GPS"**

```solidity
function testGetMyTasks() public {
    // Cria 3 tarefas
    taskManager.createTask{value: stake}("Tarefa 1", description, deadline);
    taskManager.createTask{value: stake}("Tarefa 2", description, deadline);
    taskManager.createTask{value: stake}("Tarefa 3", description, deadline);
    
    // Verifica se a lista estÃ¡ correta
    uint256[] memory myTasks = taskManager.getMyTasks();
    assertEq(myTasks.length, 3);
    assertEq(myTasks[0], 1);  // Primeira tarefa tem ID 1
}
```

**Analogia**: Como **testar se o GPS funciona**:

**ğŸ—ºï¸ CriaÃ§Ã£o do Percurso**:
```solidity
taskManager.createTask{value: stake}("Tarefa 1", description, deadline);
taskManager.createTask{value: stake}("Tarefa 2", description, deadline);
taskManager.createTask{value: stake}("Tarefa 3", description, deadline);
```
- **Analogia**: **"Programar 3 destinos no GPS"**: Casa â†’ Trabalho â†’ Shopping

**ğŸ“± Consulta do GPS**:
```solidity
uint256[] memory myTasks = taskManager.getMyTasks();
```
- **Analogia**: **"Perguntar ao GPS: onde estÃ£o meus destinos?"**

**ğŸ” VerificaÃ§Ã£o da Lista**:
```solidity
assertEq(myTasks.length, 3);
assertEq(myTasks[0], 1);
```
- **Analogia**: **"Conferir se o GPS lembra dos 3 destinos"**
- **"Confirmar que o primeiro destino Ã© o nÃºmero 1"**

**O que este teste garante**:
- âœ… O "GPS" (funÃ§Ã£o de listar) funciona
- âœ… A "memÃ³ria" (storage) guarda tudo corretamente
- âœ… A "ordem" dos destinos estÃ¡ certa

#### ğŸ¯ **Por que Fazer Estes Testes?**

**Analogia**: Como **testar um carro antes de vender**:

- **ğŸ›¡ï¸ SeguranÃ§a**: Evita que o "carro exploda" (bugs que perdem dinheiro)
- **ğŸ”„ ConfianÃ§a**: Se vocÃª mudar o "motor" (cÃ³digo), testa se ainda funciona
- **ğŸ“Š Cobertura**: Testa "subida", "descida", "chuva", "sol" (diferentes cenÃ¡rios)  
- **âš¡ Rapidez**: Encontra problemas no "laboratÃ³rio", nÃ£o na "estrada" (produÃ§Ã£o)
- **ğŸ’° Economia**: Ã‰ mais barato consertar no laboratÃ³rio que pagar indenizaÃ§Ã£o

**ğŸš¨ Sem testes Ã© como**:
- Vender carro sem testar freios
- LanÃ§ar remÃ©dio sem testar efeitos
- Construir prÃ©dio sem testar fundaÃ§Ã£o

**âœ… Com testes Ã© como**:
- Certificado de qualidade
- Seguro total
- Garantia que funciona

#### ğŸ¯ **Dicas de Testes Adicionais - "Expandindo o LaboratÃ³rio"**

Nosso contrato atual tem 3 testes bÃ¡sicos, mas poderÃ­amos **"testar muito mais"**! Aqui estÃ£o ideias de **testes que vocÃª pode implementar**:

#### ğŸ›¡ï¸ **Testes de SeguranÃ§a - "Teste de InvasÃ£o"**

**Analogia**: Como **testar a seguranÃ§a de um banco** - tentar todas as formas de roubar!

**1. Teste de AutorizaÃ§Ã£o:**
```solidity
function testOnlyOwnerCanComplete() public {
    // UsuÃ¡rio 1 cria tarefa
    // UsuÃ¡rio 2 tenta completar tarefa do usuÃ¡rio 1
    // Deve FALHAR
}
```
- **O que testa**: Se alguÃ©m pode completar tarefa de outra pessoa
- **Analogia**: Como testar se **vizinho pode sacar na sua conta**

**2. Teste de Double Spending:**
```solidity
function testCannotCompleteTaskTwice() public {
    // Criar tarefa
    // Completar uma vez (sucesso)
    // Tentar completar segunda vez (deve falhar)
}
```
- **O que testa**: Se Ã© possÃ­vel receber dinheiro duas vezes
- **Analogia**: Como testar se dÃ¡ para **sacar o prÃªmio duas vezes**

**3. Teste de Overflow/Underflow:**
```solidity
function testMassiveTaskCreation() public {
    // Criar 1000+ tarefas
    // Verificar se totalTasks nÃ£o "quebra"
}
```
- **O que testa**: Se o contador aguenta nÃºmeros gigantes
- **Analogia**: Como testar se **odÃ´metro nÃ£o volta ao zero** quando chega ao limite

#### â° **Testes de Tempo - "Teste da MÃ¡quina do Tempo"**

**Analogia**: Como **testar diferentes cenÃ¡rios temporais** numa corrida!

**1. Teste de Tarefa Atrasada:**
```solidity
function testLateTaskCompletion() public {
    // Criar tarefa com prazo de 1 dia
    // AvanÃ§ar tempo para 2 dias (vm.warp)
    // Completar tarefa
    // Verificar se stake foi perdido (nÃ£o devolvido)
}
```
- **O que testa**: Se stake Ã© realmente perdido quando atrasado
- **Analogia**: **Chegar atrasado na corrida** e perder a aposta

**2. Teste de VerificaÃ§Ã£o de Atraso:**
```solidity
function testIsTaskOverdueLogic() public {
    // Criar tarefa
    // Verificar que nÃ£o estÃ¡ atrasada
    // AvanÃ§ar tempo apÃ³s prazo
    // Verificar que estÃ¡ atrasada
    // Completar tarefa
    // Verificar que nÃ£o estÃ¡ mais "atrasada" (foi concluÃ­da)
}
```
- **O que testa**: Se a lÃ³gica de "atrasado" funciona corretamente
- **Analogia**: **CronÃ´metro da corrida** estÃ¡ funcionando direito

#### ğŸ’° **Testes Financeiros - "Teste do Cofre"**

**Analogia**: Como **testar todos os cenÃ¡rios de dinheiro** num cassino!

**1. Teste de Stake Insuficiente:**
```solidity
function testInsufficientStake() public {
    // Tentar criar tarefa com 0.0001 ether (menos que mÃ­nimo)
    // Deve FALHAR
}
```
- **O que testa**: Se valores baixos sÃ£o rejeitados
- **Analogia**: **Tentar apostar centavos** numa mesa que exige reais

**2. Teste de Stake Exato:**
```solidity
function testExactMinimumStake() public {
    // Criar tarefa com exatamente 0.001 ether
    // Deve FUNCIONAR
}
```
- **O que testa**: Se o valor mÃ­nimo exato Ã© aceito
- **Analogia**: **Apostar exatamente o mÃ­nimo** permitido

**3. Teste de Stakes Diferentes:**
```solidity
function testDifferentStakeAmounts() public {
    // Criar tarefas com 0.001, 0.01, 0.1, 1 ether
    // Completar todas no prazo
    // Verificar se cada um recebeu o valor correto de volta
}
```
- **O que testa**: Se valores diferentes sÃ£o manuseados corretamente
- **Analogia**: **Apostas de valores diferentes** na mesma corrida

#### ğŸ“Š **Testes de Estado - "Teste do InventÃ¡rio"**

**Analogia**: Como **conferir se o estoque** da loja estÃ¡ correto!

**1. Teste de Contador Global:**
```solidity
function testTotalTasksIncrement() public {
    uint256 initialCount = taskManager.totalTasks();
    
    // Criar 3 tarefas
    // Verificar se totalTasks aumentou em 3
    
    assertEq(taskManager.totalTasks(), initialCount + 3);
}
```
- **O que testa**: Se o contador global estÃ¡ certo
- **Analogia**: **Conferir se o caixa** registrou todas as vendas

**2. Teste de Lista de UsuÃ¡rio:**
```solidity
function testUserTasksList() public {
    // UsuÃ¡rio A cria 2 tarefas
    // UsuÃ¡rio B cria 3 tarefas
    // Verificar se cada um tem a quantidade correta na sua lista
    // Verificar se as listas nÃ£o se misturam
}
```
- **O que testa**: Se cada usuÃ¡rio vÃª apenas suas tarefas
- **Analogia**: **Cada cliente sÃ³ vÃª seus prÃ³prios pedidos**

#### ğŸ² **Testes de Casos Extremos - "Teste do ImpossÃ­vel"**

**Analogia**: Como **testar situaÃ§Ãµes malucas** que provavelmente nunca vÃ£o acontecer!

**1. Teste de Deadline no Futuro Distante:**
```solidity
function testFarFutureDeadline() public {
    // Criar tarefa com deadline em 100 anos
    // Deve funcionar normalmente
}
```
- **O que testa**: Se o contrato aguenta datas muito futuras
- **Analogia**: **Apostar numa corrida de 2124**

**2. Teste de String Vazia:**
```solidity
function testEmptyTaskTitle() public {
    // Tentar criar tarefa com tÃ­tulo vazio ""
    // Pode aceitar ou rejeitar (depende da regra)
}
```
- **O que testa**: Como o contrato lida com dados vazios
- **Analogia**: **Apostar sem dar nome ao cavalo**

**3. Teste de String Gigante:**
```solidity
function testMassiveTaskDescription() public {
    // Criar tarefa com descriÃ§Ã£o de 10.000 caracteres
    // Verificar custo de gas e funcionamento
}
```
- **O que testa**: Se textos enormes causam problemas
- **Analogia**: **Escrever uma redaÃ§Ã£o de 50 pÃ¡ginas** como descriÃ§Ã£o

#### ğŸ† **Testes de Performance - "Teste de Velocidade"**

**Analogia**: Como **testar se o carro aguenta** FÃ³rmula 1!

**1. Teste de Gas Cost:**
```solidity
function testGasCosts() public {
    // Medir gas de createTask
    // Medir gas de completeTask
    // Verificar se estÃ¡ dentro de limites aceitÃ¡veis
}
```
- **O que testa**: Quanto "combustÃ­vel" cada funÃ§Ã£o gasta
- **Analogia**: **Testar consumo** de cada carro

**2. Teste de Stress:**
```solidity
function testStressTest() public {
    // Criar 100 tarefas em sequÃªncia
    // Completar todas
    // Verificar se tudo ainda funciona
}
```
- **O que testa**: Se o contrato aguenta uso intenso
- **Analogia**: **Dirigir 1000km** sem parar para ver se quebra

#### ğŸ’¡ **Como Implementar Estes Testes**

**1. ğŸ“ Organizar por Categoria:**
```
test/
â”œâ”€â”€ TestSecurity.t.sol     # Testes de seguranÃ§a
â”œâ”€â”€ TestTiming.t.sol       # Testes de tempo
â”œâ”€â”€ TestFinancial.t.sol    # Testes financeiros
â”œâ”€â”€ TestState.t.sol        # Testes de estado
â””â”€â”€ TestEdgeCases.t.sol    # Casos extremos
```

**2. ğŸ¯ Usar Foundry Features:**
```solidity
// Testar com fuzzing (dados aleatÃ³rios)
function testFuzzCreateTask(string memory title, uint256 deadline) public {
    vm.assume(deadline > block.timestamp);
    // Foundry vai testar com centenas de valores aleatÃ³rios
}

// Testar invariants (regras que nunca devem quebrar)
function invariant_totalTasksNeverDecrease() public {
    // Esta regra deve ser sempre verdadeira
    assert(taskManager.totalTasks() >= previousTotalTasks);
}
```

**3. ğŸš¨ Usar vm Commands:**
```solidity
vm.warp(timestamp);        // Viajar no tempo
vm.deal(user, amount);     // Dar dinheiro fake
vm.expectRevert("error");  // Esperar que falhe
vm.startPrank(user);       // Simular outro usuÃ¡rio
```

**ğŸ¯ Meta**: Com estes testes, seu contrato fica **blindado** como Fort Knox! ğŸ°

### ğŸš€ Script de Deploy (DeployTaskManager.s.sol)

O script de deploy Ã© como um **"manual de instalaÃ§Ã£o"** do nosso contrato na blockchain:

#### ğŸ—ï¸ **Estrutura do Script de Deploy**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Script.sol";
import "../src/TaskManager.sol";

contract DeployTaskManager is Script {
    function setUp() public {}

    function run() public {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        vm.startBroadcast(deployerPrivateKey);

        TaskManager taskManager = new TaskManager();
        
        console.log("TaskManager deployed at:", address(taskManager));
        console.log("Deployer address:", vm.addr(deployerPrivateKey));
        console.log("Minimum stake required:", taskManager.MINIMUM_STAKE());

        vm.stopBroadcast();
    }
}
```

**Analogia**: Como **abrir uma nova loja fÃ­sica**:

#### ğŸ“‹ **PreparaÃ§Ã£o (Imports)**
```solidity
import "forge-std/Script.sol";
import "../src/TaskManager.sol";
```
- **Analogia**: Como **reunir todas as ferramentas** necessÃ¡rias antes de construir
- `Script.sol` = "Kit de ferramentas para construÃ§Ã£o"
- `TaskManager.sol` = "Planta da loja que vamos construir"

#### ğŸ”‘ **AutenticaÃ§Ã£o (Private Key)**
```solidity
uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
```
- **Analogia**: Como **pegar a chave do proprietÃ¡rio** para autorizar a construÃ§Ã£o
- `PRIVATE_KEY` = Sua "chave secreta" (como a senha do banco)
- `vm.envUint()` = Pega a chave de um arquivo seguro (variÃ¡vel de ambiente)

#### ğŸ“¢ **InÃ­cio da ConstruÃ§Ã£o (startBroadcast)**
```solidity
vm.startBroadcast(deployerPrivateKey);
```
- **Analogia**: Como **avisar a prefeitura**: "Vou comeÃ§ar a construir agora!"
- A partir daqui, tudo que vocÃª fizer **custa dinheiro real** (gas)
- Ã‰ como ligar um **"taxÃ­metro"** da blockchain

#### ğŸ­ **ConstruÃ§Ã£o da Loja (new TaskManager)**
```solidity
TaskManager taskManager = new TaskManager();
```
- **Analogia**: Como **construir fisicamente a loja**
- `new TaskManager()` = "Erguer um prÃ©dio novo do zero"
- A partir daqui, sua loja existe **para sempre** na blockchain

#### ğŸ“ **RelatÃ³rio de ConclusÃ£o (console.log)**
```solidity
console.log("TaskManager deployed at:", address(taskManager));
console.log("Deployer address:", vm.addr(deployerPrivateKey));
console.log("Minimum stake required:", taskManager.MINIMUM_STAKE());
```
- **Analogia**: Como **entregar a certidÃ£o de conclusÃ£o da obra**:
  - "Loja construÃ­da no endereÃ§o: Rua A, nÂº 123"
  - "ProprietÃ¡rio: JoÃ£o Silva (CPF: 123.456.789-00)"
  - "Taxa de entrada: R$ 5,00"

#### ğŸ›‘ **Fim da ConstruÃ§Ã£o (stopBroadcast)**
```solidity
vm.stopBroadcast();
```
- **Analogia**: Como **desligar o taxÃ­metro** e avisar: "Obra concluÃ­da!"
- A partir daqui, nÃ£o gastamos mais gas

#### ğŸ¯ **Por que usar Script de Deploy?**

- **ğŸ”„ RepetÃ­vel**: Pode rodar vÃ¡rias vezes (testnet, mainnet, etc.)
- **ğŸ“ Documentado**: Fica registrado exatamente como o contrato foi criado
- **ğŸ›¡ï¸ Seguro**: Usa variÃ¡veis de ambiente para proteger chaves privadas
- **ğŸ“Š Informativo**: Mostra endereÃ§os e informaÃ§Ãµes importantes
- **âš¡ Automatizado**: Um comando sÃ³ faz tudo

**Comando para usar**:
```bash
forge script script/TaskManager.s.sol:TaskManagerScript --rpc-url <REDE> --private-key <SUA_CHAVE> --broadcast
```

**ğŸ¯ Importante**: Note que o script se chama `TaskManager.s.sol` e a classe Ã© `TaskManagerScript`. Este Ã© o comando correto baseado na estrutura real do projeto.

**Analogia**: Como usar um **"app de construÃ§Ã£o"** que faz tudo automaticamente!

### ğŸŒ Deploy Manual na Rede Sepolia - "Construindo na Cidade Real"

Agora vamos aprender a **"construir nossa loja"** numa cidade real (rede de teste), nÃ£o apenas no terreno de treino (rede local).

#### ğŸ¢ **Entendendo os Provedores - "Companhias TelefÃ´nicas da Blockchain"**

**Analogia**: Como **empresas de telecomunicaÃ§Ãµes** que conectam vocÃª Ã  internet.

**ğŸ¤” Por que precisamos de provedores?**

Imagine que vocÃª quer **ligar para alguÃ©m** numa cidade distante:
- VocÃª nÃ£o pode ir fisicamente atÃ© lÃ¡
- Precisa de uma **"empresa telefÃ´nica"** para fazer a conexÃ£o
- A empresa tem **torres e cabos** que conectam as cidades

**Na blockchain Ã© igual**:
- Sua aplicaÃ§Ã£o local nÃ£o consegue "falar" diretamente com Ethereum
- Precisa de um **"provedor RPC"** para fazer a conexÃ£o
- O provedor tem **servidores e nÃ³s** que conectam vocÃª Ã  rede

#### ğŸ“¡ **Infura - A "Operadora Premium"**

**Infura** Ã© como a **"Vivo/Claro da blockchain"** - uma empresa que oferece conexÃ£o profissional.

**ğŸ”— Outros provedores similares:**
- **Alchemy** (concorrente principal)
- **QuickNode** 
- **Moralis**
- **GetBlock**

**Analogia**: Como **operadoras de celular** - todas fazem a mesma coisa (conectar), mas com preÃ§os e qualidades diferentes.

#### ğŸ—ï¸ **Obtendo API Key da Infura - "Seu CartÃ£o de Acesso"**

**Passo a passo para pegar sua "linha telefÃ´nica":**

**1. ğŸ“ Criar Conta na Infura:**
- Acesse: https://infura.io/
- Clique em **"Sign Up"** (criar conta)
- Use um email vÃ¡lido (vocÃª receberÃ¡ confirmaÃ§Ã£o)

**Analogia**: Como **"contratar um plano de celular"** numa operadora.

**2. âœ… Confirmar Email:**
- VÃ¡ ao seu email
- Clique no link de confirmaÃ§Ã£o
- FaÃ§a login na Infura

**3. ğŸ¯ Criar um Projeto:**
- No painel, clique **"Create New Key"**
- **Name**: "TaskManager Project" (ou qualquer nome)
- **Network**: **"Web3 API"** (nÃ£o Ethereum 2.0)
- Clique **"Create"**

**Analogia**: Como **"registrar um novo nÃºmero"** na operadora.

**4. ğŸ“‹ Copiar as URLs:**

ApÃ³s criar, vocÃª verÃ¡ algo assim:
```
PROJECT ID: 9aa3d95b3bc440fa88ea12eaa4456161

ENDPOINTS:
Mainnet: https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161
Sepolia: https://sepolia.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161
```

**ğŸ¯ Importante**: Copie a URL da **Sepolia** - Ã© ela que vamos usar!

**Analogia**: Como **"pegar seu nÃºmero de telefone"** depois de contratar o plano.

#### ğŸ” **Etherscan - O "Google da Blockchain"**

**Etherscan** Ã© como o **"Google"** da blockchain Ethereum - vocÃª pode pesquisar qualquer coisa.

**ğŸŒ Links importantes:**
- **Mainnet**: https://etherscan.io/ (rede principal)
- **Sepolia**: https://sepolia.etherscan.io/ (rede de teste)

**O que vocÃª pode fazer no Etherscan:**
- ğŸ” **Pesquisar transaÃ§Ãµes** (como rastrear encomenda dos Correios)
- ğŸ‘€ **Ver contratos** deployados (como ver lojas numa rua)
- ğŸ’° **Verificar saldos** (como extrato bancÃ¡rio)
- â›½ **Monitorar gas** (como preÃ§o da gasolina)

#### ğŸ”‘ **Configurando API Key do Etherscan**

**Por que precisamos?**
- Para **verificar contratos** automaticamente
- Como ter **"acesso VIP"** ao Google da blockchain

**Passo a passo:**

**1. ğŸ“ Criar Conta no Etherscan:**
- Acesse: https://etherscan.io/
- Clique **"Sign In"** â†’ **"Click to sign up"**
- Registre-se com email

**2. ğŸ—ï¸ Gerar API Key:**
- FaÃ§a login
- VÃ¡ em **"API Keys"** (no menu do usuÃ¡rio)
- Clique **"Add"** 
- **App Name**: "TaskManager"
- Copie a **API Key** gerada

**Exemplo da API Key:**
```
YourApiKeyToken: ABC123DEF456GHI789JKL012MNO345PQR678
```

**Analogia**: Como **"pegar cartÃ£o VIP"** para ter acesso especial ao shopping.

#### ğŸ¦Š **MetaMask - Sua "Carteira Digital"**

**MetaMask** Ã© como sua **"carteira fÃ­sica"**, mas para criptomoedas.

#### ğŸ“¥ **Instalando MetaMask:**

**1. ğŸ’» Instalar ExtensÃ£o:**
- Acesse: https://metamask.io/
- Clique **"Download"**
- Adicione ao Chrome/Firefox/Safari

**2. ğŸ†• Criar Carteira Nova:**
- Abra a extensÃ£o
- **"Create a new wallet"**
- Criar senha forte
- **âš ï¸ ANOTAR AS 12 PALAVRAS** (seed phrase) num papel

**Analogia**: As 12 palavras sÃ£o como **"chave mestre do cofre"** - se perder, perde tudo!

#### ğŸŒ **Configurando Rede Sepolia:**

**Sepolia jÃ¡ vem configurada** no MetaMask moderno, mas se nÃ£o estiver:

```
Network Name: Sepolia test network
New RPC URL: https://sepolia.infura.io/v3/SEU_PROJECT_ID
Chain ID: 11155111
Currency Symbol: ETH
Block Explorer: https://sepolia.etherscan.io
```

#### ğŸ’° **Conseguindo Ethereum de Teste (Sepolia ETH):**

**Analogia**: Como **"dinheiro de Monopoly"** - vale apenas no jogo (rede de teste).

**Faucets (torneiras) gratuitas:**
1. **Sepolia Faucet**: https://sepoliafaucet.com/
2. **Alchemy Faucet**: https://sepoliafaucet.com/
3. **Infura Faucet**: https://www.infura.io/faucet

**Como usar:**
- Copie seu endereÃ§o MetaMask
- Cole no faucet
- Aguarde 1-2 minutos
- Receba ~0.5 ETH de teste

#### ğŸ” **Obtendo Chave Privada - "Senha do Cofre"**

**âš ï¸ ATENÃ‡ÃƒO EXTREMA**: Chave privada Ã© como **"senha do banco"** - NUNCA compartilhe!

**Passo a passo no MetaMask:**

**1. ğŸ¦Š Abrir MetaMask:**
- Clique na extensÃ£o
- FaÃ§a login

**2. âš™ï¸ Acessar ConfiguraÃ§Ãµes:**
- Clique nos **3 pontinhos** (menu)
- **"Account Details"**

**3. ğŸ”‘ Exportar Chave:**
- **"Show private key"**
- Digite sua **senha do MetaMask**
- **Copie a chave privada**

**Exemplo de chave privada:**
```
0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
```

**ğŸš¨ SEGURANÃ‡A MÃXIMA**:
- âŒ **NUNCA** cole em sites duvidosos
- âŒ **NUNCA** compartilhe com ninguÃ©m
- âŒ **NUNCA** commit no Git
- âœ… Use apenas para deploy local/teste
- âœ… Crie uma carteira separada sÃ³ para desenvolvimento

#### ğŸš€ **Deploy Manual na Sepolia - Passo a Passo**

Agora vamos **"construir nossa loja"** na cidade real!

#### ğŸ› ï¸ **PreparaÃ§Ã£o do Ambiente:**

**1. ğŸ“ Criar arquivo .env:**

Na pasta do projeto, crie `.env`:
```bash
# .env (NUNCA commit este arquivo!)
PRIVATE_KEY=0xSUA_CHAVE_PRIVADA_AQUI
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/SEU_PROJECT_ID
ETHERSCAN_API_KEY=SUA_API_KEY_DO_ETHERSCAN
```

**2. ğŸ”’ Proteger .env:**

Adicione no `.gitignore`:
```
.env
```

**Analogia**: Como **"trancar o cofre"** onde vocÃª guarda senhas.

#### ğŸ—ï¸ **Executando o Deploy:**

**ğŸ”§ PrÃ©-requisito IMPORTANTE: Carregar VariÃ¡veis de Ambiente**

Antes de executar o comando de deploy, vocÃª **DEVE** carregar as variÃ¡veis do arquivo `.env`:

```bash
# ğŸ”‘ PRIMEIRO: Carregar as variÃ¡veis de ambiente
source .env

# âœ… Verificar se as variÃ¡veis foram carregadas
echo "RPC: $SEPOLIA_RPC_URL"
echo "Private Key configurada: $([ -n "$PRIVATE_KEY" ] && echo "âœ… SIM" || echo "âŒ NÃƒO")"
echo "Etherscan API: $([ -n "$ETHERSCAN_API_KEY" ] && echo "âœ… SIM" || echo "âŒ NÃƒO")"
```

**ğŸ’¡ Por que isso Ã© necessÃ¡rio?**
- O comando usa variÃ¡veis como `$SEPOLIA_RPC_URL`, `$PRIVATE_KEY`, `$ETHERSCAN_API_KEY`
- Sem o `source .env`, essas variÃ¡veis ficam vazias e o comando falha
- Ã‰ como **"logar no sistema"** antes de usar seus dados

**ğŸ“‹ Exemplo Visual:**

```bash
# âŒ SEM carregar .env - FALHA!
forge script script/TaskManager.s.sol:TaskManagerScript --rpc-url $SEPOLIA_RPC_URL
# Resultado: --rpc-url ""  (vazio!)

# âœ… COM source .env - FUNCIONA!
source .env
forge script script/TaskManager.s.sol:TaskManagerScript --rpc-url $SEPOLIA_RPC_URL  
# Resultado: --rpc-url "https://sepolia.infura.io/v3/1b375955f267496abf270f2423801349"
```

**ğŸ” Como as variÃ¡veis sÃ£o substituÃ­das:**
- `$SEPOLIA_RPC_URL` â†’ `https://sepolia.infura.io/v3/SEU_PROJECT_ID`
- `$PRIVATE_KEY` â†’ `0x1234567890abcdef...` (sua chave privada)
- `$ETHERSCAN_API_KEY` â†’ `ABC123DEF456...` (sua API key)

**1. ğŸ’» Comando de Deploy:**

```bash
# OpÃ§Ã£o A: Carregar variÃ¡veis E executar deploy em um comando
source .env && forge script script/TaskManager.s.sol:TaskManagerScript \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  --verify \
  --etherscan-api-key $ETHERSCAN_API_KEY \
  -vvvv

# OpÃ§Ã£o B: Carregar variÃ¡veis primeiro, depois executar
source .env
forge script script/TaskManager.s.sol:TaskManagerScript \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  --verify \
  --etherscan-api-key $ETHERSCAN_API_KEY \
  -vvvv
```

**âœ… Este Ã© o comando testado e funcionando!** Note que usamos `TaskManager.s.sol:TaskManagerScript` (nÃ£o `DeployTaskManager.s.sol`).

**Quebrado em partes:**
- `forge script` = Executar script de deploy
- `--rpc-url` = Conectar via Infura na Sepolia
- `--private-key` = Usar sua carteira para pagar gas
- `--broadcast` = Realmente enviar para blockchain
- `--verify` = Publicar cÃ³digo no Etherscan
- `-vvvv` = Mostrar TUDO que estÃ¡ acontecendo

**2. ğŸ’¸ O que acontece:**

```
[â ¢] Compiling...
[âœ…] Compilation completed successfully.

== Logs ==
TaskManager deployed at: 0x742d35Cc6636C0532925a3b8D8C9a76C4577F6B5
Deployer address: 0xYourAddress
Minimum stake required: 1000000000000000

## Setting up 1 EVM.
##
## Environment
Chain: sepolia

## Sender
Address: 0xYourAddress
Balance: 0.123456789 ETH

âœ… Transaction sent! Hash: 0xabc123...
â³ Waiting for confirmation...
âœ… Transaction confirmed!
â›½ Gas used: 1,234,567
ğŸ’° Gas cost: 0.001234 ETH
```

**3. ğŸ” VerificaÃ§Ã£o no Etherscan:**

- Acesse: https://sepolia.etherscan.io/
- Cole o endereÃ§o do contrato
- Veja seu contrato deployado!

#### ğŸ¯ **Testando o Contrato Deployado:**

**1. ğŸ“ Consultar dados (grÃ¡tis):**

```bash
# Ver total de tarefas
cast call 0xSEU_CONTRATO_ADDRESS "totalTasks()" --rpc-url $SEPOLIA_RPC_URL

# Ver stake mÃ­nimo
cast call 0xSEU_CONTRATO_ADDRESS "MINIMUM_STAKE()" --rpc-url $SEPOLIA_RPC_URL
```

**2. ğŸ“ Criar tarefa (custa gas):**

```bash
cast send 0xSEU_CONTRATO_ADDRESS \
  "createTask(string,string,uint256)" \
  "Estudar Solidity" \
  "Completar tutorial completo" \
  1703980800 \
  --value 0.001ether \
  --private-key $PRIVATE_KEY \
  --rpc-url $SEPOLIA_RPC_URL
```

#### ğŸ‰ **ParabÃ©ns! Seu Contrato estÃ¡ Vivo!**

**ğŸŒ Links Ãºteis apÃ³s deploy:**
- **Contrato**: https://sepolia.etherscan.io/address/SEU_ENDEREÃ‡O
- **CÃ³digo Verificado**: Aba "Contract" â†’ "Read Contract"
- **TransaÃ§Ãµes**: Aba "Txns" mostra todas as interaÃ§Ãµes

**Analogia**: Como **"inaugurar sua loja"** numa rua movimentada - agora todo mundo pode visitÃ¡-la!

#### ğŸš¨ **Troubleshooting - Problemas Comuns**

**Erro: "No such file or directory: script/DeployTaskManager.s.sol"**
- **âŒ Problema**: Script nÃ£o existe com esse nome
- **âœ… SoluÃ§Ã£o**: Use `script/TaskManager.s.sol:TaskManagerScript`

**Erro: "a value is required for '--fork-url' but none was supplied"**
- **âŒ Problema**: Comando quebrado em mÃºltiplas linhas
- **âœ… SoluÃ§Ã£o**: Execute o comando completo em uma linha ou use `\` para quebra

**ğŸš¨ Erro: VariÃ¡veis vazias ou "Invalid RPC URL"**
- **âŒ Problema**: NÃ£o carregou o arquivo `.env` antes do comando
- **âœ… SoluÃ§Ã£o**: SEMPRE execute `source .env` primeiro
- **ğŸ” Como verificar**: `echo $SEPOLIA_RPC_URL` deve mostrar a URL completa

**ğŸš¨ Erro: "insufficient funds for gas * price + value"**
- **âŒ Problema**: Carteira sem ETH suficiente para pagar gas
- **âœ… SoluÃ§Ã£o**: Pegue ETH de teste no faucet Sepolia

**ğŸ“‹ Checklist antes do deploy:**
```bash
# 1. Verificar se estÃ¡ na pasta smartcontract
pwd  # Deve mostrar: .../fb02/smartcontract

# 2. Verificar se arquivo .env existe
ls -la .env

# 3. Carregar variÃ¡veis
source .env

# 4. Verificar se variÃ¡veis estÃ£o carregadas
echo "âœ… RPC: $SEPOLIA_RPC_URL"
echo "âœ… Private Key: $([ -n "$PRIVATE_KEY" ] && echo "configurada" || echo "âŒ VAZIA")"
echo "âœ… Etherscan API: $([ -n "$ETHERSCAN_API_KEY" ] && echo "configurada" || echo "âŒ VAZIA")"
```

**Comando COMPLETO que FUNCIONA:**
```bash
source .env && forge script script/TaskManager.s.sol:TaskManagerScript --rpc-url $SEPOLIA_RPC_URL --private-key $PRIVATE_KEY --broadcast --verify --etherscan-api-key $ETHERSCAN_API_KEY -vvvv
```

**ğŸ¯ PrÃ³ximos passos:**
- Criar interface front-end
- Conectar MetaMask ao seu site
- Permitir que usuÃ¡rios interajam visualmente

---

## ğŸ Bonus - Prompt do Contrato

Para referÃªncia e estudo, aqui estÃ¡ o **prompt original** usado para criar o contrato TaskManager:

```
Crie um contrato inteligente em Solidity chamado "TaskManager" que permita aos usuÃ¡rios criar, gerenciar e concluir tarefas associadas a prazos e valores apostados (stakes). O contrato deve atender aos seguintes requisitos:

Estrutura de Dados

Armazenar informaÃ§Ãµes de cada tarefa, incluindo:

Um identificador Ãºnico para cada tarefa.

Um tÃ­tulo descritivo.

Uma descriÃ§Ã£o detalhada.

A data de criaÃ§Ã£o da tarefa.

Um prazo para conclusÃ£o (data futura).

O status atual da tarefa (pendente ou concluÃ­da).

O endereÃ§o do criador da tarefa.

O valor apostado (stake) associado Ã  tarefa.

Um indicador que mostre se o valor apostado jÃ¡ foi processado.

Funcionalidades Principais

Permitir que usuÃ¡rios criem novas tarefas fornecendo:

Um tÃ­tulo, uma descriÃ§Ã£o e um prazo (que deve ser uma data futura).

Um valor apostado mÃ­nimo de 0.001 ether, enviado junto com a criaÃ§Ã£o.

Restringir a conclusÃ£o de tarefas apenas ao criador da tarefa.

Processar o valor apostado da seguinte forma:

Devolver o valor ao criador se a tarefa for concluÃ­da antes do prazo.

Considerar o valor perdido se o prazo expirar sem conclusÃ£o.

Oferecer uma maneira de os usuÃ¡rios consultarem todas as tarefas que eles prÃ³prios criaram.

Possibilitar a verificaÃ§Ã£o se uma tarefa estÃ¡ atrasada com base no prazo e no tempo atual.

Disponibilizar informaÃ§Ãµes gerais, como:

O nÃºmero total de tarefas criadas no contrato.

O saldo total de ether atualmente armazenado no contrato.

NotificaÃ§Ãµes

Gerar notificaÃ§Ãµes pÃºblicas (eventos) nos seguintes casos:

Quando uma nova tarefa Ã© criada.

Quando uma tarefa Ã© concluÃ­da.

Quando o valor apostado Ã© perdido devido ao atraso.

SeguranÃ§a

Garantir que as transferÃªncias de ether sejam feitas de forma segura, verificando se foram concluÃ­das com sucesso.

EspecificaÃ§Ãµes TÃ©cnicas

Utilizar a versÃ£o 0.8.13 do Solidity.

Incluir a licenÃ§a MIT no inÃ­cio do cÃ³digo.

Usar estruturas de mapeamento para organizar as tarefas e associÃ¡-las aos respectivos criadores.

Fornecer uma forma de consultar os detalhes completos de uma tarefa especÃ­fica.

Incluir uma maneira de determinar se uma tarefa estÃ¡ atrasada em relaÃ§Ã£o ao prazo.

Permitir consulta ao nÃºmero total de tarefas criadas e ao saldo atual do contrato.
```

**ğŸ’¡ Dica**: Este prompt pode servir como **base** para criar outros contratos similares ou para **estudar** como traduzir requisitos em cÃ³digo Solidity!

---

### ğŸ“Œ **AtualizaÃ§Ã£o: Deploy Corrigido**

**âœ… Deploy Funcional**: O comando de deploy foi corrigido e testado com sucesso!
- **Contrato**: TaskManager deployado em: `0xb17d39826a1b83f7685de1ebc924b3185b677383`
- **Rede**: Sepolia Testnet
- **Hash**: `0x317b05ffccb85fad4a670cdee712c2f908322101767e78b4ad809e4b0fe8d10e`
- **Verificado**: âœ… CÃ³digo verificado no Etherscan

**ğŸ”— Ver contrato**: [https://sepolia.etherscan.io/address/0xb17d39826a1b83f7685de1ebc924b3185b677383](https://sepolia.etherscan.io/address/0xb17d39826a1b83f7685de1ebc924b3185b677383)

#### ğŸ”‘ **LEMBRE-SE: Sempre Carregar VariÃ¡veis de Ambiente!**

**âš ï¸ ERRO MAIS COMUM**: Esquecer de executar `source .env` antes do deploy.

**âœ… PROCESSO CORRETO:**
1. `cd smartcontract` (entrar na pasta do smart contract)
2. `source .env` (carregar variÃ¡veis)
3. Executar comando de deploy
4. âœ¨ Deploy funciona perfeitamente!

**ğŸ’¡ Dica**: Sempre que abrir um novo terminal, execute `source .env` novamente, pois as variÃ¡veis sÃ³ ficam carregadas na sessÃ£o atual do terminal.

---

## ğŸ¯ Aula 3 - IntegraÃ§Ã£o Frontend com Smart Contract

### ğŸŒ‰ **Construindo a Ponte entre Seu Site e a Blockchain**

**Analogia**: Imagine que vocÃª tem um **restaurante fÃ­sico** (smart contract) e quer criar um **aplicativo de delivery** (frontend). VocÃª precisa de uma **"ponte"** para conectar os dois mundos!

**ğŸ”— O que vamos fazer nesta aula:**
- Conectar nosso site Next.js com o smart contract deployado
- Usar **wagmi** e **viem** para fazer essa conexÃ£o
- Criar hooks customizados para organizar a lÃ³gica Web3
- Configurar providers e implementar a interface
- Fazer tudo funcionar **sem complicaÃ§Ã£o**

#### ğŸ§© **As PeÃ§as do Quebra-CabeÃ§a**

Antes de comeÃ§ar, vamos entender **o que cada ferramenta faz**:

```
ğŸ  Seu Site (Next.js)     ğŸŒ‰ Ponte (wagmi + viem)     ğŸª Smart Contract (Blockchain)
     â”‚                           â”‚                           â”‚
     â”‚ "Quero criar tarefa"       â”‚                           â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Traduz para blockchain   â”‚
     â”‚                           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Executa createTask()
     â”‚                           â”‚                           â”‚
     â”‚ "Mostrar minhas tarefas"   â”‚                           â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Consulta dados           â”‚
     â”‚                           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Retorna lista [1,2,3]
     â”‚                           â”‚                           â”‚
     â”‚ Exibe na interface âœ¨      â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                           â”‚
```

### ğŸ“š **Entendendo Wagmi e Viem - Os "Tradutores MÃ¡gicos"**

#### ğŸ£ **Wagmi - O "Pescador de Dados da Blockchain"**

**Analogia**: **Wagmi** Ã© como um **"assistente pessoal"** que fica buscando informaÃ§Ãµes na blockchain e traz prontas para seu site.

**ğŸ¤” O que wagmi faz na prÃ¡tica:**

```typescript
// âœ¨ MÃGICA DO WAGMI
const { address, isConnected } = useAccount()  // Pega dados da carteira
const { data: balance } = useBalance()         // Pesca o saldo
const { data: tasks } = useReadContract()      // LÃª dados do contrato
```

**Analogia detalhada:**
- **`useAccount()`**: Como um **"recepcionista"** que sabe quem estÃ¡ logado
  - "Ah, o senhor JoÃ£o (endereÃ§o 0x123...) estÃ¡ aqui!"
  
- **`useBalance()`**: Como um **"caixa eletrÃ´nico"** que mostra seu saldo
  - "Senhor JoÃ£o, vocÃª tem R$ 150,00 na conta"
  
- **`useReadContract()`**: Como um **"consultor"** que vai no banco de dados buscar informaÃ§Ã£o
  - "Senhor JoÃ£o, vocÃª tem 3 tarefas cadastradas: [1, 2, 3]"

#### ğŸ”„ **Como Wagmi Funciona Automaticamente**

```typescript
// ğŸ¤– WAGMI TRABALHANDO 24/7
function MeuComponente() {
  const { data: minhasTarefas } = useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'getMyTasks'
  })
  
  // âœ¨ WAGMI AUTOMÃTICO:
  // - Verifica dados a cada 4 segundos
  // - Se mudou algo na blockchain, atualiza automÃ¡tico
  // - Mostra "loading" enquanto busca
  // - Guarda cache para nÃ£o buscar toda hora
  
  return <div>VocÃª tem {minhasTarefas?.length} tarefas</div>
}
```

**ğŸ§  Por que isso Ã© incrÃ­vel:**
- **AtualizaÃ§Ã£o automÃ¡tica**: Se criar nova tarefa, a lista atualiza sozinha
- **Cache inteligente**: NÃ£o fica fazendo a mesma consulta mil vezes
- **Loading states**: Mostra "carregando..." automÃ¡tico
- **Zero configuraÃ§Ã£o**: Funciona sem vocÃª programar nada complexo

#### âš¡ **Viem - O "Tradutor da Linguagem Blockchain"**

**Analogia**: **Viem** Ã© como um **"tradutor simultÃ¢neo"** que converte suas instruÃ§Ãµes em JavaScript para a "linguagem" da blockchain.

**ğŸ—£ï¸ TraduÃ§Ã£o em tempo real:**

```typescript
// ğŸ—£ï¸ VOCÃŠ FALA (JavaScript):
await writeContract({
  address: CONTRACT_ADDRESS,
  abi: CONTRACT_ABI,
  functionName: 'createTask',
  args: ['Estudar React', 'Terminar curso', deadline],
  value: parseEther('0.001')  // 0.001 ETH
})

// ğŸ¤– VIEM TRADUZ PARA BLOCKCHAIN:
// "Chamar funÃ§Ã£o createTask no contrato 0x123... 
//  com parÃ¢metros ('Estudar React', 'Terminar curso', 1703980800)
//  enviando 1000000000000000 wei (0.001 ETH)"
```

**ğŸ¯ O que viem faz especificamente:**

**1. ğŸ”¢ ConversÃ£o de NÃºmeros:**
```typescript
// VocÃª escreve (fÃ¡cil):
parseEther('0.001')  // 0.001 ETH

// Viem converte para (formato blockchain):
'1000000000000000'   // 1000000000000000 wei
```

**2. ğŸ“ PreparaÃ§Ã£o de Dados:**
```typescript
// VocÃª escreve:
args: ['Estudar React', 'Terminar curso', deadline]

// Viem empacota para blockchain:
encodeFunctionData({...}) // Dados em formato hexadecimal
```

**3. ğŸ” Assinatura de TransaÃ§Ãµes:**
```typescript
// VocÃª clica "Enviar"
// Viem + MetaMask fazem toda a criptografia e assinatura digital
```

#### ğŸ¤ **Como Wagmi e Viem Trabalham Juntos**

**Analogia**: Como um **"app de delivery"** completo:

```
ğŸ“± SEU APP          ğŸšš WAGMI           âš¡ VIEM            ğŸª BLOCKCHAIN
     â”‚                  â”‚                  â”‚                    â”‚
ğŸ“ "Criar tarefa"      â”‚                  â”‚                    â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                  â”‚                    â”‚
     â”‚                  â”‚ Prepara dados    â”‚                    â”‚
     â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                    â”‚
     â”‚                  â”‚                  â”‚ Assina transaÃ§Ã£o   â”‚
     â”‚                  â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
     â”‚                  â”‚                  â”‚                    â”‚ Executa
     â”‚                  â”‚ Monitora status  â”‚                    â”‚ createTask()
     â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                    â”‚
ğŸ“Š Atualiza interface  â”‚                  â”‚                    â”‚
     â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                  â”‚                    â”‚
     â”‚                  â”‚                  â”‚                    â”‚
```

**DivisÃ£o de responsabilidades:**
- **ğŸ“± Seu App**: Interface bonita e experiÃªncia do usuÃ¡rio
- **ğŸšš Wagmi**: Gerencia estado, cache, atualizaÃ§Ãµes automÃ¡ticas
- **âš¡ Viem**: ComunicaÃ§Ã£o direta e traduÃ§Ã£o para blockchain
- **ğŸª Blockchain**: Executa o cÃ³digo e guarda os dados

### ğŸ› ï¸ **Passo 1: InstalaÃ§Ã£o das DependÃªncias**

#### ğŸ“¦ **1.1 DependÃªncias Web3**

```bash
# ğŸ“¦ Bibliotecas principais para Web3
pnpm add wagmi viem

# ğŸ”„ Gerenciamento de estado (cache inteligente)
pnpm add @tanstack/react-query

# ğŸ”Œ Conectores para carteiras
pnpm add @wagmi/connectors
```

#### ğŸ¨ **1.2 Componentes UI com shadcn**

**Analogia**: Como usar uma **"loja de componentes prontos"** ao invÃ©s de fazer tudo do zero!

```bash
# ğŸ¯ Inicializar shadcn (se ainda nÃ£o foi feito)
npx shadcn@latest init

# ğŸ“‹ Instalar componentes necessÃ¡rios
npx shadcn@latest add dialog
npx shadcn@latest add label  
npx shadcn@latest add button
npx shadcn@latest add input
npx shadcn@latest add textarea
npx shadcn@latest add card
npx shadcn@latest add badge
npx shadcn@latest add tooltip
npx shadcn@latest add alert
```

**ğŸ¤” Por que usar shadcn:**
- âœ… **Componentes prontos**: NÃ£o precisa criar Dialog, Label, etc. manualmente
- âœ… **Tipos TypeScript**: JÃ¡ vem com tipagem perfeita
- âœ… **CustomizÃ¡vel**: VocÃª pode modificar o cÃ³digo depois
- âœ… **AcessÃ­vel**: Segue padrÃµes de acessibilidade
- âœ… **Consistente**: Visual uniforme em todo o app

**ğŸ¤” Por que cada biblioteca Web3:**

- **`wagmi`**: O "assistente pessoal" que busca dados da blockchain
- **`viem`**: O "tradutor" que converte JavaScript â†” Blockchain  
- **`@tanstack/react-query`**: A "memÃ³ria inteligente" que guarda dados
- **`@wagmi/connectors`**: Os "adaptadores" para diferentes carteiras

### ğŸ£ **Passo 2: Criar Hooks Customizados**

#### **ğŸ¤” Por que usar Hooks?**

**Analogia**: Hooks sÃ£o como **"funcionÃ¡rios especializados"** numa empresa:

- **ğŸ‘” Gerente de Vendas** (useCreateTask): SÃ³ cuida de criar tarefas
- **ğŸ“Š Analista de Dados** (useTaskMetrics): SÃ³ cuida de calcular estatÃ­sticas
- **ğŸ” Pesquisador** (useAllUserTasks): SÃ³ cuida de buscar dados
- **ğŸ”— Recepcionista** (useWeb3Status): SÃ³ cuida de saber quem estÃ¡ logado

**âœ… Vantagens dos Hooks:**
- **ReutilizÃ¡vel**: Usa o mesmo hook em vÃ¡rios componentes
- **Organizado**: Cada hook tem uma responsabilidade especÃ­fica
- **AutomÃ¡tico**: Atualiza dados automaticamente quando necessÃ¡rio
- **Limpo**: Componente fica simples, lÃ³gica fica nos hooks

Vamos criar **"assistentes especializados"** para cada tarefa do nosso app:

#### ğŸ“ **Criar `hooks/useTaskManager.ts`**

```typescript
// hooks/useTaskManager.ts - Nossos "assistentes especialistas"

import { useReadContract, useWriteContract, useAccount } from 'wagmi'
import { CONTRACT_ADDRESS, CONTRACT_ABI } from '@/lib/web3'
import { parseEther } from 'viem'

// ğŸ£ Hook: Buscar minhas tarefas
export function useMyTasks() {
  const { address } = useAccount()
  
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'getMyTasks',
    account: address,
    // âœ¨ WAGMI AUTOMÃTICO:
    // - Atualiza a cada 4 segundos
    // - Para de buscar se usuÃ¡rio nÃ£o conectado
    // - Guarda resultado em cache
  })
}

// ğŸ” Hook: Buscar dados de uma tarefa especÃ­fica
export function useTask(taskId: number | undefined) {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'tasks',
    args: taskId ? [BigInt(taskId)] : undefined,
    enabled: !!taskId, // SÃ³ busca se taskId existir
  })
}

// ğŸ“Š Hook: Buscar total de tarefas no sistema
export function useTotalTasks() {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'totalTasks',
  })
}

// âœï¸ Hook: Criar nova tarefa
export function useCreateTask() {
  const { writeContract, isPending, error } = useWriteContract()
  
  const createTask = async (
    title: string, 
    description: string, 
    deadline: Date,
    stakeAmount: string = '0.001' // ETH
  ) => {
    try {
      // ğŸ—“ï¸ Converte data para timestamp
      const deadlineTimestamp = Math.floor(deadline.getTime() / 1000)
      
      // ğŸ“ Chama funÃ§Ã£o do contrato
      await writeContract({
        address: CONTRACT_ADDRESS,
        abi: CONTRACT_ABI,
        functionName: 'createTask',
        args: [title, description, BigInt(deadlineTimestamp)],
        value: parseEther(stakeAmount), // Converte ETH para Wei
      })
      
      console.log('âœ… Tarefa criada com sucesso!')
      
    } catch (err) {
      console.error('âŒ Erro ao criar tarefa:', err)
      throw err
    }
  }
  
  return {
    createTask,
    isPending, // true = transaÃ§Ã£o sendo processada
    error      // detalhes do erro, se houver
  }
}

// âœ… Hook: Completar tarefa
export function useCompleteTask() {
  const { writeContract, isPending, error } = useWriteContract()
  
  const completeTask = async (taskId: number) => {
    try {
      await writeContract({
        address: CONTRACT_ADDRESS,
        abi: CONTRACT_ABI,
        functionName: 'completeTask',
        args: [BigInt(taskId)],
      })
      
      console.log('âœ… Tarefa completada!')
      
    } catch (err) {
      console.error('âŒ Erro ao completar tarefa:', err)
      throw err
    }
  }
  
  return {
    completeTask,
    isPending,
    error
  }
}

// ğŸ”— Hook: Status da conexÃ£o
export function useWeb3Status() {
  const { address, isConnected } = useAccount()
  
  return {
    address,
    isConnected,
    // EndereÃ§o formatado para exibiÃ§Ã£o
    shortAddress: address ? `${address.slice(0, 6)}...${address.slice(-4)}` : null
  }
}
```

**Analogia**: Cada hook Ã© como um **"funcionÃ¡rio especializado"**:

- **`useMyTasks`**: "SecretÃ¡rio" que sempre sabe suas tarefas
- **`useTask`**: "Arquivista" que busca dados de tarefa especÃ­fica  
- **`useCreateTask`**: "Assistente de criaÃ§Ã£o" que registra novas tarefas
- **`useCompleteTask`**: "Supervisor" que marca tarefas como concluÃ­das
- **`useWeb3Status`**: "Recepcionista" que sabe quem estÃ¡ logado

### ğŸ—ï¸ **Passo 3: ConfiguraÃ§Ã£o da ConexÃ£o Web3**

Agora que entendemos os hooks, vamos configurar a **conexÃ£o com a blockchain**. Este arquivo Ã© como a **"configuraÃ§Ã£o de internet"** do nosso DApp:

#### ğŸ“ **Criar `lib/web3.ts` - O "Centro de Controle" da ConexÃ£o**

**Analogia**: Imagine que vocÃª vai instalar **internet e TV a cabo** em casa. O arquivo `web3.ts` Ã© como o **"manual de configuraÃ§Ã£o"** que o tÃ©cnico usa para conectar tudo corretamente.

```typescript
// lib/web3.ts - Nossa "Central de ConexÃµes"

// ğŸ“¦ Importa as ferramentas necessÃ¡rias
import { createConfig, http } from 'wagmi'
import { sepolia } from 'wagmi/chains'
import { metaMask, walletConnect } from 'wagmi/connectors'
```

**ğŸ“– ExplicaÃ§Ã£o das importaÃ§Ãµes:**

**`import { createConfig, http } from 'wagmi'`**
- **Analogia**: Como importar **"ferramentas de instalaÃ§Ã£o"** da caixa de ferramentas
- **`createConfig`**: Ã‰ a **"funÃ§Ã£o principal"** que monta toda a configuraÃ§Ã£o
- **`http`**: Ã‰ o **"tipo de conexÃ£o"** (como escolher cabo ou fibra Ã³tica)

**`import { sepolia } from 'wagmi/chains'`**
- **Analogia**: Como escolher **"qual cidade"** vocÃª quer internet
- **`sepolia`**: Ã‰ a **"rede de teste"** do Ethereum (como uma cidade de treino)
- **Por que Sepolia**: Ã‰ grÃ¡tis e seguro para aprender (nÃ£o usa dinheiro real)

**`import { metaMask, walletConnect } from 'wagmi/connectors'`**
- **Analogia**: Como escolher **"quais aparelhos"** podem conectar na sua internet
- **`metaMask`**: Conecta carteiras MetaMask (o mais popular)
- **`walletConnect`**: Conecta carteiras do celular (Trust Wallet, etc.)

---

#### ğŸ”‘ **SeÃ§Ã£o 1: ConfiguraÃ§Ãµes de Acesso**

```typescript
// ğŸ”‘ ConfiguraÃ§Ãµes (substitua pelos seus valores)
const projectId = 'SEU_WALLETCONNECT_PROJECT_ID' // De https://cloud.walletconnect.com
const alchemyApiKey = 'SUA_ALCHEMY_API_KEY'      // De https://alchemy.com
```

**ğŸ“– ExplicaÃ§Ã£o das chaves:**

**`const projectId = 'SEU_WALLETCONNECT_PROJECT_ID'`**
- **Analogia**: Como o **"cÃ³digo do seu plano de internet"** 
- **O que Ã©**: Identificador Ãºnico para carteiras mobile se conectarem
- **Onde pegar**: Site oficial da WalletConnect (gratuito)
- **Para que serve**: Permite que apps mobile conectem ao seu DApp

**`const alchemyApiKey = 'SUA_ALCHEMY_API_KEY'`**
- **Analogia**: Como a **"senha da sua conexÃ£o"** com a operadora de internet
- **O que Ã©**: Chave de acesso aos serviÃ§os da Alchemy
- **Onde pegar**: Site oficial da Alchemy (gratuito atÃ© certo limite)
- **Para que serve**: Permite que seu app "fale" com a blockchain Ethereum

---

#### âš™ï¸ **SeÃ§Ã£o 2: ConfiguraÃ§Ã£o Principal**

```typescript
// âš™ï¸ ConfiguraÃ§Ã£o principal - nossa "receita de conexÃ£o"
export const config = createConfig({
  // ğŸŒ Em qual blockchain vamos trabalhar
  chains: [sepolia],
  
  // ğŸ”Œ Quais carteiras podem conectar
  connectors: [
    metaMask(),                     // MetaMask (mais popular)
    walletConnect({ projectId }),   // WalletConnect (carteiras mobile)
  ],
  
  // ğŸŒ Como conectar na internet da blockchain
  transports: {
    [sepolia.id]: http(`https://eth-sepolia.g.alchemy.com/v2/${alchemyApiKey}`)
  },
})
```

**ğŸ“– ExplicaÃ§Ã£o linha por linha:**

**`export const config = createConfig({`**
- **Analogia**: Como **"criar o manual de instalaÃ§Ã£o completo"**
- **`export`**: Torna disponÃ­vel para outros arquivos usarem
- **`createConfig`**: FunÃ§Ã£o que monta toda a configuraÃ§Ã£o Web3

**`chains: [sepolia],`**
- **Analogia**: Como escolher **"em qual cidade vocÃª quer internet"**
- **`chains`**: Lista de blockchains que seu app pode usar
- **`[sepolia]`**: SÃ³ a rede Sepolia (array com um item)
- **Por que array**: VocÃª pode adicionar mais redes depois: `[sepolia, mainnet]`

**`connectors: [metaMask(), walletConnect({ projectId })],`**
- **Analogia**: Como listar **"quais tipos de aparelho podem conectar"**
- **`connectors`**: Lista de carteiras aceitas pelo seu app
- **`metaMask()`**: Carteira MetaMask (extensÃ£o do navegador)
- **`walletConnect({ projectId })`**: Carteiras mobile (precisa do projectId)

**`transports: { [sepolia.id]: http(...) }`**
- **Analogia**: Como configurar **"qual cabo usar para cada cidade"**
- **`transports`**: Como se conectar fisicamente com cada blockchain
- **`[sepolia.id]`**: Para a rede Sepolia especificamente
- **`http(...)`**: Usar conexÃ£o HTTP com a URL da Alchemy

---

#### ğŸ“ **SeÃ§Ã£o 3: EndereÃ§o do Smart Contract**

```typescript
// ğŸ“ EndereÃ§o do nosso smart contract (copie do deploy)
export const CONTRACT_ADDRESS = '0xSEU_ENDERECO_DO_CONTRATO_AQUI'
```

**ğŸ“– ExplicaÃ§Ã£o:**

**`export const CONTRACT_ADDRESS = '0x...'`**
- **Analogia**: Como o **"endereÃ§o da sua loja"** na blockchain
- **O que Ã©**: LocalizaÃ§Ã£o Ãºnica onde seu smart contract foi instalado
- **Formato**: Sempre comeÃ§a com `0x` seguido de 40 caracteres
- **Onde pegar**: Console do terminal quando vocÃª fez o deploy
- **Exemplo real**: `'0xb17d39826a1b83f7685de1ebc924b3185b677383'`

---

#### ğŸ“‹ **SeÃ§Ã£o 4: ABI - O "Manual de InstruÃ§Ãµes"**

```typescript
// ğŸ“‹ ABI - "Manual de instruÃ§Ãµes" do contrato
export const CONTRACT_ABI = [
  // ğŸ“ FunÃ§Ã£o: createTask (criar nova tarefa)
  {
    "inputs": [
      { "internalType": "string", "name": "_title", "type": "string" },
      { "internalType": "string", "name": "_description", "type": "string" },
      { "internalType": "uint256", "name": "_deadline", "type": "uint256" }
    ],
    "name": "createTask",
    "outputs": [],
    "stateMutability": "payable",  // â† Aceita ETH junto
    "type": "function"
  },
  // ... mais funÃ§Ãµes
] as const
```

**ğŸ“– ExplicaÃ§Ã£o do ABI:**

**`export const CONTRACT_ABI = [`**
- **Analogia**: Como o **"manual de instruÃ§Ãµes"** de um aparelho eletrÃ´nico
- **ABI significa**: Application Binary Interface (Interface BinÃ¡ria da AplicaÃ§Ã£o)
- **O que Ã©**: Lista de todas as funÃ§Ãµes que o contrato sabe fazer
- **Por que precisamos**: Sem isso, nÃ£o sabemos como "falar" com o contrato

**ExplicaÃ§Ã£o de uma funÃ§Ã£o do ABI:**

```typescript
{
  "inputs": [
    { "internalType": "string", "name": "_title", "type": "string" },
    { "internalType": "string", "name": "_description", "type": "string" },
    { "internalType": "uint256", "name": "_deadline", "type": "uint256" }
  ],
  "name": "createTask",
  "outputs": [],
  "stateMutability": "payable",
  "type": "function"
}
```

**`"name": "createTask"`**
- **Analogia**: Como o **"nome do botÃ£o"** que vocÃª aperta
- **O que Ã©**: Nome da funÃ§Ã£o no smart contract
- **Uso**: Ã‰ isso que chamamos no JavaScript: `createTask(...)`

**`"inputs": [...]`**
- **Analogia**: Como a **"lista de ingredientes"** que vocÃª precisa dar
- **`_title`**: Texto com o nome da tarefa
- **`_description`**: Texto com a descriÃ§Ã£o
- **`_deadline`**: NÃºmero representando a data limite

**`"stateMutability": "payable"`**
- **Analogia**: Como um **"cofre que aceita moedas"**
- **`"payable"`**: Esta funÃ§Ã£o **aceita ETH** junto com a chamada
- **`"nonpayable"`**: FunÃ§Ã£o que **nÃ£o aceita ETH**
- **`"view"`**: FunÃ§Ã£o que **sÃ³ lÃª dados** (nÃ£o gasta gas)

**`"outputs": []`**
- **Analogia**: Como **"o que a mÃ¡quina te devolve"**
- **`[]`**: Esta funÃ§Ã£o nÃ£o retorna nada
- **Se tivesse**: `[{"type": "uint256"}]` = retorna um nÃºmero

**`"type": "function"`**
- **Analogia**: Como dizer **"isto Ã© um botÃ£o"** (nÃ£o um texto ou imagem)
- **Outros tipos**: `"event"` (notificaÃ§Ã£o), `"constructor"` (instalaÃ§Ã£o)

---

#### ğŸ¯ **Resumo do que Configuramos**

**ğŸ” O que este arquivo faz:**

1. **ğŸŒ Escolhe a rede**: Sepolia (rede de teste)
2. **ğŸ”Œ Define carteiras**: MetaMask e carteiras mobile
3. **ğŸ›£ï¸ Configura conexÃ£o**: Via Alchemy (como internet)
4. **ğŸ“ Define endereÃ§o**: Onde encontrar nosso contrato
5. **ğŸ“‹ Lista funÃ§Ãµes**: O que o contrato sabe fazer

**ğŸ¯ Analogia completa**: 
Ã‰ como **configurar um sistema de delivery**:
- **Rede** = qual cidade (Sepolia)
- **Carteiras** = quais apps de pagamento aceitar (MetaMask, etc.)
- **Transporte** = qual internet usar (Alchemy)
- **EndereÃ§o** = onde fica o restaurante (CONTRACT_ADDRESS)
- **ABI** = cardÃ¡pio do restaurante (que pratos tÃªm, ingredientes, preÃ§os)

### ğŸ¯ **Passo 4: Configurar Provedores no App**

Agora vamos configurar os **"fornecedores de energia"** do nosso DApp. Os providers sÃ£o como a **"fiaÃ§Ã£o elÃ©trica"** que distribui funcionalidades Web3 para todo o aplicativo.

#### ğŸ“ **Criar `providers/Web3Provider.tsx` - O "Quadro de ForÃ§a" Web3**

**Analogia**: Imagine que vocÃª instalou **painÃ©is solares** em casa. O `Web3Provider` Ã© como o **"quadro de forÃ§a especializado"** que converte e distribui essa energia solar para todos os aparelhos da casa.

```typescript
// providers/Web3Provider.tsx - Provider Web3 isolado

'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from '@/lib/web3'
import { useState, ReactNode } from 'react'

interface Web3ProviderProps {
  children: ReactNode
}
```

**ğŸ“– ExplicaÃ§Ã£o das importaÃ§Ãµes:**

**`'use client'`**
- **Analogia**: Como uma **"placa de aviso"** que diz "esta peÃ§a precisa funcionar no navegador"
- **Por que**: Bibliotecas Web3 precisam de recursos do navegador (MetaMask, localStorage, etc.)
- **Quando usar**: Sempre que o componente usar Web3, useState, ou eventos

**`import { QueryClient, QueryClientProvider } from '@tanstack/react-query'`**
- **Analogia**: Como importar um **"sistema de armazenamento inteligente"**
- **QueryClient**: Gerencia **cache** (memÃ³ria temporÃ¡ria) dos dados da blockchain
- **QueryClientProvider**: **Distribui** esse sistema de cache para toda a aplicaÃ§Ã£o

**`import { WagmiProvider } from 'wagmi'`**
- **Analogia**: Como importar o **"gerador principal"** de energia Web3
- **WagmiProvider**: **Fornece** todas as funcionalidades Web3 (conexÃ£o, contratos, etc.)

**`import { config } from '@/lib/web3'`**
- **Analogia**: Como importar o **"manual de configuraÃ§Ã£o"** que criamos no Passo 3
- **config**: Todas as configuraÃ§Ãµes (redes, carteiras, contratos) que definimos

---

#### ğŸ§  **SeÃ§Ã£o 1: Criando a "MemÃ³ria Inteligente"**

```typescript
export function Web3Provider({ children }: Web3ProviderProps) {
  // ğŸ§  Cria a "memÃ³ria inteligente" (cache)
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        // âš¡ ConfiguraÃ§Ãµes otimizadas para Web3
        refetchOnWindowFocus: false,
        retry: 1,
        staleTime: 1000 * 60 * 5, // 5 minutos
      },
    },
  }))
```

**ğŸ“– ExplicaÃ§Ã£o detalhada:**

**`const [queryClient] = useState(() => new QueryClient({`**
- **Analogia**: Como **"instalar um HD SSD"** especializado para guardar dados temporÃ¡rios
- **useState**: Garante que criamos sÃ³ um cliente de cache (nÃ£o recria a cada render)
- **Arrow function `() =>`**: SÃ³ executa na primeira vez (lazy initialization)

**`defaultOptions: { queries: {`**
- **Analogia**: Como **"configurar as regras do arquivo temporÃ¡rio"**
- **defaultOptions**: ConfiguraÃ§Ãµes que se aplicam a **todas** as consultas
- **queries**: EspecÃ­fico para **buscar dados** (nÃ£o para enviar transaÃ§Ãµes)

**`refetchOnWindowFocus: false,`**
- **Analogia**: Como **"nÃ£o verificar emails toda vez que olha pro computador"**
- **O que faz**: NÃ£o recarrega dados quando vocÃª volta para a aba do navegador
- **Por que false**: Blockchain nÃ£o muda tÃ£o rÃ¡pido, evita consultas desnecessÃ¡rias

**`retry: 1,`**
- **Analogia**: Como **"tentar discar de novo sÃ³ 1 vez se deu ocupado"**
- **O que faz**: Se uma consulta falhar, tenta mais 1 vez antes de desistir
- **Por que 1**: Blockchain Ã s vezes estÃ¡ congestionada, mas nÃ£o adianta insistir muito

**`staleTime: 1000 * 60 * 5, // 5 minutos`**
- **Analogia**: Como **"considerar notÃ­cia velha depois de 5 minutos"**
- **O que faz**: Dados sÃ£o considerados "frescos" por 5 minutos
- **Depois de 5 min**: Busca dados novos da blockchain automaticamente
- **CÃ¡lculo**: 1000ms Ã— 60s Ã— 5min = 300.000ms

---

#### ğŸ”Œ **SeÃ§Ã£o 2: Estrutura dos Providers**

```typescript
  return (
    {/* ğŸ”§ WAGMI: Fornece conexÃ£o Web3 para todo o app */}
    <WagmiProvider config={config}>
      {/* ğŸ—„ï¸ QUERY: Gerencia cache e atualizaÃ§Ãµes automÃ¡ticas */}
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    </WagmiProvider>
  )
}
```

**ğŸ“– ExplicaÃ§Ã£o da estrutura aninhada:**

**`<WagmiProvider config={config}>`**
- **Analogia**: Como **"ligar o gerador principal"** na casa
- **O que faz**: Disponibiliza todas as funcionalidades Web3 para componentes filhos
- **config**: Usa as configuraÃ§Ãµes que criamos no `lib/web3.ts`
- **Fornece**: useAccount, useConnect, useContract, etc.

**`<QueryClientProvider client={queryClient}>`**
- **Analogia**: Como **"instalar o sistema de armazenamento"** na casa
- **O que faz**: Gerencia cache, loading states, refetch automÃ¡tico
- **client**: Usa o cliente que configuramos acima
- **Dentro de WagmiProvider**: Porque precisa das funcionalidades Web3

**`{children}`**
- **Analogia**: Como **"todos os aparelhos da casa"** que vÃ£o receber energia
- **O que sÃ£o**: Todos os componentes que estÃ£o dentro do provider
- **BenefÃ­cio**: Podem usar hooks Web3 (useAccount, useContract, etc.)

**ğŸ”„ Fluxo de funcionamento:**

```
ğŸ  WagmiProvider
     â†“ fornece conexÃµes Web3
ğŸ§  QueryClientProvider  
     â†“ fornece cache inteligente
ğŸ“± Seus Componentes
     â†“ podem usar hooks como:
     â€¢ useAccount() â†’ "quem estÃ¡ logado?"
     â€¢ useContract() â†’ "chamar funÃ§Ã£o do contrato"  
     â€¢ useBalance() â†’ "quanto dinheiro tem?"
```

---

#### ğŸ“ **Atualizar `app/layout.tsx` - A "FiaÃ§Ã£o Principal"**

**Analogia**: O `layout.tsx` Ã© como a **"fiaÃ§Ã£o elÃ©trica principal"** da casa, que distribui energia para todos os cÃ´modos.

```typescript
// app/layout.tsx - MantÃ©m como estÃ¡ (sem 'use client')

import { Web3Provider } from '@/providers/Web3Provider'
import { Toaster } from '@/components/ui/toaster'
import type { Metadata } from 'next'
import './globals.css'
```

**ğŸ“– ExplicaÃ§Ã£o das importaÃ§Ãµes:**

**Sem `'use client'` no topo**
- **Analogia**: Como **"fiaÃ§Ã£o que funciona tanto na geraÃ§Ã£o quanto na distribuiÃ§Ã£o"**
- **Server Component**: Pode usar otimizaÃ§Ãµes do Next.js (SEO, performance)
- **Roda no servidor**: Melhor para SEO e carregamento inicial

**`import { Web3Provider } from '@/providers/Web3Provider'`**
- **Analogia**: Como **"importar o quadro de forÃ§a especializado"**
- **O que Ã©**: O provider que criamos acima

**`import { Toaster } from '@/components/ui/toaster'`**
- **Analogia**: Como **"sistema de notificaÃ§Ãµes"** da casa
- **O que faz**: Mostra mensagens de sucesso/erro das transaÃ§Ãµes

---

#### ğŸ”§ **SeÃ§Ã£o 1: ConfiguraÃ§Ãµes do App**

```typescript
export const metadata: Metadata = {
  title: 'TaskManager DApp',
  description: 'Gerencie suas tarefas na blockchain Ethereum (Sepolia)',
  // ... resto das configuraÃ§Ãµes
}
```

**ğŸ“– ExplicaÃ§Ã£o:**

**`export const metadata: Metadata`**
- **Analogia**: Como **"placa de identificaÃ§Ã£o"** da casa
- **O que faz**: Define tÃ­tulo, descriÃ§Ã£o para Google, redes sociais
- **Server Component**: SÃ³ funciona em componentes servidor (sem 'use client')

---

#### ğŸ  **SeÃ§Ã£o 2: Estrutura Principal do Layout**

```typescript
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="pt-BR">
      <body className="min-h-screen bg-background font-sans antialiased">
        <Web3Provider>
          <main className="relative flex min-h-screen flex-col">
            {children}
          </main>
          <Toaster />
        </Web3Provider>
      </body>
    </html>
  )
}
```

**ğŸ“– ExplicaÃ§Ã£o da estrutura:**

**`<html lang="pt-BR">`**
- **Analogia**: Como **"definir que a casa fica no Brasil"**
- **lang="pt-BR"**: Diz aos navegadores que o conteÃºdo estÃ¡ em portuguÃªs
- **Acessibilidade**: Leitores de tela sabem como pronunciar

**`<body className="min-h-screen bg-background font-sans antialiased">`**
- **Analogia**: Como **"estilo bÃ¡sico de todos os cÃ´modos"**
- **min-h-screen**: Altura mÃ­nima = tela inteira
- **bg-background**: Cor de fundo padrÃ£o do tema
- **font-sans**: Fonte sem serifa (mais moderna)
- **antialiased**: Suaviza bordas das letras

**`<Web3Provider>`**
- **Analogia**: Como **"instalar o quadro de forÃ§a Web3"** na casa inteira
- **PosiÃ§Ã£o**: Envolve quase tudo (exceto html/body)
- **Efeito**: Todos os componentes filhos podem usar Web3

**`<main className="relative flex min-h-screen flex-col">`**
- **Analogia**: Como **"Ã¡rea principal utilizÃ¡vel"** da casa
- **relative**: Permite posicionamento de elementos filhos
- **flex flex-col**: Layout flexÃ­vel em coluna (vertical)
- **min-h-screen**: Garante que ocupa toda a tela

**`{children}`**
- **Analogia**: Como **"cada pÃ¡gina especÃ­fica"** da casa
- **O que sÃ£o**: page.tsx, about/page.tsx, etc.
- **DinÃ¢mico**: Muda conforme a URL que o usuÃ¡rio visita

**`<Toaster />`**
- **Analogia**: Como **"sistema de campainha/interfone"** da casa
- **PosiÃ§Ã£o**: Fora do main para aparecer sobre tudo
- **FunÃ§Ã£o**: Mostra notificaÃ§Ãµes de transaÃ§Ãµes Web3

---

#### ğŸ”„ **Hierarquia Completa - Como Tudo se Conecta**

```
ğŸ“„ layout.tsx (Server Component)
â”‚
â”œâ”€â”€ ğŸŒ <html> (define idioma)
â”‚   â”‚
â”‚   â””â”€â”€ ğŸ  <body> (estilos bÃ¡sicos)
â”‚       â”‚
â”‚       â””â”€â”€ ğŸ”Œ <Web3Provider> (energia Web3)
â”‚           â”‚
â”‚           â”œâ”€â”€ ğŸ“± <main> (Ã¡rea principal)
â”‚           â”‚   â”‚
â”‚           â”‚   â””â”€â”€ {children} (suas pÃ¡ginas)
â”‚           â”‚       â”‚
â”‚           â”‚       â””â”€â”€ ğŸ“„ page.tsx
â”‚           â”‚           â”œâ”€â”€ useAccount() âœ…
â”‚           â”‚           â”œâ”€â”€ useContract() âœ…  
â”‚           â”‚           â””â”€â”€ useBalance() âœ…
â”‚           â”‚
â”‚           â””â”€â”€ ğŸ”” <Toaster> (notificaÃ§Ãµes)
```

---

#### ğŸ¯ **Vantagens desta Arquitetura**

**âœ… SeparaÃ§Ã£o de Responsabilidades:**
- **layout.tsx**: SEO, estrutura geral, metadados
- **Web3Provider**: Funcionalidades blockchain, cache
- **page.tsx**: LÃ³gica especÃ­fica da pÃ¡gina

**âœ… Performance Otimizada:**
- **Server Component**: layout.tsx roda no servidor (mais rÃ¡pido)
- **Client Component**: Web3Provider sÃ³ onde necessÃ¡rio
- **Cache inteligente**: NÃ£o refaz consultas desnecessÃ¡rias

**âœ… ManutenÃ§Ã£o FÃ¡cil:**
- **Provider isolado**: MudanÃ§as Web3 ficam em um lugar sÃ³
- **ConfiguraÃ§Ã£o centralizada**: lib/web3.ts tem tudo
- **Tipagem segura**: TypeScript previne erros

**âœ… ExperiÃªncia do UsuÃ¡rio:**
- **Loading automÃ¡tico**: Cache gerencia estados de carregamento
- **NotificaÃ§Ãµes**: Toaster mostra feedback das transaÃ§Ãµes
- **ReconexÃ£o**: wagmi reconecta automaticamente se perder conexÃ£o

**ğŸ¯ Analogia Final:**

Ã‰ como **construir uma casa inteligente**:
- **ğŸ  Layout**: Estrutura e fiaÃ§Ã£o bÃ¡sica
- **ğŸ”Œ Web3Provider**: Sistema especializado para aparelhos inteligentes
- **ğŸ§  QueryClient**: Central de automaÃ§Ã£o que lembra configuraÃ§Ãµes
- **ğŸ“± Componentes**: Aparelhos inteligentes que se conectam automaticamente

### ğŸ’» **Passo 5: ImplementaÃ§Ã£o da Interface Principal**

Como vocÃª jÃ¡ tem uma interface bonita funcionando, vamos **integrar Web3 gradualmente** mantendo seu design atual:

#### ğŸ“ **Atualizar `app/page.tsx` - IntegraÃ§Ã£o Completa**

```typescript
// app/page.tsx - PÃ¡gina principal com integraÃ§Ã£o Web3

"use client"

import type React from "react"
import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { AlertCircle, CheckCircle2, ListTodo, Loader, Coins, PlusCircle, CheckSquare, Wallet, RefreshCw } from "lucide-react"

// ğŸ”§ Imports Web3 SIMPLIFICADOS
import { useConnect, useDisconnect, useChainId } from 'wagmi'
import { useWeb3Status, useContractBalance, useTaskMetrics } from '@/hooks/useTaskManager'
import { CreateTaskModal } from '@/components/CreateTaskModal'
import { TaskItem } from '@/components/TaskItem'
import { sepolia } from 'wagmi/chains'

export default function Web3TodoPage() {
  const [showCreateModal, setShowCreateModal] = useState(false)
  
  // ğŸ”— Hooks Web3 ULTRA-SIMPLIFICADOS
  const { connectors, connect } = useConnect()
  const { disconnect } = useDisconnect()
  const { isConnected, shortAddress } = useWeb3Status()
  const { refetchBalance } = useContractBalance()
  const chainId = useChainId()
  
  // ğŸš€ UM ÃšNICO HOOK para tudo: mÃ©tricas + tarefas + dados
  const {
    total,
    concluidas, 
    pendentes,
    weiInStake,
    tasks,
    isLoading: loadingTasks,
    refetch: refetchTasks
  } = useTaskMetrics()
  
  // Verificar se estÃ¡ na rede correta
  const isCorrectNetwork = chainId === sepolia.id
  const networkName = chainId === sepolia.id ? 'Sepolia' : `Rede ${chainId}`

  const handleConnectWallet = () => {
    if (isConnected) {
      disconnect()
    } else {
      const metamask = connectors.find(c => c.name === 'MetaMask')
      if (metamask) connect({ connector: metamask })
    }
  }

  const handleRefresh = async () => {
    await Promise.all([refetchTasks(), refetchBalance()])
  }

  return (
    <TooltipProvider>
      <div className="min-h-screen bg-gray-50 text-gray-900">
        <main className="container mx-auto p-4 sm:p-6 lg:p-8">
          {/* CabeÃ§alho */}
          <header className="mb-8">
            <div className="flex flex-col sm:flex-row justify-between items-center gap-4">
              <h1 className="text-3xl font-bold text-gray-800">WEB3 TODO</h1>
              <div className="flex items-center gap-2">
                {isConnected && (
                  <div className="flex flex-col items-end text-sm">
                    <span className="text-green-600 font-medium">{shortAddress}</span>
                    <div className="flex items-center gap-1">
                      <div className={`w-2 h-2 rounded-full ${isCorrectNetwork ? 'bg-green-500' : 'bg-red-500'}`}></div>
                      <span className={`text-xs ${isCorrectNetwork ? 'text-green-600' : 'text-red-600'}`}>
                        {networkName}
                      </span>
                    </div>
                  </div>
                )}
                <Button
                  onClick={handleConnectWallet}
                  className={`transition-all duration-300 ${
                    isConnected ? "bg-green-600 hover:bg-green-700" : "bg-violet-600 hover:bg-violet-700"
                  }`}
                >
                  <Wallet className="mr-2 h-4 w-4" />
                  {isConnected ? "Carteira Conectada" : "Conectar Carteira"}
                </Button>
              </div>
            </div>
            {!isConnected && (
              <Alert
                variant="destructive"
                className="mt-4 border-yellow-500/50 text-yellow-700 [&>svg]:text-yellow-700"
              >
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>AtenÃ§Ã£o</AlertTitle>
                <AlertDescription>Conecte sua carteira para gerenciar suas tarefas na blockchain.</AlertDescription>
              </Alert>
            )}
            {isConnected && !isCorrectNetwork && (
              <Alert
                variant="destructive"
                className="mt-4 border-red-500/50 text-red-700 [&>svg]:text-red-700"
              >
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>Rede Incorreta</AlertTitle>
                <AlertDescription>
                  VocÃª estÃ¡ conectado Ã  rede {networkName}. Por favor, mude para a rede Sepolia para usar este DApp.
                </AlertDescription>
              </Alert>
            )}

          </header>

          {/* SeÃ§Ã£o de MÃ©tricas */}
          <section className="mb-10">
            <div className="grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-4">
              <MetricCard
                title="Total de Tarefas"
                value={total}
                icon={<ListTodo className="h-6 w-6 text-violet-500" />}
                tooltip="NÃºmero total de tarefas criadas"
              />
              <MetricCard
                title="Tarefas ConcluÃ­das"
                value={concluidas}
                icon={<CheckCircle2 className="h-6 w-6 text-cyan-500" />}
                tooltip="Tarefas finalizadas no prazo - stake devolvido"
              />
              <MetricCard
                title="Tarefas Pendentes"
                value={pendentes}
                icon={<Loader className="h-6 w-6 text-yellow-500" />}
                tooltip="Tarefas ainda nÃ£o concluÃ­das"
              />
              <MetricCard
                title="ETH em Stake"
                value={`${weiInStake.toFixed(6)} ETH`}
                icon={<Coins className="h-6 w-6 text-indigo-500" />}
                tooltip="Valor total apostado em tarefas pendentes"
              />
            </div>
          </section>

          {/* SeÃ§Ã£o de Tarefas */}
          <section>
            <div className="flex justify-between items-center mb-6">
              <h2 className="text-2xl font-semibold text-gray-800">Tarefas</h2>
              <div className="flex gap-2">
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button 
                      disabled={!isConnected || loadingTasks} 
                      variant="outline"
                      onClick={handleRefresh}
                      className="border-violet-300 text-violet-600 hover:bg-violet-50"
                    >
                      <RefreshCw className={`mr-2 h-4 w-4 ${loadingTasks ? 'animate-spin' : ''}`} />
                      Atualizar
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>{!isConnected ? "Conecte sua carteira" : "Atualizar lista de tarefas"}</p>
                  </TooltipContent>
                </Tooltip>
                
                <Tooltip>
                  <TooltipTrigger asChild>
                    <div className="inline-block">
                      <Button 
                        disabled={!isConnected} 
                        className="bg-violet-600 hover:bg-violet-700 disabled:opacity-50"
                        onClick={() => setShowCreateModal(true)}
                      >
                        <PlusCircle className="mr-2 h-4 w-4" />
                        Nova Tarefa
                      </Button>
                    </div>
                  </TooltipTrigger>
                  {!isConnected && (
                    <TooltipContent>
                      <p>Conecte sua carteira para criar tarefas.</p>
                    </TooltipContent>
                  )}
                </Tooltip>
              </div>
            </div>
            
            <div className="space-y-4">
              {loadingTasks && isConnected ? (
                <div className="text-center p-8">
                  <Loader className="animate-spin h-8 w-8 mx-auto mb-4" />
                  <p>Carregando tarefas da blockchain...</p>
                </div>
              ) : (!tasks || tasks.length === 0) && isConnected ? (
                <div className="text-center p-8">
                  <p className="text-gray-500">VocÃª ainda nÃ£o tem tarefas. Crie sua primeira!</p>
                </div>
              ) : isConnected && tasks ? (
                tasks.map((task: any) => (
                  <TaskItem 
                    key={Number(task.id)} 
                    task={task}
                    isConnected={isConnected}
                    onTaskUpdate={refetchTasks}
                  />
                ))
              ) : null}
              
              {!isConnected && (
                <div className="text-center p-8">
                  <AlertCircle className="h-12 w-12 mx-auto mb-4 text-gray-400" />
                  <p className="text-gray-500">Conecte sua carteira para ver suas tarefas</p>
                </div>
              )}
            </div>
          </section>
        </main>
      </div>
      
      {/* Modal de Criar Tarefa */}
      <CreateTaskModal 
        open={showCreateModal} 
        onClose={() => setShowCreateModal(false)} 
      />
    </TooltipProvider>
  )
}

// Componente para os cards de mÃ©trica
function MetricCard({ 
  title, 
  value, 
  icon, 
  tooltip 
}: { 
  title: string; 
  value: string | number; 
  icon: React.ReactNode;
  tooltip?: string;
}) {
  const content = (
    <Card className="transition-shadow duration-300 hover:shadow-lg cursor-pointer">
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium text-gray-500">{title}</CardTitle>
        {icon}
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
      </CardContent>
    </Card>
  )

  if (tooltip) {
    return (
      <Tooltip>
        <TooltipTrigger asChild>
          {content}
        </TooltipTrigger>
        <TooltipContent>
          <p>{tooltip}</p>
        </TooltipContent>
      </Tooltip>
    )
  }

  return content
}
```

#### ğŸ“ **Criar `components/CreateTaskModal.tsx`**

```typescript
// components/CreateTaskModal.tsx - Modal para criar tarefas

'use client'

import { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Label } from '@/components/ui/label'
import { Loader } from 'lucide-react'
import { useCreateTask } from '@/hooks/useTaskManager'

interface CreateTaskModalProps {
  open: boolean
  onClose: () => void
}

export function CreateTaskModal({ open, onClose }: CreateTaskModalProps) {
  const [title, setTitle] = useState('')
  const [description, setDescription] = useState('')
  const [deadline, setDeadline] = useState('')
  const [stakeAmount, setStakeAmount] = useState('0.001')
  
  const { createTask, isPending } = useCreateTask()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    try {
      const deadlineDate = new Date(deadline)
      await createTask(title, description, deadlineDate, stakeAmount)
      
      // Limpa formulÃ¡rio e fecha modal
      setTitle('')
      setDescription('')
      setDeadline('')
      setStakeAmount('0.001')
      onClose()
      
    } catch (error) {
      console.error('Erro ao criar tarefa:', error)
    }
  }

  // Gera data mÃ­nima (hoje + 1 hora)
  const minDateTime = new Date(Date.now() + 60 * 60 * 1000).toISOString().slice(0, 16)

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>ğŸ¯ Nova Tarefa na Blockchain</DialogTitle>
        </DialogHeader>
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="title">TÃ­tulo da Tarefa</Label>
            <Input
              id="title"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder="Ex: Estudar Solidity"
              required
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="description">DescriÃ§Ã£o</Label>
            <Textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Descreva o que precisa ser feito..."
              rows={3}
              required
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="deadline">Prazo Final</Label>
            <Input
              id="deadline"
              type="datetime-local"
              value={deadline}
              onChange={(e) => setDeadline(e.target.value)}
              min={minDateTime}
              required
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="stake">Valor do Stake (ETH)</Label>
            <Input
              id="stake"
              type="number"
              step="0.001"
              min="0.001"
              value={stakeAmount}
              onChange={(e) => setStakeAmount(e.target.value)}
              placeholder="0.001"
              required
            />
            <p className="text-xs text-gray-500">
              ğŸ’¡ MÃ­nimo: 0.001 ETH â€¢ VocÃª recupera se completar no prazo!
            </p>
          </div>
          
          <div className="flex justify-end gap-3 pt-4">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancelar
            </Button>
            <Button type="submit" disabled={isPending} className="bg-violet-600 hover:bg-violet-700">
              {isPending ? (
                <>
                  <Loader className="mr-2 h-4 w-4 animate-spin" />
                  Criando...
                </>
              ) : (
                'Criar Tarefa'
              )}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}
```

### âš¡ **Passo 7: Testar e Configurar a IntegraÃ§Ã£o**

#### ğŸ”§ **7.1 Atualizar ConfiguraÃ§Ãµes**

**ğŸ“ Atualizar `lib/web3.ts` com seus dados reais:**

```typescript
// lib/web3.ts - Configure com seus dados

// ğŸ”‘ Substitua pelas suas chaves reais
const projectId = 'SUA_WALLETCONNECT_KEY_AQUI'  // De https://cloud.walletconnect.com
const alchemyApiKey = 'SUA_ALCHEMY_KEY_AQUI'    // De https://alchemy.com

// ğŸ“ Substitua pelo endereÃ§o do seu contrato deployado
export const CONTRACT_ADDRESS = '0xSEU_ENDERECO_DEPLOYADO_AQUI'
```

#### ğŸ§ª **7.2 Testar Localmente**

**1. ğŸš€ Iniciar o servidor:**
```bash
pnpm dev
```

**2. ğŸŒ Abrir http://localhost:3000**

**3. âœ… Fluxo de teste:**
1. **Conectar carteira**: Clique em "Conectar Carteira" â†’ MetaMask aparece
2. **Ver dados atualizados**: Dashboard mostra saldo e endereÃ§o
3. **Criar tarefa**: Clique "Nova Tarefa" â†’ Preenche formulÃ¡rio â†’ Assina transaÃ§Ã£o
4. **Ver tarefa na lista**: Tarefa aparece automaticamente apÃ³s confirmaÃ§Ã£o
5. **Completar tarefa**: Clique no âœ… â†’ Assina transaÃ§Ã£o â†’ Status atualiza

#### ğŸ” **7.3 Debug e Troubleshooting**

**ğŸš¨ Problemas comuns e soluÃ§Ãµes:**

**1. "MetaMask nÃ£o aparece"**
```typescript
// Verifique se MetaMask estÃ¡ instalado
console.log('MetaMask instalado:', typeof window.ethereum !== 'undefined')
```

**2. "Erro ao conectar"**
```typescript
// Verifique configuraÃ§Ã£o wagmi
console.log('ConfiguraÃ§Ã£o wagmi:', config)
console.log('Conectores disponÃ­veis:', connectors)
```

**3. "TransaÃ§Ãµes falham"**
```typescript
// Debug de transaÃ§Ãµes
console.log('EndereÃ§o do contrato:', CONTRACT_ADDRESS)
console.log('Rede conectada:', await provider.getNetwork())
```

**4. "Dados nÃ£o atualizam"**
```typescript
// Verifique hooks wagmi
console.log('Dados das tarefas:', taskIds)
console.log('Loading:', isLoading)
console.log('Erro:', error)
```

## ğŸ”— **Passo a Passo: Integrando Frontend com Smart Contract**

Agora que seu contrato estÃ¡ deployado, vamos conectar o frontend com a blockchain. Siga esta sequÃªncia **exata**:

### ğŸ“‹ **SequÃªncia de IntegraÃ§Ã£o (IMPORTANTE: Siga esta ordem!)**

**1. ğŸ“ Copiar dados do contrato deployado**
**2. âš™ï¸ Configurar arquivo web3.ts**  
**3. ğŸ£ Criar hooks customizados**
**4. ğŸ’» Atualizar pÃ¡gina principal**
**5. ğŸ§ª Testar integraÃ§Ã£o**

---

### ğŸ¯ **Passo 1: Copiando ABI e EndereÃ§o do Contrato**

#### **ğŸ“‹ O que Ã© ABI e por que precisamos?**

**Analogia**: ABI Ã© como um **"cardÃ¡pio de restaurante"** que lista todos os pratos (funÃ§Ãµes) disponÃ­veis e seus ingredientes (parÃ¢metros).

- **ğŸ¤” Sem ABI**: Ã‰ como tentar pedir comida sem ver o cardÃ¡pio - vocÃª nÃ£o sabe o que estÃ¡ disponÃ­vel
- **âœ… Com ABI**: VocÃª sabe exatamente quais funÃ§Ãµes pode chamar e como chamar

#### **ğŸ“ 1.1 Obter ABI do Contrato Compilado**

**Onde encontrar**: ApÃ³s compilar com Foundry, o ABI fica em:
```
smartcontract/out/TaskManager.sol/TaskManager.json
```

**ğŸ“‹ Como extrair o ABI:**

1. **Abra o arquivo**:
```bash
cd smartcontract
cat out/TaskManager.sol/TaskManager.json
```

2. **Procure pela seÃ§Ã£o "abi"** (Ã© um array gigante):
```json
{
  "abi": [
    {
      "inputs": [...],
      "name": "createTask",
      "outputs": [...],
      "stateMutability": "payable",
      "type": "function"
    },
    // ... muitas outras funÃ§Ãµes
  ]
}
```

3. **Copie APENAS o array da seÃ§Ã£o "abi"** (tudo entre `"abi": [` e `]`)

#### **ğŸ“ 1.2 Obter EndereÃ§o do Contrato**

**De onde vem**: Quando vocÃª fez o deploy, apareceu algo como:
```
TaskManager deployed at: 0xb17d39826a1b83f7685de1ebc924b3185b677383
```

**ğŸ“‹ Como confirmar se estÃ¡ correto:**
- Acesse: https://sepolia.etherscan.io/address/SEU_ENDERECO
- Se mostrar seu contrato = estÃ¡ certo âœ…

---

### âš™ï¸ **Passo 2: Configurando `lib/web3.ts`**

Este arquivo Ã© a **"central de conexÃ£o"** do seu DApp:

```typescript
// lib/web3.ts - "Central de ConexÃ£o" do seu DApp

import { createConfig, http } from 'wagmi'
import { sepolia } from 'wagmi/chains'
import { metaMask } from 'wagmi/connectors'

// ğŸŒ ConfiguraÃ§Ã£o principal
export const config = createConfig({
  chains: [sepolia],                                    // ğŸŒ Qual blockchain usar
  connectors: [metaMask()],                            // ğŸ”Œ Quais carteiras aceitar
  transports: {
    [sepolia.id]: http('https://sepolia.infura.io/v3/SUA_INFURA_KEY')  // ğŸ›£ï¸ Como conectar
  },
})

// ğŸ“ COLE AQUI: EndereÃ§o do seu contrato deployado
export const CONTRACT_ADDRESS = '0xSEU_ENDERECO_DEPLOYADO_AQUI'

// ğŸ“‹ COLE AQUI: ABI do seu contrato (copiado do arquivo .json)
export const CONTRACT_ABI = [
  // Cole aqui todo o array ABI que vocÃª copiou do arquivo TaskManager.json
  {
    "inputs": [
      { "internalType": "string", "name": "_title", "type": "string" },
      { "internalType": "string", "name": "_description", "type": "string" },
      { "internalType": "uint256", "name": "_deadline", "type": "uint256" }
    ],
    "name": "createTask",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  // ... resto das funÃ§Ãµes do ABI
] as const
```

**ğŸ¤” O que cada parte faz:**

- **`config`**: "Receita" de como conectar na blockchain
- **`CONTRACT_ADDRESS`**: "EndereÃ§o" onde seu contrato mora na blockchain
- **`CONTRACT_ABI`**: "Manual de instruÃ§Ãµes" de todas as funÃ§Ãµes disponÃ­veis
- **`as const`**: Diz ao TypeScript "estes dados nunca mudam"

---

### ğŸ£ **Passo 3: Entendendo os Hooks Customizados**

#### **ğŸ¤” Por que usar Hooks?**

**Analogia**: Hooks sÃ£o como **"funcionÃ¡rios especializados"** numa empresa:

- **ğŸ‘” Gerente de Vendas** (useCreateTask): SÃ³ cuida de criar tarefas
- **ğŸ“Š Analista de Dados** (useTaskMetrics): SÃ³ cuida de calcular estatÃ­sticas
- **ğŸ” Pesquisador** (useAllUserTasks): SÃ³ cuida de buscar dados
- **ğŸ”— Recepcionista** (useWeb3Status): SÃ³ cuida de saber quem estÃ¡ logado

**âœ… Vantagens dos Hooks:**
- **ReutilizÃ¡vel**: Usa o mesmo hook em vÃ¡rios componentes
- **Organizado**: Cada hook tem uma responsabilidade especÃ­fica
- **AutomÃ¡tico**: Atualiza dados automaticamente quando necessÃ¡rio
- **Limpo**: Componente fica simples, lÃ³gica fica nos hooks

### ğŸ“ **Anatomia do `hooks/useTaskManager.ts` - ExplicaÃ§Ã£o Detalhada**

Vamos dissecar cada hook do nosso arquivo como um **manual tÃ©cnico**:

#### ğŸš€ **Hook 1: useAllUserTasks() - O "CaÃ§ador de Dados"**

```typescript
export function useAllUserTasks() {
  const { address } = useAccount()
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'getUserTasksWithData',
    args: address ? [address] : undefined,
    query: { enabled: !!address }
  })
}
```

**ğŸ“– ExplicaÃ§Ã£o linha por linha:**

```typescript
const { address } = useAccount()
```
- **O que faz**: Pega o endereÃ§o da carteira conectada
- **Analogia**: Como perguntar "Qual Ã© seu CPF?" para identificar a pessoa
- **Resultado**: `address = "0x1a2b3c4d..."` ou `undefined` se nÃ£o conectado

```typescript
return useReadContract({
```
- **O que faz**: Chama uma funÃ§Ã£o do smart contract que **sÃ³ lÃª dados** (nÃ£o gasta gas)
- **Analogia**: Como "consultar saldo no banco" - sÃ³ olha, nÃ£o mexe

```typescript
address: CONTRACT_ADDRESS,
abi: CONTRACT_ABI,
functionName: 'getUserTasksWithData',
```
- **address**: "Onde" estÃ¡ o contrato (endereÃ§o na blockchain)
- **abi**: "Manual de instruÃ§Ãµes" para falar com o contrato
- **functionName**: "Qual funÃ§Ã£o" queremos chamar no contrato

```typescript
args: address ? [address] : undefined,
```
- **O que faz**: Passa o endereÃ§o da carteira como parÃ¢metro
- **Analogia**: Como dizer "mostre as tarefas do CPF 123.456.789-00"
- **Se nÃ£o conectado**: NÃ£o passa nenhum parÃ¢metro

```typescript
query: { enabled: !!address }
```
- **O que faz**: SÃ³ executa a busca se tiver carteira conectada
- **`!!address`**: Converte para true/false (double negation)
- **Analogia**: "SÃ³ procure tarefas se a pessoa se identificou"

#### ğŸ“Š **Hook 2: useTaskMetrics() - O "Calculadora Inteligente"**

```typescript
export function useTaskMetrics() {
  const { data: allTasks, isLoading, error, refetch } = useAllUserTasks()
  
  // Se ainda estÃ¡ carregando ou sem dados
  if (isLoading || !allTasks) {
    return {
      total: 0, concluidas: 0, pendentes: 0, weiInStake: 0,
      tasks: [], isLoading: true, error: null, refetch
    }
  }

  // Se nÃ£o hÃ¡ tarefas
  if (!Array.isArray(allTasks) || allTasks.length === 0) {
    return {
      total: 0, concluidas: 0, pendentes: 0, weiInStake: 0,
      tasks: [], isLoading: false, error: null, refetch
    }
  }

  // ğŸ§® Calcular mÃ©tricas automaticamente
  let concluidas = 0
  let totalStake = 0

  allTasks.forEach((task: any) => {
    if (task.status) {
      concluidas++
    } else {
      totalStake += Number(task.stakeAmount)
    }
  })

  return {
    total: allTasks.length,
    concluidas,
    pendentes: allTasks.length - concluidas,
    weiInStake: totalStake / 1e18,
    tasks: allTasks,
    isLoading: false,
    error,
    refetch
  }
}
```

**ğŸ“– ExplicaÃ§Ã£o detalhada:**

**ğŸ” Primeira parte - Buscar dados:**
```typescript
const { data: allTasks, isLoading, error, refetch } = useAllUserTasks()
```
- **data: allTasks**: Renomeia `data` para `allTasks` para ficar mais claro
- **isLoading**: `true` = ainda buscando dados, `false` = terminou
- **error**: Se deu erro, contÃ©m detalhes do erro
- **refetch**: FunÃ§Ã£o para "buscar novamente" quando quiser atualizar

**ğŸ”„ Estados de carregamento:**
```typescript
if (isLoading || !allTasks) {
  return { total: 0, ..., isLoading: true }
}
```
- **Por que verificar**: Evita erros quando dados ainda nÃ£o chegaram
- **Analogia**: Como dizer "ainda estou contando, aguarde..." numa votaÃ§Ã£o
- **Retorna zeros**: Para nÃ£o quebrar a interface

**ğŸ¯ VerificaÃ§Ã£o de dados vazios:**
```typescript
if (!Array.isArray(allTasks) || allTasks.length === 0) {
  return { total: 0, ..., tasks: [] }
}
```
- **Array.isArray()**: Confirma que Ã© realmente uma lista
- **length === 0**: Confirma que a lista nÃ£o estÃ¡ vazia
- **Analogia**: Como conferir se a gaveta estÃ¡ vazia antes de contar objetos

**ğŸ§® CÃ¡lculo das mÃ©tricas:**
```typescript
let concluidas = 0
let totalStake = 0

allTasks.forEach((task: any) => {
  if (task.status) {          // Se tarefa foi concluÃ­da
    concluidas++
  } else {                    // Se ainda estÃ¡ pendente
    totalStake += Number(task.stakeAmount)  // Soma valor apostado
  }
})
```
- **forEach**: Percorre cada tarefa da lista
- **task.status**: `true` = concluÃ­da, `false` = pendente
- **task.stakeAmount**: Valor apostado na tarefa (em wei)
- **Number()**: Converte de string para nÃºmero

**ğŸ“Š Retorno final:**
```typescript
return {
  total: allTasks.length,                    // Quantidade total
  concluidas,                                // Quantidade concluÃ­das
  pendentes: allTasks.length - concluidas,   // Total - concluÃ­das = pendentes
  weiInStake: totalStake / 1e18,            // Converte wei para ETH
  tasks: allTasks,                          // Dados completos
  isLoading: false,                         // NÃ£o estÃ¡ mais carregando
  error,                                    // Erro, se houver
  refetch                                   // FunÃ§Ã£o para atualizar
}
```

#### âœï¸ **Hook 3: useCreateTask() - O "Construtor de Tarefas"**

```typescript
export function useCreateTask() {
  const { writeContract, isPending, error } = useWriteContract()
  
  const createTask = async (title: string, description: string, deadline: Date, stakeAmount: string = '0.001') => {
    const deadlineTimestamp = Math.floor(deadline.getTime() / 1000)
    await writeContract({
      address: CONTRACT_ADDRESS,
      abi: CONTRACT_ABI,
      functionName: 'createTask',
      args: [title, description, BigInt(deadlineTimestamp)],
      value: parseEther(stakeAmount),
    })
  }
  
  return { createTask, isPending, error }
}
```

**ğŸ“– ExplicaÃ§Ã£o detalhada:**

**ğŸ”§ ConfiguraÃ§Ã£o inicial:**
```typescript
const { writeContract, isPending, error } = useWriteContract()
```
- **writeContract**: FunÃ§Ã£o que envia transaÃ§Ãµes para blockchain
- **isPending**: `true` = transaÃ§Ã£o sendo processada
- **error**: Detalhes de erro, se houver

**ğŸ“ FunÃ§Ã£o de criaÃ§Ã£o:**
```typescript
const createTask = async (title, description, deadline, stakeAmount = '0.001') => {
```
- **async**: FunÃ§Ã£o assÃ­ncrona (demora um tempo para completar)
- **ParÃ¢metros**: Dados necessÃ¡rios para criar a tarefa
- **stakeAmount = '0.001'**: Valor padrÃ£o se nÃ£o informado

**ğŸ—“ï¸ ConversÃ£o de data:**
```typescript
const deadlineTimestamp = Math.floor(deadline.getTime() / 1000)
```
- **deadline.getTime()**: Converte data para milissegundos
- **/ 1000**: Blockchain usa segundos, nÃ£o milissegundos
- **Math.floor()**: Remove decimais para ficar nÃºmero inteiro

**ğŸ’° ConversÃ£o de valor:**
```typescript
value: parseEther(stakeAmount),
```
- **parseEther('0.001')**: Converte "0.001 ETH" para "1000000000000000 wei"
- **Por que**: Blockchain trabalha com wei (menor unidade)

#### âœ… **Hook 4: useCompleteTask() - O "Finalizador"**

```typescript
export function useCompleteTask() {
  const { writeContract, isPending, error } = useWriteContract()
  
  const completeTask = async (taskId: number) => {
    await writeContract({
      address: CONTRACT_ADDRESS,
      abi: CONTRACT_ABI,
      functionName: 'completeTask',
      args: [BigInt(taskId)],
    })
  }
  
  return { completeTask, isPending, error }
}
```

**ğŸ“– ExplicaÃ§Ã£o detalhada:**

**ğŸ¯ FunÃ§Ã£o simples e direta:**
- **ParÃ¢metro**: SÃ³ precisa do ID da tarefa
- **BigInt(taskId)**: Converte nÃºmero JavaScript para formato blockchain
- **Sem value**: NÃ£o envia ETH junto (apenas executa)

#### ğŸ”— **Hook 5: useWeb3Status() - O "Vigia da ConexÃ£o"**

```typescript
export function useWeb3Status() {
  const { address, isConnected } = useAccount()
  return {
    address,
    isConnected,
    shortAddress: address ? `${address.slice(0, 6)}...${address.slice(-4)}` : null
  }
}
```

**ğŸ“– ExplicaÃ§Ã£o detalhada:**

**ğŸ“ FormataÃ§Ã£o de endereÃ§o:**
```typescript
shortAddress: address ? `${address.slice(0, 6)}...${address.slice(-4)}` : null
```
- **address.slice(0, 6)**: Primeiros 6 caracteres "0x1a2b"
- **address.slice(-4)**: Ãšltimos 4 caracteres "c4d5"
- **Resultado**: "0x1a2b...c4d5" (mais fÃ¡cil de ler)

---

### ğŸ’» **Passo 4: Entendendo a PÃ¡gina Principal (page.tsx)**

Agora vamos dissecar o cÃ³digo da pÃ¡gina principal para entender como tudo se conecta:

#### **ğŸ“‹ Estrutura Geral do Componente**

```typescript
export default function Web3TodoPage() {
  const [showCreateModal, setShowCreateModal] = useState(false)
  
  // ğŸ”— Hooks Web3 ULTRA-SIMPLIFICADOS
  const { connectors, connect } = useConnect()
  const { disconnect } = useDisconnect()
  const { isConnected, shortAddress } = useWeb3Status()
  const { refetchBalance } = useContractBalance()
  const chainId = useChainId()
  
  // ğŸš€ UM ÃšNICO HOOK para tudo: mÃ©tricas + tarefas + dados
  const {
    total, concluidas, pendentes, weiInStake, tasks,
    isLoading: loadingTasks, refetch: refetchTasks
  } = useTaskMetrics()
}
```

**ğŸ“– ExplicaÃ§Ã£o detalhada dos hooks:**

#### **ğŸ”Œ Hooks de ConexÃ£o**

```typescript
const { connectors, connect } = useConnect()
const { disconnect } = useDisconnect()
```
- **connectors**: Lista de carteiras disponÃ­veis (MetaMask, WalletConnect, etc.)
- **connect()**: FunÃ§Ã£o para conectar uma carteira especÃ­fica
- **disconnect()**: FunÃ§Ã£o para desconectar a carteira atual

#### **ğŸŒ Hook de VerificaÃ§Ã£o de Rede**

```typescript
const chainId = useChainId()
const isCorrectNetwork = chainId === sepolia.id
const networkName = chainId === sepolia.id ? 'Sepolia' : `Rede ${chainId}`
```
- **chainId**: ID numÃ©rico da rede atual (Sepolia = 11155111)
- **isCorrectNetwork**: `true` se estÃ¡ na Sepolia, `false` se nÃ£o
- **networkName**: Nome amigÃ¡vel da rede para exibir na interface

#### **ğŸ¯ Hook Central - useTaskMetrics()**

```typescript
const {
  total, concluidas, pendentes, weiInStake, tasks,
  isLoading: loadingTasks, refetch: refetchTasks
} = useTaskMetrics()
```

**ğŸš€ Este Ã© o hook MAIS IMPORTANTE! Ele faz TUDO:**

- **total**: Quantidade total de tarefas
- **concluidas**: Quantidade de tarefas concluÃ­das
- **pendentes**: Quantidade de tarefas pendentes  
- **weiInStake**: Valor total apostado em ETH
- **tasks**: Array com dados completos de todas as tarefas
- **loadingTasks**: `true` = carregando dados da blockchain
- **refetchTasks**: FunÃ§Ã£o para buscar dados novamente

#### **ğŸ”„ FunÃ§Ã£o de Conectar/Desconectar Carteira**

```typescript
const handleConnectWallet = () => {
  if (isConnected) {
    disconnect()
  } else {
    const metamask = connectors.find(c => c.name === 'MetaMask')
    if (metamask) connect({ connector: metamask })
  }
}
```

**ğŸ“– Passo a passo:**

1. **Verifica se jÃ¡ estÃ¡ conectado**: `if (isConnected)`
2. **Se conectado**: Chama `disconnect()` para desconectar
3. **Se nÃ£o conectado**: Procura MetaMask na lista de conectores
4. **Se encontrou MetaMask**: Chama `connect()` para conectar

#### **ğŸ”„ FunÃ§Ã£o de Atualizar Dados**

```typescript
const handleRefresh = async () => {
  await Promise.all([refetchTasks(), refetchBalance()])
}
```

**ğŸ“– O que faz:**
- **refetchTasks()**: Busca tarefas novamente na blockchain
- **refetchBalance()**: Atualiza saldo do contrato
- **Promise.all()**: Executa ambas ao mesmo tempo (mais rÃ¡pido)
- **async/await**: Aguarda terminar antes de continuar

#### **ğŸ¨ Estrutura Visual da Interface**

```typescript
return (
  <TooltipProvider>
    <div className="min-h-screen bg-gray-50 text-gray-900">
      <main className="container mx-auto p-4 sm:p-6 lg:p-8">
        {/* ğŸ¯ CABEÃ‡ALHO */}
        <header className="mb-8">
          {/* TÃ­tulo + BotÃ£o de conectar */}
        </header>

        {/* ğŸ“Š SEÃ‡ÃƒO DE MÃ‰TRICAS */}
        <section className="mb-10">
          {/* 4 cards com estatÃ­sticas */}
        </section>

        {/* ğŸ“‹ SEÃ‡ÃƒO DE TAREFAS */}
        <section>
          {/* Lista de tarefas + botÃ£o nova tarefa */}
        </section>
      </main>
    </div>
  </TooltipProvider>
)
```

#### **âš¡ RenderizaÃ§Ã£o Condicional Inteligente**

**ğŸ” Para o carregamento:**
```typescript
{loadingTasks && isConnected ? (
  <div className="text-center p-8">
    <Loader className="animate-spin h-8 w-8 mx-auto mb-4" />
    <p>Carregando tarefas da blockchain...</p>
  </div>
) : /* ... outras condiÃ§Ãµes */ }
```

**ğŸ“ Para lista vazia:**
```typescript
(!tasks || tasks.length === 0) && isConnected ? (
  <div className="text-center p-8">
    <p className="text-gray-500">VocÃª ainda nÃ£o tem tarefas. Crie sua primeira!</p>
  </div>
) : /* ... outras condiÃ§Ãµes */
```

**ğŸ“‹ Para lista de tarefas:**
```typescript
isConnected && tasks ? (
  tasks.map((task: any) => (
    <TaskItem 
      key={Number(task.id)} 
      task={task}
      isConnected={isConnected}
      onTaskUpdate={refetchTasks}
    />
  ))
) : null
```

**ğŸš« Para usuÃ¡rio desconectado:**
```typescript
{!isConnected && (
  <div className="text-center p-8">
    <AlertCircle className="h-12 w-12 mx-auto mb-4 text-gray-400" />
    <p className="text-gray-500">Conecte sua carteira para ver suas tarefas</p>
  </div>
)}
```

#### **ğŸ”„ Por que o wagmi otimiza automaticamente**

**ğŸ§  OtimizaÃ§Ãµes automÃ¡ticas do wagmi:**
- **Cache automÃ¡tico**: NÃ£o refaz chamadas desnecessÃ¡rias  
- **InvalidaÃ§Ã£o inteligente**: SÃ³ atualiza quando blockchain muda
- **Batching**: Agrupa mÃºltiplas atualizaÃ§Ãµes em uma sÃ³
- **Background refetch**: Atualiza dados quando necessÃ¡rio

#### **ğŸ“Š Fluxo Completo de Dados:**

```
ğŸ‘¤ USUÃRIO conecta carteira
    â†“
ğŸ£ useTaskMetrics() â†’ useAllUserTasks() 
    â†“
ğŸ“¡ Chama getUserTasksWithData() na blockchain
    â†“
ğŸª Smart Contract retorna dados completos
    â†“
ğŸ§® useTaskMetrics() calcula estatÃ­sticas
    â†“
ğŸ’» Componente renderiza interface
    â†“
ğŸ‘¤ USUÃRIO vÃª: total, concluÃ­das, pendentes, lista de tarefas

ğŸ‘¤ USUÃRIO cria nova tarefa
    â†“
âš¡ TransaÃ§Ã£o Ã© minerada na blockchain
    â†“
ğŸ“¡ wagmi detecta mudanÃ§a automaticamente
    â†“
ğŸ”„ useTaskMetrics() busca dados atualizados
    â†“
ğŸ’» Interface atualiza sozinha! âœ¨
```

#### **ğŸ¨ Componente MetricCard**

```typescript
function MetricCard({ title, value, icon, tooltip }) {
  const content = (
    <Card className="transition-shadow duration-300 hover:shadow-lg cursor-pointer">
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium text-gray-500">{title}</CardTitle>
        {icon}
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
      </CardContent>
    </Card>
  )

  // Se tem tooltip, envolve com Tooltip
  if (tooltip) {
    return (
      <Tooltip>
        <TooltipTrigger asChild>{content}</TooltipTrigger>
        <TooltipContent><p>{tooltip}</p></TooltipContent>
      </Tooltip>
    )
  }

  return content
}
```

**ğŸ“– CaracterÃ­sticas do MetricCard:**
- **ReutilizÃ¡vel**: Usado para todos os 4 cards de mÃ©tricas
- **Hover effect**: Sombra aparece quando passa mouse
- **Tooltip opcional**: Mostra explicaÃ§Ã£o se fornecida
- **Layout flexÃ­vel**: Ãcone Ã  direita, texto Ã  esquerda

---

### ğŸ§© **Passo 6: Componentes Auxiliares**

#### **ğŸ“ TaskItem Component**

O `TaskItem` Ã© responsÃ¡vel por exibir cada tarefa individual:

```typescript
<TaskItem 
  key={Number(task.id)} 
  task={task}                    // Dados completos da tarefa
  isConnected={isConnected}      // Se carteira estÃ¡ conectada
  onTaskUpdate={refetchTasks}    // Callback para atualizar lista
/>
```

**ğŸ”— Props explicadas:**
- **task**: Objeto com todos os dados da tarefa (id, title, description, status, etc.)
- **isConnected**: Permite/bloqueia aÃ§Ãµes baseadas na conexÃ£o
- **onTaskUpdate**: FunÃ§Ã£o chamada apÃ³s completar tarefa (atualiza a lista)

#### **ğŸ“ CreateTaskModal Component**

Modal para criar novas tarefas:

```typescript
<CreateTaskModal 
  open={showCreateModal}                    // Se modal estÃ¡ aberto
  onClose={() => setShowCreateModal(false)} // FunÃ§Ã£o para fechar
/>
```

**ğŸ¯ Funcionalidades:**
- **FormulÃ¡rio controlado**: Todos inputs sÃ£o controlados por estado
- **ValidaÃ§Ã£o**: Impede envio com dados invÃ¡lidos
- **Loading state**: Mostra "Criando..." durante transaÃ§Ã£o
- **Auto-reset**: Limpa formulÃ¡rio apÃ³s sucesso

---

### ğŸ§ª **Passo 6: Testando a IntegraÃ§Ã£o**

#### **ğŸ“‹ Checklist de Teste Essencial**

**ğŸ”Œ Conectividade:**
- [ ] BotÃ£o "Conectar Carteira" funciona
- [ ] MetaMask abre e solicita conexÃ£o
- [ ] EndereÃ§o aparece no cabeÃ§alho
- [ ] Indicador mostra rede "Sepolia"

**ğŸ“Š Funcionalidades:**
- [ ] Modal "Nova Tarefa" abre
- [ ] TransaÃ§Ãµes sÃ£o assinadas no MetaMask
- [ ] Lista de tarefas atualiza automaticamente
- [ ] BotÃ£o "Atualizar" funciona

#### **ğŸš¨ Problemas Comuns**

**âŒ "Contract not found"**
- Verifique `CONTRACT_ADDRESS` no `lib/web3.ts`
- Confirme no Etherscan: https://sepolia.etherscan.io/address/SEU_ENDERECO

**âŒ "Wrong network"**
- MetaMask deve estar conectado Ã  rede Sepolia
- Chain ID deve ser 11155111

**âŒ "Insufficient funds"**
- Use faucet Sepolia: https://sepoliafaucet.com/

---

### ğŸš€ **Passo 7: Deploy e ProduÃ§Ã£o**

#### **ğŸ“¦ Build da AplicaÃ§Ã£o**

```bash
# Verificar se tudo compila
pnpm build

# Testar build localmente
pnpm start
```

#### **ğŸŒ Deploy no Vercel**

```bash
# Conectar repositÃ³rio ao Vercel
# Configurar variÃ¡veis de ambiente:
# - NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID
# - NEXT_PUBLIC_ALCHEMY_API_KEY
```

#### **âš™ï¸ VariÃ¡veis de Ambiente**

```env
# .env.local (para produÃ§Ã£o)
NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID=seu_project_id
NEXT_PUBLIC_ALCHEMY_API_KEY=sua_alchemy_key
```

**ğŸ”‘ Por que NEXT_PUBLIC_:**
- VariÃ¡veis com `NEXT_PUBLIC_` ficam disponÃ­veis no browser
- NecessÃ¡rio para bibliotecas Web3 funcionarem no frontend

---

### ğŸ¯ **Resumo Final: O que Conquistamos**

**âœ… Sistema Completo Funcionando:**

1. **ğŸ”Œ ConexÃ£o**: MetaMask conecta no nosso site
2. **ğŸ“ CriaÃ§Ã£o**: UsuÃ¡rio cria tarefas que vÃ£o para blockchain
3. **ğŸ“Š VisualizaÃ§Ã£o**: Dados atualizados em tempo real
4. **âœ… InteraÃ§Ã£o**: Completar tarefas com transaÃ§Ãµes reais
5. **ğŸ’° Stakes**: Sistema financeiro com ETH real (testnet)
6. **ğŸ”„ SincronizaÃ§Ã£o**: Interface atualiza automaticamente
7. **ğŸ›¡ï¸ ValidaÃ§Ã£o**: VerificaÃ§Ã£o de rede e estados

**ğŸ§© Arquitetura Final Integrada:**

```
ğŸ‘¤ USUÃRIO
    â†“ clica "Criar Tarefa"
ğŸ’» COMPONENTE CreateTaskModal
    â†“ chama useCreateTask()
ğŸ£ HOOK useCreateTask  
    â†“ usa writeContract()
âš¡ VIEM + WAGMI
    â†“ traduz e envia para blockchain
ğŸ¦Š METAMASK
    â†“ usuÃ¡rio assina transaÃ§Ã£o
ğŸŒ SEPOLIA BLOCKCHAIN
    â†“ executa createTask() no smart contract
ğŸ“¡ EVENTO TaskCreated
    â†“ wagmi detecta automaticamente
ğŸ”„ CACHE INVALIDATION
    â†“ useTaskMetrics() busca dados novos
ğŸ“Š MÃ‰TRICAS RECALCULADAS
    â†“ componente re-renderiza
ğŸ’» INTERFACE ATUALIZADA
    â†“ nova tarefa aparece na lista
ğŸ‘¤ USUÃRIO vÃª resultado instantÃ¢neo! âœ¨
```

**ğŸ¯ Funcionalidades Implementadas:**

- âœ… **ConexÃ£o de Carteira**: MetaMask, WalletConnect
- âœ… **VerificaÃ§Ã£o de Rede**: ForÃ§a uso da Sepolia
- âœ… **GestÃ£o de Estado**: Cache inteligente com wagmi
- âœ… **TransaÃ§Ãµes**: Criar e completar tarefas
- âœ… **MÃ©tricas Tempo Real**: EstatÃ­sticas automÃ¡ticas
- âœ… **Interface Responsiva**: Funciona em mobile/desktop
- âœ… **Loading States**: Feedback visual durante operaÃ§Ãµes
- âœ… **Error Handling**: Tratamento de erros de rede
- âœ… **Tooltips Informativos**: ExplicaÃ§Ãµes contextuais
- âœ… **Sistema de Refresh**: AtualizaÃ§Ã£o manual quando necessÃ¡rio

**ğŸš€ Seu app agora Ã© um DApp completo!**

- âœ… **D**ecentralized: Roda na blockchain Ethereum
- âœ… **A**pplication: Interface moderna e intuitiva  
- âœ… **P**rotocol: Smart contract com regras automÃ¡ticas

**ğŸ“ Conhecimentos Adquiridos:**

- ğŸ”§ **IntegraÃ§Ã£o Web3**: Como conectar React com blockchain
- ğŸ£ **Hooks Customizados**: OrganizaÃ§Ã£o e reutilizaÃ§Ã£o de lÃ³gica
- âš¡ **OtimizaÃ§Ã£o**: Cache automÃ¡tico e performance
- ğŸ”„ **Estado Reativo**: AtualizaÃ§Ãµes automÃ¡ticas de dados
- ğŸ›¡ï¸ **ValidaÃ§Ãµes**: VerificaÃ§Ã£o de rede e estados
- ğŸ¨ **UX Web3**: ExperiÃªncia de usuÃ¡rio em DApps
- ğŸ“¡ **ComunicaÃ§Ã£o Blockchain**: Leitura e escrita de contratos

---

## ğŸ‰ **ConclusÃ£o da Aula 3**

**ğŸ† ParabÃ©ns! VocÃª construiu um DApp completo do zero!**

**âœ… Jornada Conquistada:**

1. **ğŸ—ï¸ Smart Contract**: Criou e deployou na blockchain Sepolia
2. **ğŸ£ Hooks Organizados**: Desenvolveu lÃ³gica Web3 reutilizÃ¡vel
3. **ğŸ”— ConfiguraÃ§Ã£o Web3**: Conectou frontend com blockchain via wagmi
4. **ğŸ’» Interface Integrada**: Implementou UI moderna com funcionalidades Web3
5. **âš¡ Performance Otimizada**: Cache automÃ¡tico e atualizaÃ§Ãµes em tempo real
6. **ğŸ§ª Sistema Testado**: Validou todas as funcionalidades essenciais

**ğŸ§© Stack TecnolÃ³gica Dominada:**
- **Frontend**: Next.js 15 + TypeScript + Tailwind CSS
- **UI Components**: shadcn/ui + Radix UI + Lucide Icons
- **Web3**: wagmi + viem + TanStack Query
- **Blockchain**: Ethereum Sepolia + Alchemy/Infura
- **Smart Contract**: Solidity + Foundry
- **Carteira**: MetaMask + WalletConnect

**ğŸš€ PrÃ³ximos Passos:**
- Deploy em produÃ§Ã£o no Vercel
- Migrar para mainnet Ethereum
- Adicionar novas funcionalidades (editÃ¡r tarefas, categorias, etc.)
- Implementar temas dark/light
- Adicionar notificaÃ§Ãµes push

**ğŸ“ VocÃª agora domina:**
- ğŸ£ **Hooks Customizados**: OrganizaÃ§Ã£o e reutilizaÃ§Ã£o de lÃ³gica Web3
- ğŸ”§ **ConfiguraÃ§Ã£o Wagmi**: Setup completo de provedores e conexÃµes
- âš¡ **Performance Web3**: Cache automÃ¡tico e otimizaÃ§Ãµes
- ğŸ’» **IntegraÃ§Ã£o Frontend**: React + TypeScript + Blockchain
- ğŸ§ª **Testes e Debug**: ValidaÃ§Ã£o de funcionalidades Web3
