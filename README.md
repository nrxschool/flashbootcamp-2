# Web3 todo interface

*Automatically synced with your [v0.dev](https://v0.dev) deployments*

[![Deployed on Vercel](https://img.shields.io/badge/Deployed%20on-Vercel-black?style=for-the-badge&logo=vercel)](https://vercel.com/manoelgomesdevs-projects/v0-web3-todo-interface)
[![Built with v0](https://img.shields.io/badge/Built%20with-v0.dev-black?style=for-the-badge)](https://v0.dev/chat/projects/Tw7JzfnvoEm)

## Overview

This repository will stay in sync with your deployed chats on [v0.dev](https://v0.dev).
Any changes you make to your deployed app will be automatically pushed to this repository from [v0.dev](https://v0.dev).

## Deployment

Your project is live at:

**[https://vercel.com/manoelgomesdevs-projects/v0-web3-todo-interface](https://vercel.com/manoelgomesdevs-projects/v0-web3-todo-interface)**

## Build your app

Continue building your app on:

**[https://v0.dev/chat/projects/Tw7JzfnvoEm](https://v0.dev/chat/projects/Tw7JzfnvoEm)**

## How It Works

1. Create and modify your project using [v0.dev](https://v0.dev)
2. Deploy your chats from the v0 interface
3. Changes are automatically pushed to this repository
4. Vercel deploys the latest version from this repository

---

## ğŸ“š Aula 1

### ğŸš€ Prompt para criar seu Front com mais agilidade

```
WEB3 TODO â€” Interface de UsuÃ¡rio

O objetivo deste projeto Ã© desenvolver a interface de usuÃ¡rio do WEB3 TODO, um aplicativo de gerenciamento de tarefas com integraÃ§Ã£o Ã  tecnologia Web3. O sistema permitirÃ¡ que os usuÃ¡rios conectem sua carteira digital, criem e acompanhem tarefas, alÃ©m de visualizarem mÃ©tricas em tempo real, sempre priorizando a usabilidade e o design moderno.

A estrutura da interface Ã© dividida em trÃªs Ã¡reas principais:

1. CabeÃ§alho

Exibir no topo da pÃ¡gina um botÃ£o de destaque com o rÃ³tulo "Conectar Carteira".

Abaixo do botÃ£o, apresentar uma mensagem de alerta:
"Conecte sua carteira para gerenciar suas tarefas na blockchain."

O botÃ£o e a mensagem devem indicar visualmente o status da conexÃ£o com a carteira, facilitando o entendimento do usuÃ¡rio sobre o que estÃ¡ ou nÃ£o disponÃ­vel.

2. SeÃ§Ã£o de MÃ©tricas

Criar uma grade horizontal com quatro cards informativos:

Total de Tarefas

Tarefas ConcluÃ­das

Tarefas Pendentes

Wei em Stake

Cada card deve:

Utilizar cores que remetam Ã  tecnologia, como azul cobalto, ciano elÃ©trico e violeta digital.

Conter Ã­cones visuais que facilitem a leitura rÃ¡pida dos dados.

3. SeÃ§Ã£o de Tarefas

Exibir o tÃ­tulo da seÃ§Ã£o: "Tarefas".

Ao lado do tÃ­tulo, adicionar um botÃ£o destacado: "Nova Tarefa".

Exibir a lista de tarefas em formato de cards horizontais, contendo:

Nome da tarefa

Status: Pendente ou ConcluÃ­do

DescriÃ§Ã£o

Data de criaÃ§Ã£o

Data de conclusÃ£o (se aplicÃ¡vel)

Valor em wei associado

Ãcone de aÃ§Ã£o para "Concluir Tarefa" (sem ediÃ§Ã£o ou exclusÃ£o)

Os cards devem:

ReforÃ§ar visualmente as aÃ§Ãµes disponÃ­veis.

Diferenciar claramente tarefas pendentes e tarefas concluÃ­das.

Diretrizes de Design

Estilo Visual

Interface clean e moderna, com tema claro (light mode).

Aplicar a regra 60-30-10 para proporÃ§Ã£o de cores.

Utilizar no mÃ¡ximo duas cores principais.

Tipografia clara com hierarquia visual definida.

Design minimalista, com espaÃ§amento adequado.

Fornecer feedback visual para:

AÃ§Ãµes do usuÃ¡rio

Estados de carregamento

Erros ou validaÃ§Ãµes

Interface responsiva para se adaptar a diferentes dispositivos.

Clareza e ConsistÃªncia

Utilizar rÃ³tulos descritivos e Ã­cones intuitivos.

Manter coerÃªncia visual em:

Cores

Tamanhos

Fontes

EspaÃ§amentos

Destacar visualmente elementos que dependem da conexÃ£o da carteira.

Interatividade

Fornecer feedback imediato com animaÃ§Ãµes suaves.

Criar transiÃ§Ãµes fluidas entre os diferentes estados da interface.

BotÃµes devem apresentar estados visuais distintos:

Hover

Ativo

Desativado

Carregando

Acessibilidade

Garantir contraste de cores adequado.

Incluir textos alternativos (alt) para Ã­cones e imagens.

Permitir navegaÃ§Ã£o completa por teclado.

Evitar a comunicaÃ§Ã£o exclusiva por cor (ex: nÃ£o usar sÃ³ cor para indicar status).

ConsideraÃ§Ãµes Finais

A interface deve ser intuitiva e acessÃ­vel para iniciantes em Web3, deixando claro quando determinadas funcionalidades exigem a carteira conectada. Todos os elementos interativos devem responder com feedback visual, e a experiÃªncia deve manter consistÃªncia e fluidez em toda a jornada do usuÃ¡rio.
```

---

## ğŸ“ Aula 2

### ğŸ”— O que Ã© Blockchain Ethereum?

**Blockchain** Ã© como um **livro de registros digital** que funciona de forma descentralizada:

- **ğŸ“– Livro PÃºblico**: Todas as transaÃ§Ãµes ficam registradas e visÃ­veis para todos
- **ğŸ”’ ImutÃ¡vel**: Uma vez registrado, nÃ£o pode ser alterado ou apagado
- **ğŸŒ Descentralizado**: NÃ£o hÃ¡ uma autoridade central controlando
- **â›“ï¸ Em Blocos**: InformaÃ§Ãµes organizadas em "blocos" conectados em sequÃªncia

**Ethereum** Ã© uma blockchain especial que permite executar **programas** (smart contracts), nÃ£o apenas transferir dinheiro como o Bitcoin.

### ğŸ“‹ O que Ã© Smart Contract?

**Smart Contract** Ã© um **programa de computador** que roda na blockchain:

- **ğŸ¤– AutomÃ¡tico**: Executa sozinho quando as condiÃ§Ãµes sÃ£o atendidas
- **ğŸ“ CÃ³digo Ã© Lei**: As regras estÃ£o escritas em cÃ³digo e nÃ£o podem ser quebradas
- **ğŸ” Transparente**: Qualquer pessoa pode ver o cÃ³digo e verificar como funciona
- **ğŸ’° Lida com Dinheiro**: Pode receber, guardar e enviar criptomoedas

**Exemplo prÃ¡tico**: 
- VocÃª cria uma tarefa no nosso sistema
- Envia 0.001 ETH como "aposta" 
- Se completar no prazo = recebe o dinheiro de volta
- Se atrasar = perde o dinheiro
- Tudo acontece automaticamente, sem intermediÃ¡rios!

### â›½ O que Ã© "Gas"?

**Gas** Ã© a **"gasolina"** da blockchain Ethereum:

- **ğŸ’¸ Taxa de TransaÃ§Ã£o**: VocÃª paga para usar a blockchain
- **âš¡ Energia Computacional**: Quanto mais complexa a operaÃ§Ã£o, mais gas custa
- **ğŸ‘· Pagamento aos Mineradores**: Quem mantÃ©m a rede funcionando recebe essas taxas
- **ğŸš€ Velocidade**: Pagar mais gas = transaÃ§Ã£o mais rÃ¡pida

**Analogia simples**:
- Blockchain = Estrada
- Smart Contract = Destino  
- Gas = CombustÃ­vel para chegar lÃ¡
- Mais gas = Viagem mais rÃ¡pida, menos gas = Viagem mais lenta

**Exemplo de custos**:
- Criar tarefa: ~50,000 gas
- Completar tarefa: ~30,000 gas  
- Consultar dados: 0 gas (leitura Ã© grÃ¡tis!)

**ğŸ’¡ Dica**: Gas varia conforme a demanda da rede. Em horÃ¡rios de pico, fica mais caro!

### ğŸ’» Entendendo Solidity - A Linguagem dos Smart Contracts

**Solidity** Ã© como o **"idioma oficial"** para escrever contratos inteligentes no Ethereum.

#### ğŸŒ **Onde Solidity Ã© Usado?**

**Analogia**: Como **idiomas do mundo real**:

- **PortuguÃªs**: Usado no Brasil, Portugal, alguns paÃ­ses da Ãfrica
- **InglÃªs**: Usado nos EUA, Inglaterra, AustrÃ¡lia
- **Solidity**: Usado em **blockchains compatÃ­veis com Ethereum**

**Principais blockchains que "falam" Solidity**:
- ğŸ”· **Ethereum** (a blockchain original)
- ğŸŸ£ **Polygon** (mais rÃ¡pida e barata)
- ğŸŸ¡ **Binance Smart Chain** (BSC)
- ğŸ”µ **Avalanche** 
- âšª **Arbitrum** e **Optimism** (Layer 2 do Ethereum)

#### ğŸ“š **Conceitos BÃ¡sicos de Solidity**

#### ğŸ—ï¸ **1. Struct - O "FormulÃ¡rio PadrÃ£o"**

```solidity
struct Task {
    uint256 id;
    string title;
    bool isCompleted;
}
```

**Analogia**: Como **formulÃ¡rio de cadastro** mÃ©dico:

- **Struct** = O **modelo em branco** do formulÃ¡rio
- Cada struct define **exatamente quais campos** existem
- Ã‰ como dizer: "Todo paciente tem: Nome, CPF, Idade"
- **ReutilizÃ¡vel**: VocÃª pode preencher **milhares** de formulÃ¡rios iguais

**No nosso caso**:
- `Task` = Modelo do formulÃ¡rio de tarefa
- Toda tarefa **sempre** tem: id, tÃ­tulo, descriÃ§Ã£o, prazo, etc.
- Ã‰ como ter um **"carimbo"** que sempre cria fichas idÃªnticas

#### ğŸ’¾ **2. Memory vs Storage - "Caderno vs Arquivo"**

**Analogia**: Como **diferentes tipos de anotaÃ§Ã£o**:

**ğŸ“ Memory - "Rascunho"**:
```solidity
string memory tempTitle = "Estudar Solidity";
```
- Ã‰ como escrever num **papel rascunho**
- **TemporÃ¡rio**: Depois que a funÃ§Ã£o termina, some
- **RÃ¡pido**: NÃ£o custa muito gas
- **Uso**: Calculations, variÃ¡veis temporÃ¡rias

**ğŸ“ Storage - "Arquivo Permanente"**:
```solidity
Task storage task = tasks[1];  // Pegando uma tarefa jÃ¡ salva
task.isCompleted = true;       // Modificando permanentemente
```
- Ã‰ como escrever num **arquivo oficial**
- **Permanente**: Fica gravado na blockchain para sempre
- **Caro**: Custa mais gas (vocÃª estÃ¡ pagando pelo "papel oficial")
- **Uso**: Dados que precisam ser salvos

**Exemplo PrÃ¡tico**:
```solidity
function completeTask(uint256 _taskId) public {
    string memory message = "Completing task...";  // MEMORY (temporÃ¡rio)
    Task storage task = tasks[_taskId];             // STORAGE (permanente)
    task.isCompleted = true;                        // Modifica permanentemente
}
```

#### ğŸ”¢ **3. Tipos de Dados BÃ¡sicos**

**Analogia**: Como **tipos de gaveta** para guardar coisas:

```solidity
uint256 public totalTasks;           // Gaveta para NÃšMEROS (sempre positivos)
string public title;                 // Gaveta para TEXTO
bool public isCompleted;             // Gaveta para SIM/NÃƒO
address public creator;              // Gaveta para ENDEREÃ‡OS da blockchain
mapping(uint256 => Task) tasks;      // Gaveta para DICIONÃRIOS (chave â†’ valor)
```

- **`uint256`**: Como gaveta para **"nÃºmeros grandes positivos"** (0, 1, 2, 1000000...)
- **`string`**: Como gaveta para **"textos"** ("JoÃ£o", "Estudar Solidity")
- **`bool`**: Como gaveta para **"verdadeiro/falso"** (true/false, sim/nÃ£o)
- **`address`**: Como gaveta para **"CPF da blockchain"** (0x1a2b3c4d...)
- **`mapping`**: Como gaveta para **"agenda telefÃ´nica"** (nome â†’ telefone)

#### ğŸ›¡ï¸ **4. Modificadores de Visibilidade**

**Analogia**: Como **nÃ­veis de privacidade** numa empresa:

```solidity
uint256 public totalTasks;     // PÃšBLICO - Qualquer um pode ver
uint256 private secretData;    // PRIVADO - SÃ³ este contrato vÃª
uint256 internal teamData;     // INTERNO - SÃ³ "funcionÃ¡rios" (contratos filhos) veem
```

- **`public`**: Como **"mural da empresa"** - todo mundo pode ler
- **`private`**: Como **"cofre do diretor"** - sÃ³ o prÃ³prio contrato acessa
- **`internal`**: Como **"pasta da equipe"** - sÃ³ contratos "da famÃ­lia" acessam

#### âš¡ **5. Functions - As "MÃ¡quinas" do Contrato**

```solidity
function createTask(string memory _title) public payable returns (uint256) {
    // CÃ³digo aqui
    return newTaskId;
}
```

**Partes da funÃ§Ã£o**:
- **`function`**: "Esta Ã© uma mÃ¡quina"
- **`createTask`**: Nome da mÃ¡quina
- **`(string memory _title)`**: "Ingredientes" que vocÃª coloca na mÃ¡quina
- **`public`**: "Qualquer um pode usar esta mÃ¡quina"
- **`payable`**: "Esta mÃ¡quina aceita dinheiro"
- **`returns (uint256)`**: "Esta mÃ¡quina devolve um nÃºmero"

### ğŸ”¨ Framework Foundry - A "Oficina Profissional"

**Foundry** Ã© como uma **oficina mecÃ¢nica completa** para desenvolver smart contracts.

#### ğŸ¯ **Por que Foundry Ã© Especial?**

**Analogia**: Comparando **oficinas**:

**ğŸ”§ Oficina Antiga (Remix, Truffle)**:
- Como oficina de **"fundo de quintal"**
- Ferramentas bÃ¡sicas
- Tudo manual e lento
- DifÃ­cil de organizar projetos grandes

**ğŸ­ Foundry - "Oficina da Mercedes"**:
- Como oficina **profissional de montadora**
- Ferramentas de Ãºltima geraÃ§Ã£o
- Tudo automatizado e rÃ¡pido
- OrganizaÃ§Ã£o industrial

#### âš™ï¸ **Ferramentas do Foundry**

**1. ğŸ”¨ Forge - O "Martelo Inteligente"**:
```bash
forge build    # ConstrÃ³i o contrato
forge test     # Testa todas as funcionalidades
forge deploy   # Coloca na blockchain
```
- **Analogia**: Como **robÃ´ de montagem** que faz tudo automaticamente

**2. ğŸ“Š Cast - O "Medidor Universal"**:
```bash
cast call 0x... "totalTasks()"  # Consulta dados do contrato
cast send 0x... "createTask()"  # Executa funÃ§Ã£o
```
- **Analogia**: Como **multÃ­metro profissional** que mede qualquer coisa

**3. âš¡ Anvil - A "Bancada de Teste"**:
```bash
anvil  # Cria blockchain local para testes
```
- **Analogia**: Como **bancada com todos os equipamentos** para testar peÃ§as

#### ğŸš€ **Vantagens do Foundry**

**1. ğŸƒâ€â™‚ï¸ Velocidade Extrema**:
- **Testes rodam em milissegundos** (vs. segundos em outras ferramentas)
- Como comparar **Ferrari vs. bicicleta**

**2. ğŸ§ª Testes em Solidity**:
- VocÃª escreve testes **na mesma linguagem** do contrato
- Como mecÃ¢nico **usar as mesmas ferramentas** para construir e testar

**3. ğŸ“¦ GestÃ£o de DependÃªncias**:
```bash
forge install OpenZeppelin/openzeppelin-contracts
```
- Como **loja de auto-peÃ§as integrada** na oficina

**4. ğŸ” Debugging AvanÃ§ado**:
- Mostra **exatamente onde** o erro aconteceu
- Como **raio-X** que mostra problema interno

**5. â›½ AnÃ¡lise de Gas**:
- Calcula **exatamente quanto** cada funÃ§Ã£o custa
- Como **calculadora de combustÃ­vel** precisa

#### ğŸ“¦ **InstalaÃ§Ã£o do Foundry - "Montando sua Oficina"**

**Analogia**: Como **montar uma oficina profissional** em casa - vocÃª precisa das ferramentas certas!

#### ğŸ”§ **PrÃ©-requisitos (O que vocÃª precisa ter)**

**1. ğŸ’» Sistema Operacional CompatÃ­vel**:
- âœ… **Linux** (recomendado)
- âœ… **macOS** 
- âœ… **Windows** (via WSL - Windows Subsystem for Linux)

**Analogia**: Como verificar se sua **garagem tem espaÃ§o** para a oficina.

**2. ğŸ¦€ Rust (Linguagem de ProgramaÃ§Ã£o)**:
- Foundry Ã© escrito em **Rust**
- Ã‰ como o **"motor"** que faz tudo funcionar

**3. ğŸ“‹ Git (Controle de VersÃ£o)**:
- Para baixar bibliotecas e gerenciar cÃ³digo
- Como o **"sistema de entrega"** da oficina

#### ğŸš€ **InstalaÃ§Ã£o Passo a Passo**

#### **MÃ©todo 1: InstalaÃ§Ã£o AutomÃ¡tica (Recomendado)**

**1. ğŸ“¥ Instalar Foundry com um comando:**

```bash
curl -L https://foundry.paradigm.xyz | bash
```

**Analogia**: Como **"kit de oficina automÃ¡tico"** - um caminhÃ£o chega e instala tudo de uma vez!

**2. ğŸ”„ Reiniciar o terminal ou executar:**

```bash
source ~/.bashrc
```

**3. ğŸ“¦ Instalar as ferramentas:**

```bash
foundryup
```

**Analogia**: Como **"ligar todas as mÃ¡quinas"** da oficina pela primeira vez.

#### **MÃ©todo 2: InstalaÃ§Ã£o Manual (Para UsuÃ¡rios AvanÃ§ados)**

```bash
# 1. Instalar Rust (se nÃ£o tiver)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 2. Instalar Foundry via Cargo (gerenciador do Rust)
cargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked
```

#### **Para Windows (WSL)**

**1. ğŸªŸ Instalar WSL primeiro:**

```powershell
wsl --install Ubuntu
```

**2. ğŸ§ Dentro do WSL, seguir os passos do Linux:**

```bash
curl -L https://foundry.paradigm.xyz | bash
foundryup
```

**Analogia**: Como **"construir uma oficina dentro do porÃ£o"** (WSL Ã© como o porÃ£o do Windows).

#### âœ… **Verificando se Funcionou**

**Teste se as ferramentas estÃ£o instaladas:**

```bash
forge --version    # Deve mostrar versÃ£o do Forge
cast --version     # Deve mostrar versÃ£o do Cast  
anvil --version    # Deve mostrar versÃ£o do Anvil
```

**Analogia**: Como **"testar se todas as mÃ¡quinas ligam"** na sua nova oficina.

#### ğŸ› ï¸ **Criando seu Primeiro Projeto**

```bash
# 1. Criar novo projeto
forge init meu-primeiro-contrato

# 2. Entrar na pasta
cd meu-primeiro-contrato

# 3. Compilar contratos de exemplo
forge build

# 4. Rodar testes
forge test
```

**Estrutura criada automaticamente:**
```
meu-primeiro-contrato/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ Counter.sol           # Contrato de exemplo
â”œâ”€â”€ test/
â”‚   â””â”€â”€ Counter.t.sol         # Teste de exemplo
â”œâ”€â”€ script/
â”‚   â””â”€â”€ Counter.s.sol         # Script de deploy
â”œâ”€â”€ foundry.toml              # ConfiguraÃ§Ãµes
â””â”€â”€ lib/                      # Bibliotecas (vazio inicialmente)
```

**Analogia**: Como receber uma **"oficina prÃ©-montada"** com tudo organizado e um projeto de exemplo para vocÃª comeÃ§ar!

#### ğŸš¨ **Problemas Comuns e SoluÃ§Ãµes**

**1. ğŸ’£ "command not found: forge"**

**SoluÃ§Ã£o**: Reiniciar terminal ou executar:
```bash
source ~/.bashrc
# ou
source ~/.zshrc
```

**2. ğŸŒ InstalaÃ§Ã£o muito lenta**

**SoluÃ§Ã£o**: Usar um VPN ou tentar em horÃ¡rio diferente:
```bash
# Usar proxy se necessÃ¡rio
export https_proxy=http://proxy:port
```

**3. ğŸªŸ Problemas no Windows**

**SoluÃ§Ã£o**: Instalar WSL2:
```powershell
# No PowerShell como administrador
wsl --install
wsl --set-default-version 2
```

#### ğŸ’¡ **Dicas Pro**

**1. ğŸ”„ Manter Atualizado:**
```bash
foundryup  # Atualiza para a versÃ£o mais recente
```

**2. ğŸ“š Instalar Bibliotecas Ãšteis:**
```bash
# OpenZeppelin (biblioteca de seguranÃ§a)
forge install OpenZeppelin/openzeppelin-contracts

# Solmate (biblioteca otimizada)
forge install transmissions11/solmate
```

**3. âš™ï¸ Configurar VS Code:**
- Instalar extensÃ£o "Solidity"
- Configurar para usar Foundry como formatter

**Analogia**: Como **"personalizar sua oficina"** com ferramentas extras e organizaÃ§Ã£o prÃ³pria!

#### ğŸ’¼ **Foundry vs. Outras Ferramentas**

| CaracterÃ­stica | Foundry | Hardhat | Remix |
|---|---|---|---|
| **Velocidade** | ğŸï¸ Ferrari | ğŸš— Carro normal | ğŸš² Bicicleta |
| **Linguagem dos testes** | Solidity | JavaScript | Manual |
| **InstalaÃ§Ã£o** | 1 comando | ConfiguraÃ§Ã£o complexa | Browser |
| **Para iniciantes** | ğŸ“š Curva de aprendizado | ğŸ˜Š Mais fÃ¡cil | ğŸ¯ Muito simples |
| **Para profissionais** | ğŸ‘‘ PadrÃ£o da indÃºstria | âœ… Boa opÃ§Ã£o | âŒ Limitado |

#### ğŸ—ï¸ **Estrutura de Projeto Foundry**

```
meu-projeto/
â”œâ”€â”€ src/           # Contratos principais
â”œâ”€â”€ test/          # Testes
â”œâ”€â”€ script/        # Scripts de deploy  
â”œâ”€â”€ lib/           # Bibliotecas externas
â””â”€â”€ foundry.toml   # ConfiguraÃ§Ãµes
```

**Analogia**: Como **organizaÃ§Ã£o de oficina profissional**:
- `src/` = **"Ãrea de montagem"** (onde vocÃª constrÃ³i)
- `test/` = **"Ãrea de testes"** (onde vocÃª verifica qualidade)
- `script/` = **"Manuais de procedimento"** (como fazer deploy)
- `lib/` = **"Estoque de peÃ§as"** (bibliotecas de terceiros)

**ğŸ¯ ConclusÃ£o**: Foundry Ã© como **"evoluir de oficina caseira para fÃ¡brica da Tesla"** - mais profissional, mais rÃ¡pido, mais confiÃ¡vel!

### ğŸ“ Anatomia do Smart Contract TaskManager

Imagine que vamos construir uma **fÃ¡brica de gerenciamento de tarefas** na blockchain. Vamos dissecar cada peÃ§a desta mÃ¡quina:

#### ğŸ—ï¸ **Estrutura BÃ¡sica do Contrato - A "CertidÃ£o de Nascimento"**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract TaskManager {
    // CÃ³digo do contrato aqui
}
```

**Analogia**: Ã‰ como o **cabeÃ§alho de um documento oficial**:

- **`SPDX-License-Identifier: MIT`**: Como uma **"licenÃ§a de uso"** - MIT significa "qualquer um pode usar gratuitamente"
  - Ã‰ como colocar "DomÃ­nio PÃºblico" numa mÃºsica
  
- **`pragma solidity ^0.8.13`**: Define a **"versÃ£o do idioma"** que estamos falando
  - Como dizer "este documento estÃ¡ escrito em PortuguÃªs versÃ£o 2024"
  - `^0.8.13` = "versÃ£o 8.13 ou mais nova, mas nÃ£o versÃ£o 9"
  
- **`contract TaskManager`**: Ã‰ o **nome da nossa empresa/fÃ¡brica**
  - Como "Papelaria JoÃ£o" ou "Padaria do Seu JosÃ©"

#### ğŸ’ **VariÃ¡veis e Constantes - As "Regras da Casa"**

```solidity
uint256 public constant MINIMUM_STAKE = 0.001 ether;
uint256 public totalTasks;
```

**Analogia**: Como **regras afixadas na parede** de um estabelecimento:

- **`MINIMUM_STAKE = 0.001 ether`**: Ã‰ o **"preÃ§o mÃ­nimo da entrada"**
  - Como uma placa: "Taxa mÃ­nima: R$ 5,00"
  - `constant` = Esta regra **NUNCA muda** (como "gravada em pedra")
  - `public` = **Todos podem ver** esta regra (estÃ¡ na parede para todos lerem)
  - `uint256` = Tipo de nÃºmero (sempre positivo, muito grande)
  
- **`totalTasks`**: Ã‰ o **"contador da porta"** daqueles cinemas
  - Conta quantas pessoas (tarefas) jÃ¡ entraram
  - ComeÃ§a em 0 e vai aumentando: 1, 2, 3, 4...
  - Ã‰ como um **"odÃ´metro" de tarefas criadas**

#### ğŸ“‹ **Struct Task - Nossa "Ficha de Cadastro"**

```solidity
struct Task {
    uint256 id;           // Identificador Ãºnico
    string title;         // TÃ­tulo da tarefa
    string description;   // DescriÃ§Ã£o detalhada
    uint256 createdAt;    // Quando foi criada (timestamp)
    uint256 deadline;     // Prazo limite (timestamp)
    bool isCompleted;     // Se foi concluÃ­da (true/false)
    address creator;      // Quem criou a tarefa
    uint256 stake;        // Valor apostado em wei
    bool stakeProcessed;  // Se o stake jÃ¡ foi processado
}
```

**Analogia**: Ã‰ como uma **ficha de cadastro mÃ©dico completa**:

- **`id`**: NÃºmero da **carteirinha do paciente** (Ãºnico, nunca repete)
- **`title`**: **Nome do tratamento** ("Consulta cardiolÃ³gica")
- **`description`**: **Detalhes do procedimento** ("Exame completo do coraÃ§Ã£o")
- **`createdAt`**: **Data de abertura da ficha** (quando foi criado o cadastro)
- **`deadline`**: **Data da consulta marcada** (prazo para completar)
- **`isCompleted`**: **"Paciente compareceu?"** (âœ… Sim / âŒ NÃ£o)
- **`creator`**: **EndereÃ§o de quem fez o agendamento** (CPF da pessoa)
- **`stake`**: **Valor da consulta** (quanto foi pago)
- **`stakeProcessed`**: **"Pagamento foi processado?"** (evita cobrar duas vezes)

**Por que struct?** Ã‰ como ter um **"formulÃ¡rio padrÃ£o"** - toda tarefa tem exatamente os mesmos campos preenchidos!

#### ğŸ—ºï¸ **Mappings - Nossos "Arquivos Organizados"**

```solidity
mapping(uint256 => Task) public tasks;
mapping(address => uint256[]) public userTasks;
```

**Analogia**: Como **dois sistemas de arquivo diferentes**:

**1. `tasks` - O "Arquivo Geral por NÃºmero"**
- Ã‰ como um **arquivo mÃ©dico por nÃºmero de protocolo**
- VocÃª fala: "Quero ver a ficha nÃºmero 1" â†’ Recebe todos os dados da Tarefa 1
- `uint256` = nÃºmero da tarefa (1, 2, 3...)
- `Task` = ficha completa com todos os dados
- Ã‰ como uma **gaveta numerada**: Gaveta 1 = Ficha 1, Gaveta 2 = Ficha 2...

**2. `userTasks` - O "Ãndice por Pessoa"**
- Ã‰ como um **caderno de "quem tem consulta marcada"**
- VocÃª fala: "Quais sÃ£o as consultas do JoÃ£o?" â†’ Recebe: [1, 5, 8] (nÃºmeros das fichas dele)
- `address` = "CPF" da pessoa na blockchain (0x1a2b3c4d...)
- `uint256[]` = lista de nÃºmeros das tarefas daquela pessoa

**Exemplo prÃ¡tico**:
- JoÃ£o criou 3 tarefas (IDs: 1, 3, 5)
- Maria criou 2 tarefas (IDs: 2, 4)
- `tasks[1]` = dados completos da tarefa 1 (do JoÃ£o)
- `userTasks[JoÃ£o]` = [1, 3, 5] (lista das tarefas do JoÃ£o)

#### ğŸ“¢ **Eventos - O "Jornal da Empresa"**

```solidity
event TaskCreated(uint256 taskId, address creator, string title, uint256 deadline, uint256 stake);
event TaskCompleted(uint256 taskId, address creator, uint256 stakeReturned);
event StakeLost(uint256 taskId, address creator, uint256 stakeLost);
```

**Analogia**: Como **manchetes de jornal que ficam arquivadas para sempre**:

**ğŸ” Por que eventos?**
- A blockchain Ã© como um **"cofre fechado"** - vocÃª nÃ£o pode "bisbilhotar" o que estÃ¡ dentro
- Eventos sÃ£o como **"recortes de jornal"** que saem do cofre e ficam acessÃ­veis
- Ã‰ uma forma de **"avisar o mundo exterior"** o que aconteceu

**ğŸ“° Nossos "tipos de notÃ­cia"**:

**1. `TaskCreated` - "Nascimentos"**
- **Manchete**: "Nova tarefa foi criada!"
- **Detalhes**: ID da tarefa, quem criou, tÃ­tulo, prazo, quanto apostou
- Como anunciar: "FamÃ­lia Silva teve um bebÃª! Nome: JoÃ£o, nasceu dia 15/03"

**2. `TaskCompleted` - "Sucessos"**
- **Manchete**: "Tarefa concluÃ­da no prazo!"
- **Detalhes**: Qual tarefa, quem completou, quanto dinheiro recebeu de volta
- Como anunciar: "JoÃ£o Silva se formou! Recebeu diploma e prÃªmio de R$ 1000"

**3. `StakeLost` - "Penalties"**
- **Manchete**: "Prazo perdido!"
- **Detalhes**: Qual tarefa, quem perdeu o prazo, quanto dinheiro foi perdido
- Como anunciar: "JoÃ£o Silva perdeu aposta de R$ 500 por nÃ£o entregar projeto"

**ğŸ”— Importante**: Estes "jornais" ficam **gravados para sempre** na blockchain - qualquer site pode ler e mostrar essas notificaÃ§Ãµes!

#### ğŸ› ï¸ **FunÃ§Ã£o createTask() - A "MÃ¡quina de Fazer Tarefas"**

```solidity
function createTask(string memory _title, string memory _description, uint256 _deadline) 
    public payable
{
    // VerificaÃ§Ãµes de seguranÃ§a
    require(_deadline > block.timestamp, "Deadline must be in the future");
    require(msg.value >= MINIMUM_STAKE, "Stake must be at least 0.001 ether");

    totalTasks++;  // Incrementa contador

    // Cria nova tarefa
    tasks[totalTasks] = Task({
        id: totalTasks,
        title: _title,
        description: _description,
        createdAt: block.timestamp,
        deadline: _deadline,
        isCompleted: false,
        creator: msg.sender,
        stake: msg.value,
        stakeProcessed: false
    });

    userTasks[msg.sender].push(totalTasks);  // Adiciona Ã  lista do usuÃ¡rio
    
    emit TaskCreated(totalTasks, msg.sender, _title, _deadline, msg.value);  // Emite evento
}
```

**Analogia**: Como uma **mÃ¡quina de fazer apostas em corrida de cavalos**:

**ğŸ° Como funciona a mÃ¡quina:**

**Entrada (ParÃ¢metros)**:
- **`_title`**: Nome do seu cavalo ("Estudar Solidity")
- **`_description`**: DescriÃ§Ã£o da corrida ("Completar curso em 30 dias")
- **`_deadline`**: Data da corrida (timestamp futuro)
- **`payable`**: A mÃ¡quina **aceita dinheiro** junto com o pedido

**ğŸ›¡ï¸ SeguranÃ§as da MÃ¡quina (require)**:
```solidity
require(_deadline > block.timestamp, "Deadline must be in the future");
```
- **Analogia**: Como um **seguranÃ§a na porta** que verifica se vocÃª nÃ£o estÃ¡ tentando apostar numa corrida que jÃ¡ acabou
- `block.timestamp` = "que horas sÃ£o agora na blockchain"
- Ã‰ como dizer: "SÃ³ aceito apostas para corridas futuras!"

```solidity
require(msg.value >= MINIMUM_STAKE, "Stake must be at least 0.001 ether");
```
- **Analogia**: Como um **caixa** que verifica se vocÃª trouxe dinheiro suficiente
- `msg.value` = quanto dinheiro vocÃª colocou na mÃ¡quina
- Ã‰ como: "Aposta mÃ­nima: R$ 5,00"

**ğŸ­ ProduÃ§Ã£o da Ficha (CriaÃ§Ã£o da Task)**:
```solidity
totalTasks++;  // Gera nÃºmero sequencial da ficha
```
- Como uma **mÃ¡quina de senha do banco**: 001, 002, 003...

```solidity
tasks[totalTasks] = Task({...});
```
- **Analogia**: Como **preencher uma ficha de aposta completa**:
  - `id`: NÃºmero da sua aposta (Ãºnico)
  - `title` e `description`: Nome e detalhes do cavalo
  - `createdAt`: "Hora que fez a aposta" (agora)
  - `deadline`: "Hora da corrida"
  - `isCompleted: false`: "Corrida ainda nÃ£o aconteceu"
  - `creator`: "Seu CPF" (quem fez a aposta)
  - `stake`: "Quanto vocÃª apostou"
  - `stakeProcessed: false`: "Pagamento ainda nÃ£o foi processado"

**ğŸ“ OrganizaÃ§Ã£o (userTasks)**:
```solidity
userTasks[msg.sender].push(totalTasks);
```
- **Analogia**: Como **anotar no seu caderno pessoal**: "Apostas que fiz: 1, 5, 12"
- A mÃ¡quina lembra **todas as suas apostas**

**ğŸ“¢ DivulgaÃ§Ã£o (Evento)**:
```solidity
emit TaskCreated(...);
```
- **Analogia**: Como **anunciar no alto-falante**: "JoÃ£o Silva fez aposta #5 no cavalo 'Estudar Solidity' para corrida do dia 15!"
- Todo mundo pode **ouvir** este anÃºncio

#### âœ… **FunÃ§Ã£o completeTask() - O "Juiz da Corrida"**

```solidity
function completeTask(uint256 _taskId) public
{
    // VerificaÃ§Ãµes
    require(_taskId > 0 && _taskId <= totalTasks, "Task does not exist");
    require(tasks[_taskId].creator == msg.sender, "Only task creator can call this function");
    
    Task storage task = tasks[_taskId];
    require(!task.isCompleted, "Task is already completed");
    require(!task.stakeProcessed, "Stake has already been processed");

    task.isCompleted = true;
    task.stakeProcessed = true;

    // LÃ³gica do stake
    if (block.timestamp <= task.deadline) {
        // No prazo = devolve o dinheiro
        (bool success, ) = payable(task.creator).call{value: task.stake}("");
        require(success, "Failed to return stake");
        emit TaskCompleted(_taskId, task.creator, task.stake);
    } else {
        // Atrasado = perde o dinheiro
        emit StakeLost(_taskId, task.creator, task.stake);
    }
}
```

**Analogia**: Como um **juiz rigoroso de corrida** que decide se vocÃª ganhou ou perdeu a aposta:

**ğŸ” VerificaÃ§Ãµes do Juiz (requires)**:

```solidity
require(_taskId > 0 && _taskId <= totalTasks, "Task does not exist");
```
- **Analogia**: "Esta aposta existe?" - Como verificar se o **bilhete Ã© vÃ¡lido**
- Evita que alguÃ©m invente nÃºmeros de apostas

```solidity
require(tasks[_taskId].creator == msg.sender, "Only task creator can call this function");
```
- **Analogia**: "VocÃª Ã© realmente dono desta aposta?" - Como pedir **documento de identidade**
- SÃ³ quem fez a aposta pode reivindicar o prÃªmio

```solidity
require(!task.isCompleted, "Task is already completed");
require(!task.stakeProcessed, "Stake has already been processed");
```
- **Analogia**: "Esta corrida jÃ¡ foi julgada?" - Evita **duplicar pagamentos**
- Como carimbar "PAGO" no bilhete para nÃ£o pagar duas vezes

**ğŸ“ MarcaÃ§Ã£o dos Resultados**:
```solidity
task.isCompleted = true;
task.stakeProcessed = true;
```
- **Analogia**: Carimbar na ficha: **"CORRIDA FINALIZADA"** e **"PAGAMENTO PROCESSADO"**

**ğŸ’° A Grande DecisÃ£o - LÃ³gica do Pagamento**:
```solidity
if (block.timestamp <= task.deadline) {
    // GANHOU!
} else {
    // PERDEU!
}
```

**ğŸ¯ CENÃRIO 1 - GANHOU (No prazo)**:
```solidity
(bool success, ) = payable(task.creator).call{value: task.stake}("");
require(success, "Failed to return stake");
emit TaskCompleted(_taskId, task.creator, task.stake);
```
- **Analogia**: Como o **caixa do hipÃ³dromo pagando sua aposta**
- `payable(task.creator).call{value: task.stake}("")` = "Transferir dinheiro para o ganhador"
- `require(success...)` = "Garantir que o dinheiro chegou na conta"
- `emit TaskCompleted(...)` = "Anunciar no alto-falante: JoÃ£o ganhou R$ 100!"

**ğŸ’¸ CENÃRIO 2 - PERDEU (Atrasado)**:
```solidity
emit StakeLost(_taskId, task.creator, task.stake);
```
- **Analogia**: Como **rasgar o bilhete de aposta perdida**
- O dinheiro fica "na casa" (no contrato)
- `emit StakeLost(...)` = "Anunciar: JoÃ£o perdeu R$ 100 por atraso"

**ğŸ° Sistema de Incentivos**:
- â° **Chegou no prazo**: Dinheiro volta 100% + sensaÃ§Ã£o de vitÃ³ria
- âŒ **Atrasou**: Perde o dinheiro + liÃ§Ã£o aprendida
- ğŸ§  **Psicologia**: A possibilidade de perder dinheiro **motiva** vocÃª a cumprir prazos!

#### ğŸ“‹ **FunÃ§Ãµes de Consulta**

```solidity
// Pega tarefas de qualquer usuÃ¡rio
function getUserTasks(address _user) public view returns (uint256[] memory) {
    return userTasks[_user];
}

// Pega suas prÃ³prias tarefas
function getMyTasks() public view returns (uint256[] memory) {
    return userTasks[msg.sender];
}

// Verifica se uma tarefa estÃ¡ atrasada
function isTaskOverdue(uint256 _taskId) public view returns (bool) {
    require(_taskId > 0 && _taskId <= totalTasks, "Task does not exist");
    Task memory task = tasks[_taskId];
    return (block.timestamp > task.deadline && !task.isCompleted);
}
```

### ğŸ§ª LaboratÃ³rio de Testes (TaskManager.t.sol)

Os testes sÃ£o como **laboratÃ³rio de qualidade** - testamos tudo antes de lanÃ§ar no mercado:

#### ğŸ”§ **PreparaÃ§Ã£o do LaboratÃ³rio (Setup)**

```solidity
contract TaskManagerTest is Test {
    TaskManager public taskManager;
    address public user1 = address(0x1);
    
    function setUp() public {
        taskManager = new TaskManager();
        vm.deal(user1, 10 ether);  // DÃ¡ dinheiro fake para testes
    }
}
```

**Analogia**: Como **montar um laboratÃ³rio de teste** para carros:

- **`TaskManager public taskManager`**: Ã‰ o **"carro protÃ³tipo"** que vamos testar
- **`address public user1 = address(0x1)`**: Ã‰ o **"motorista de teste"** (boneco de crash test)
- **`taskManager = new TaskManager()`**: **"Construir um carro novo"** para cada teste
- **`vm.deal(user1, 10 ether)`**: **"Dar combustÃ­vel"** para o motorista de teste
- **`setUp()`**: Roda **antes de cada teste** - como resetar o laboratÃ³rio

#### âœ… **Teste 1: testCreateTask() - "Teste de IgniÃ§Ã£o"**

```solidity
function testCreateTask() public {
    vm.startPrank(user1);  // Simula que user1 estÃ¡ dirigindo
    
    taskManager.createTask{value: stake}(title, description, deadline);
    
    // Verifica se os dados foram salvos corretamente
    (uint256 id, string memory taskTitle, ...) = taskManager.tasks(1);
    assertEq(id, 1);
    assertEq(taskTitle, title);
    // ... mais verificaÃ§Ãµes
}
```

**Analogia**: Como **testar se o carro liga**:

**ğŸ”‘ PreparaÃ§Ã£o do Teste**:
```solidity
vm.startPrank(user1);
```
- **Analogia**: **"Colocar o motorista no banco do motorista"**
- `vm.startPrank()` = simula que user1 estÃ¡ fazendo as aÃ§Ãµes

**ğŸš— AÃ§Ã£o Testada**:
```solidity
taskManager.createTask{value: stake}(title, description, deadline);
```
- **Analogia**: **"Virar a chave e pisar no acelerador"**
- Testamos se a "criaÃ§Ã£o de tarefa" funciona

**ğŸ” VerificaÃ§Ã£o**:
```solidity
(uint256 id, string memory taskTitle, ...) = taskManager.tasks(1);
assertEq(id, 1);
assertEq(taskTitle, title);
```
- **Analogia**: **"Verificar se o motor ligou corretamente"**
- `taskManager.tasks(1)` = "Olhar o painel do carro"
- `assertEq()` = "Confirmar que o velocÃ­metro mostra 0 km/h"

**O que este teste garante**:
- âœ… O "motor" da criaÃ§Ã£o de tarefas funciona
- âœ… Os "dados do painel" estÃ£o corretos
- âœ… O "contador" estÃ¡ funcionando

#### âœ… **Teste 2: testCompleteTask() - "Teste de Freios"**

```solidity
function testCompleteTask() public {
    // Primeiro cria uma tarefa
    taskManager.createTask{value: stake}(title, description, deadline);
    
    uint256 balanceBefore = user1.balance;
    taskManager.completeTask(1);  // Completa a tarefa
    uint256 balanceAfter = user1.balance;
    
    // Verifica se o dinheiro voltou
    assertEq(balanceAfter, balanceBefore + stake);
}
```

**Analogia**: Como **testar se os freios funcionam**:

**ğŸ PreparaÃ§Ã£o**:
```solidity
taskManager.createTask{value: stake}(title, description, deadline);
```
- **Analogia**: **"Acelerar o carro atÃ© 100 km/h"** (criar a tarefa)

**ğŸ“Š MediÃ§Ã£o Inicial**:
```solidity
uint256 balanceBefore = user1.balance;
```
- **Analogia**: **"Medir a velocidade antes de frear"** (dinheiro antes)

**ğŸ›‘ AÃ§Ã£o de Teste**:
```solidity
taskManager.completeTask(1);
```
- **Analogia**: **"Pisar no freio"** (completar a tarefa)

**ğŸ“Š VerificaÃ§Ã£o Final**:
```solidity
uint256 balanceAfter = user1.balance;
assertEq(balanceAfter, balanceBefore + stake);
```
- **Analogia**: **"Confirmar que o carro parou"** (dinheiro voltou)
- Se o dinheiro nÃ£o voltou = "freios falharam"

**O que este teste garante**:
- âœ… O "sistema de freios" (conclusÃ£o) funciona
- âœ… O "airbag" (devoluÃ§Ã£o de dinheiro) ativa corretamente
- âœ… A "frenagem" acontece no tempo certo

#### ğŸ“‹ **Teste 3: testGetMyTasks() - "Teste do GPS"**

```solidity
function testGetMyTasks() public {
    // Cria 3 tarefas
    taskManager.createTask{value: stake}("Tarefa 1", description, deadline);
    taskManager.createTask{value: stake}("Tarefa 2", description, deadline);
    taskManager.createTask{value: stake}("Tarefa 3", description, deadline);
    
    // Verifica se a lista estÃ¡ correta
    uint256[] memory myTasks = taskManager.getMyTasks();
    assertEq(myTasks.length, 3);
    assertEq(myTasks[0], 1);  // Primeira tarefa tem ID 1
}
```

**Analogia**: Como **testar se o GPS funciona**:

**ğŸ—ºï¸ CriaÃ§Ã£o do Percurso**:
```solidity
taskManager.createTask{value: stake}("Tarefa 1", description, deadline);
taskManager.createTask{value: stake}("Tarefa 2", description, deadline);
taskManager.createTask{value: stake}("Tarefa 3", description, deadline);
```
- **Analogia**: **"Programar 3 destinos no GPS"**: Casa â†’ Trabalho â†’ Shopping

**ğŸ“± Consulta do GPS**:
```solidity
uint256[] memory myTasks = taskManager.getMyTasks();
```
- **Analogia**: **"Perguntar ao GPS: onde estÃ£o meus destinos?"**

**ğŸ” VerificaÃ§Ã£o da Lista**:
```solidity
assertEq(myTasks.length, 3);
assertEq(myTasks[0], 1);
```
- **Analogia**: **"Conferir se o GPS lembra dos 3 destinos"**
- **"Confirmar que o primeiro destino Ã© o nÃºmero 1"**

**O que este teste garante**:
- âœ… O "GPS" (funÃ§Ã£o de listar) funciona
- âœ… A "memÃ³ria" (storage) guarda tudo corretamente
- âœ… A "ordem" dos destinos estÃ¡ certa

#### ğŸ¯ **Por que Fazer Estes Testes?**

**Analogia**: Como **testar um carro antes de vender**:

- **ğŸ›¡ï¸ SeguranÃ§a**: Evita que o "carro exploda" (bugs que perdem dinheiro)
- **ğŸ”„ ConfianÃ§a**: Se vocÃª mudar o "motor" (cÃ³digo), testa se ainda funciona
- **ğŸ“Š Cobertura**: Testa "subida", "descida", "chuva", "sol" (diferentes cenÃ¡rios)  
- **âš¡ Rapidez**: Encontra problemas no "laboratÃ³rio", nÃ£o na "estrada" (produÃ§Ã£o)
- **ğŸ’° Economia**: Ã‰ mais barato consertar no laboratÃ³rio que pagar indenizaÃ§Ã£o

**ğŸš¨ Sem testes Ã© como**:
- Vender carro sem testar freios
- LanÃ§ar remÃ©dio sem testar efeitos
- Construir prÃ©dio sem testar fundaÃ§Ã£o

**âœ… Com testes Ã© como**:
- Certificado de qualidade
- Seguro total
- Garantia que funciona

#### ğŸ¯ **Dicas de Testes Adicionais - "Expandindo o LaboratÃ³rio"**

Nosso contrato atual tem 3 testes bÃ¡sicos, mas poderÃ­amos **"testar muito mais"**! Aqui estÃ£o ideias de **testes que vocÃª pode implementar**:

#### ğŸ›¡ï¸ **Testes de SeguranÃ§a - "Teste de InvasÃ£o"**

**Analogia**: Como **testar a seguranÃ§a de um banco** - tentar todas as formas de roubar!

**1. Teste de AutorizaÃ§Ã£o:**
```solidity
function testOnlyOwnerCanComplete() public {
    // UsuÃ¡rio 1 cria tarefa
    // UsuÃ¡rio 2 tenta completar tarefa do usuÃ¡rio 1
    // Deve FALHAR
}
```
- **O que testa**: Se alguÃ©m pode completar tarefa de outra pessoa
- **Analogia**: Como testar se **vizinho pode sacar na sua conta**

**2. Teste de Double Spending:**
```solidity
function testCannotCompleteTaskTwice() public {
    // Criar tarefa
    // Completar uma vez (sucesso)
    // Tentar completar segunda vez (deve falhar)
}
```
- **O que testa**: Se Ã© possÃ­vel receber dinheiro duas vezes
- **Analogia**: Como testar se dÃ¡ para **sacar o prÃªmio duas vezes**

**3. Teste de Overflow/Underflow:**
```solidity
function testMassiveTaskCreation() public {
    // Criar 1000+ tarefas
    // Verificar se totalTasks nÃ£o "quebra"
}
```
- **O que testa**: Se o contador aguenta nÃºmeros gigantes
- **Analogia**: Como testar se **odÃ´metro nÃ£o volta ao zero** quando chega ao limite

#### â° **Testes de Tempo - "Teste da MÃ¡quina do Tempo"**

**Analogia**: Como **testar diferentes cenÃ¡rios temporais** numa corrida!

**1. Teste de Tarefa Atrasada:**
```solidity
function testLateTaskCompletion() public {
    // Criar tarefa com prazo de 1 dia
    // AvanÃ§ar tempo para 2 dias (vm.warp)
    // Completar tarefa
    // Verificar se stake foi perdido (nÃ£o devolvido)
}
```
- **O que testa**: Se stake Ã© realmente perdido quando atrasado
- **Analogia**: **Chegar atrasado na corrida** e perder a aposta

**2. Teste de VerificaÃ§Ã£o de Atraso:**
```solidity
function testIsTaskOverdueLogic() public {
    // Criar tarefa
    // Verificar que nÃ£o estÃ¡ atrasada
    // AvanÃ§ar tempo apÃ³s prazo
    // Verificar que estÃ¡ atrasada
    // Completar tarefa
    // Verificar que nÃ£o estÃ¡ mais "atrasada" (foi concluÃ­da)
}
```
- **O que testa**: Se a lÃ³gica de "atrasado" funciona corretamente
- **Analogia**: **CronÃ´metro da corrida** estÃ¡ funcionando direito

#### ğŸ’° **Testes Financeiros - "Teste do Cofre"**

**Analogia**: Como **testar todos os cenÃ¡rios de dinheiro** num cassino!

**1. Teste de Stake Insuficiente:**
```solidity
function testInsufficientStake() public {
    // Tentar criar tarefa com 0.0001 ether (menos que mÃ­nimo)
    // Deve FALHAR
}
```
- **O que testa**: Se valores baixos sÃ£o rejeitados
- **Analogia**: **Tentar apostar centavos** numa mesa que exige reais

**2. Teste de Stake Exato:**
```solidity
function testExactMinimumStake() public {
    // Criar tarefa com exatamente 0.001 ether
    // Deve FUNCIONAR
}
```
- **O que testa**: Se o valor mÃ­nimo exato Ã© aceito
- **Analogia**: **Apostar exatamente o mÃ­nimo** permitido

**3. Teste de Stakes Diferentes:**
```solidity
function testDifferentStakeAmounts() public {
    // Criar tarefas com 0.001, 0.01, 0.1, 1 ether
    // Completar todas no prazo
    // Verificar se cada um recebeu o valor correto de volta
}
```
- **O que testa**: Se valores diferentes sÃ£o manuseados corretamente
- **Analogia**: **Apostas de valores diferentes** na mesma corrida

#### ğŸ“Š **Testes de Estado - "Teste do InventÃ¡rio"**

**Analogia**: Como **conferir se o estoque** da loja estÃ¡ correto!

**1. Teste de Contador Global:**
```solidity
function testTotalTasksIncrement() public {
    uint256 initialCount = taskManager.totalTasks();
    
    // Criar 3 tarefas
    // Verificar se totalTasks aumentou em 3
    
    assertEq(taskManager.totalTasks(), initialCount + 3);
}
```
- **O que testa**: Se o contador global estÃ¡ certo
- **Analogia**: **Conferir se o caixa** registrou todas as vendas

**2. Teste de Lista de UsuÃ¡rio:**
```solidity
function testUserTasksList() public {
    // UsuÃ¡rio A cria 2 tarefas
    // UsuÃ¡rio B cria 3 tarefas
    // Verificar se cada um tem a quantidade correta na sua lista
    // Verificar se as listas nÃ£o se misturam
}
```
- **O que testa**: Se cada usuÃ¡rio vÃª apenas suas tarefas
- **Analogia**: **Cada cliente sÃ³ vÃª seus prÃ³prios pedidos**

#### ğŸ² **Testes de Casos Extremos - "Teste do ImpossÃ­vel"**

**Analogia**: Como **testar situaÃ§Ãµes malucas** que provavelmente nunca vÃ£o acontecer!

**1. Teste de Deadline no Futuro Distante:**
```solidity
function testFarFutureDeadline() public {
    // Criar tarefa com deadline em 100 anos
    // Deve funcionar normalmente
}
```
- **O que testa**: Se o contrato aguenta datas muito futuras
- **Analogia**: **Apostar numa corrida de 2124**

**2. Teste de String Vazia:**
```solidity
function testEmptyTaskTitle() public {
    // Tentar criar tarefa com tÃ­tulo vazio ""
    // Pode aceitar ou rejeitar (depende da regra)
}
```
- **O que testa**: Como o contrato lida com dados vazios
- **Analogia**: **Apostar sem dar nome ao cavalo**

**3. Teste de String Gigante:**
```solidity
function testMassiveTaskDescription() public {
    // Criar tarefa com descriÃ§Ã£o de 10.000 caracteres
    // Verificar custo de gas e funcionamento
}
```
- **O que testa**: Se textos enormes causam problemas
- **Analogia**: **Escrever uma redaÃ§Ã£o de 50 pÃ¡ginas** como descriÃ§Ã£o

#### ğŸ† **Testes de Performance - "Teste de Velocidade"**

**Analogia**: Como **testar se o carro aguenta** FÃ³rmula 1!

**1. Teste de Gas Cost:**
```solidity
function testGasCosts() public {
    // Medir gas de createTask
    // Medir gas de completeTask
    // Verificar se estÃ¡ dentro de limites aceitÃ¡veis
}
```
- **O que testa**: Quanto "combustÃ­vel" cada funÃ§Ã£o gasta
- **Analogia**: **Testar consumo** de cada carro

**2. Teste de Stress:**
```solidity
function testStressTest() public {
    // Criar 100 tarefas em sequÃªncia
    // Completar todas
    // Verificar se tudo ainda funciona
}
```
- **O que testa**: Se o contrato aguenta uso intenso
- **Analogia**: **Dirigir 1000km** sem parar para ver se quebra

#### ğŸ’¡ **Como Implementar Estes Testes**

**1. ğŸ“ Organizar por Categoria:**
```
test/
â”œâ”€â”€ TestSecurity.t.sol     # Testes de seguranÃ§a
â”œâ”€â”€ TestTiming.t.sol       # Testes de tempo
â”œâ”€â”€ TestFinancial.t.sol    # Testes financeiros
â”œâ”€â”€ TestState.t.sol        # Testes de estado
â””â”€â”€ TestEdgeCases.t.sol    # Casos extremos
```

**2. ğŸ¯ Usar Foundry Features:**
```solidity
// Testar com fuzzing (dados aleatÃ³rios)
function testFuzzCreateTask(string memory title, uint256 deadline) public {
    vm.assume(deadline > block.timestamp);
    // Foundry vai testar com centenas de valores aleatÃ³rios
}

// Testar invariants (regras que nunca devem quebrar)
function invariant_totalTasksNeverDecrease() public {
    // Esta regra deve ser sempre verdadeira
    assert(taskManager.totalTasks() >= previousTotalTasks);
}
```

**3. ğŸš¨ Usar vm Commands:**
```solidity
vm.warp(timestamp);        // Viajar no tempo
vm.deal(user, amount);     // Dar dinheiro fake
vm.expectRevert("error");  // Esperar que falhe
vm.startPrank(user);       // Simular outro usuÃ¡rio
```

**ğŸ¯ Meta**: Com estes testes, seu contrato fica **blindado** como Fort Knox! ğŸ°

### ğŸš€ Script de Deploy (DeployTaskManager.s.sol)

O script de deploy Ã© como um **"manual de instalaÃ§Ã£o"** do nosso contrato na blockchain:

#### ğŸ—ï¸ **Estrutura do Script de Deploy**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Script.sol";
import "../src/TaskManager.sol";

contract DeployTaskManager is Script {
    function setUp() public {}

    function run() public {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        vm.startBroadcast(deployerPrivateKey);

        TaskManager taskManager = new TaskManager();
        
        console.log("TaskManager deployed at:", address(taskManager));
        console.log("Deployer address:", vm.addr(deployerPrivateKey));
        console.log("Minimum stake required:", taskManager.MINIMUM_STAKE());

        vm.stopBroadcast();
    }
}
```

**Analogia**: Como **abrir uma nova loja fÃ­sica**:

#### ğŸ“‹ **PreparaÃ§Ã£o (Imports)**
```solidity
import "forge-std/Script.sol";
import "../src/TaskManager.sol";
```
- **Analogia**: Como **reunir todas as ferramentas** necessÃ¡rias antes de construir
- `Script.sol` = "Kit de ferramentas para construÃ§Ã£o"
- `TaskManager.sol` = "Planta da loja que vamos construir"

#### ğŸ”‘ **AutenticaÃ§Ã£o (Private Key)**
```solidity
uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
```
- **Analogia**: Como **pegar a chave do proprietÃ¡rio** para autorizar a construÃ§Ã£o
- `PRIVATE_KEY` = Sua "chave secreta" (como a senha do banco)
- `vm.envUint()` = Pega a chave de um arquivo seguro (variÃ¡vel de ambiente)

#### ğŸ“¢ **InÃ­cio da ConstruÃ§Ã£o (startBroadcast)**
```solidity
vm.startBroadcast(deployerPrivateKey);
```
- **Analogia**: Como **avisar a prefeitura**: "Vou comeÃ§ar a construir agora!"
- A partir daqui, tudo que vocÃª fizer **custa dinheiro real** (gas)
- Ã‰ como ligar um **"taxÃ­metro"** da blockchain

#### ğŸ­ **ConstruÃ§Ã£o da Loja (new TaskManager)**
```solidity
TaskManager taskManager = new TaskManager();
```
- **Analogia**: Como **construir fisicamente a loja**
- `new TaskManager()` = "Erguer um prÃ©dio novo do zero"
- A partir daqui, sua loja existe **para sempre** na blockchain

#### ğŸ“ **RelatÃ³rio de ConclusÃ£o (console.log)**
```solidity
console.log("TaskManager deployed at:", address(taskManager));
console.log("Deployer address:", vm.addr(deployerPrivateKey));
console.log("Minimum stake required:", taskManager.MINIMUM_STAKE());
```
- **Analogia**: Como **entregar a certidÃ£o de conclusÃ£o da obra**:
  - "Loja construÃ­da no endereÃ§o: Rua A, nÂº 123"
  - "ProprietÃ¡rio: JoÃ£o Silva (CPF: 123.456.789-00)"
  - "Taxa de entrada: R$ 5,00"

#### ğŸ›‘ **Fim da ConstruÃ§Ã£o (stopBroadcast)**
```solidity
vm.stopBroadcast();
```
- **Analogia**: Como **desligar o taxÃ­metro** e avisar: "Obra concluÃ­da!"
- A partir daqui, nÃ£o gastamos mais gas

#### ğŸ¯ **Por que usar Script de Deploy?**

- **ğŸ”„ RepetÃ­vel**: Pode rodar vÃ¡rias vezes (testnet, mainnet, etc.)
- **ğŸ“ Documentado**: Fica registrado exatamente como o contrato foi criado
- **ğŸ›¡ï¸ Seguro**: Usa variÃ¡veis de ambiente para proteger chaves privadas
- **ğŸ“Š Informativo**: Mostra endereÃ§os e informaÃ§Ãµes importantes
- **âš¡ Automatizado**: Um comando sÃ³ faz tudo

**Comando para usar**:
```bash
forge script script/DeployTaskManager.s.sol:DeployTaskManager --rpc-url <REDE> --private-key <SUA_CHAVE> --broadcast
```

**Analogia**: Como usar um **"app de construÃ§Ã£o"** que faz tudo automaticamente!

### ğŸŒ Deploy Manual na Rede Sepolia - "Construindo na Cidade Real"

Agora vamos aprender a **"construir nossa loja"** numa cidade real (rede de teste), nÃ£o apenas no terreno de treino (rede local).

#### ğŸ¢ **Entendendo os Provedores - "Companhias TelefÃ´nicas da Blockchain"**

**Analogia**: Como **empresas de telecomunicaÃ§Ãµes** que conectam vocÃª Ã  internet.

**ğŸ¤” Por que precisamos de provedores?**

Imagine que vocÃª quer **ligar para alguÃ©m** numa cidade distante:
- VocÃª nÃ£o pode ir fisicamente atÃ© lÃ¡
- Precisa de uma **"empresa telefÃ´nica"** para fazer a conexÃ£o
- A empresa tem **torres e cabos** que conectam as cidades

**Na blockchain Ã© igual**:
- Sua aplicaÃ§Ã£o local nÃ£o consegue "falar" diretamente com Ethereum
- Precisa de um **"provedor RPC"** para fazer a conexÃ£o
- O provedor tem **servidores e nÃ³s** que conectam vocÃª Ã  rede

#### ğŸ“¡ **Infura - A "Operadora Premium"**

**Infura** Ã© como a **"Vivo/Claro da blockchain"** - uma empresa que oferece conexÃ£o profissional.

**ğŸ”— Outros provedores similares:**
- **Alchemy** (concorrente principal)
- **QuickNode** 
- **Moralis**
- **GetBlock**

**Analogia**: Como **operadoras de celular** - todas fazem a mesma coisa (conectar), mas com preÃ§os e qualidades diferentes.

#### ğŸ—ï¸ **Obtendo API Key da Infura - "Seu CartÃ£o de Acesso"**

**Passo a passo para pegar sua "linha telefÃ´nica":**

**1. ğŸ“ Criar Conta na Infura:**
- Acesse: https://infura.io/
- Clique em **"Sign Up"** (criar conta)
- Use um email vÃ¡lido (vocÃª receberÃ¡ confirmaÃ§Ã£o)

**Analogia**: Como **"contratar um plano de celular"** numa operadora.

**2. âœ… Confirmar Email:**
- VÃ¡ ao seu email
- Clique no link de confirmaÃ§Ã£o
- FaÃ§a login na Infura

**3. ğŸ¯ Criar um Projeto:**
- No painel, clique **"Create New Key"**
- **Name**: "TaskManager Project" (ou qualquer nome)
- **Network**: **"Web3 API"** (nÃ£o Ethereum 2.0)
- Clique **"Create"**

**Analogia**: Como **"registrar um novo nÃºmero"** na operadora.

**4. ğŸ“‹ Copiar as URLs:**

ApÃ³s criar, vocÃª verÃ¡ algo assim:
```
PROJECT ID: 9aa3d95b3bc440fa88ea12eaa4456161

ENDPOINTS:
Mainnet: https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161
Sepolia: https://sepolia.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161
```

**ğŸ¯ Importante**: Copie a URL da **Sepolia** - Ã© ela que vamos usar!

**Analogia**: Como **"pegar seu nÃºmero de telefone"** depois de contratar o plano.

#### ğŸ” **Etherscan - O "Google da Blockchain"**

**Etherscan** Ã© como o **"Google"** da blockchain Ethereum - vocÃª pode pesquisar qualquer coisa.

**ğŸŒ Links importantes:**
- **Mainnet**: https://etherscan.io/ (rede principal)
- **Sepolia**: https://sepolia.etherscan.io/ (rede de teste)

**O que vocÃª pode fazer no Etherscan:**
- ğŸ” **Pesquisar transaÃ§Ãµes** (como rastrear encomenda dos Correios)
- ğŸ‘€ **Ver contratos** deployados (como ver lojas numa rua)
- ğŸ’° **Verificar saldos** (como extrato bancÃ¡rio)
- â›½ **Monitorar gas** (como preÃ§o da gasolina)

#### ğŸ”‘ **Configurando API Key do Etherscan**

**Por que precisamos?**
- Para **verificar contratos** automaticamente
- Como ter **"acesso VIP"** ao Google da blockchain

**Passo a passo:**

**1. ğŸ“ Criar Conta no Etherscan:**
- Acesse: https://etherscan.io/
- Clique **"Sign In"** â†’ **"Click to sign up"**
- Registre-se com email

**2. ğŸ—ï¸ Gerar API Key:**
- FaÃ§a login
- VÃ¡ em **"API Keys"** (no menu do usuÃ¡rio)
- Clique **"Add"** 
- **App Name**: "TaskManager"
- Copie a **API Key** gerada

**Exemplo da API Key:**
```
YourApiKeyToken: ABC123DEF456GHI789JKL012MNO345PQR678
```

**Analogia**: Como **"pegar cartÃ£o VIP"** para ter acesso especial ao shopping.

#### ğŸ¦Š **MetaMask - Sua "Carteira Digital"**

**MetaMask** Ã© como sua **"carteira fÃ­sica"**, mas para criptomoedas.

#### ğŸ“¥ **Instalando MetaMask:**

**1. ğŸ’» Instalar ExtensÃ£o:**
- Acesse: https://metamask.io/
- Clique **"Download"**
- Adicione ao Chrome/Firefox/Safari

**2. ğŸ†• Criar Carteira Nova:**
- Abra a extensÃ£o
- **"Create a new wallet"**
- Criar senha forte
- **âš ï¸ ANOTAR AS 12 PALAVRAS** (seed phrase) num papel

**Analogia**: As 12 palavras sÃ£o como **"chave mestre do cofre"** - se perder, perde tudo!

#### ğŸŒ **Configurando Rede Sepolia:**

**Sepolia jÃ¡ vem configurada** no MetaMask moderno, mas se nÃ£o estiver:

```
Network Name: Sepolia test network
New RPC URL: https://sepolia.infura.io/v3/SEU_PROJECT_ID
Chain ID: 11155111
Currency Symbol: ETH
Block Explorer: https://sepolia.etherscan.io
```

#### ğŸ’° **Conseguindo Ethereum de Teste (Sepolia ETH):**

**Analogia**: Como **"dinheiro de Monopoly"** - vale apenas no jogo (rede de teste).

**Faucets (torneiras) gratuitas:**
1. **Sepolia Faucet**: https://sepoliafaucet.com/
2. **Alchemy Faucet**: https://sepoliafaucet.com/
3. **Infura Faucet**: https://www.infura.io/faucet

**Como usar:**
- Copie seu endereÃ§o MetaMask
- Cole no faucet
- Aguarde 1-2 minutos
- Receba ~0.5 ETH de teste

#### ğŸ” **Obtendo Chave Privada - "Senha do Cofre"**

**âš ï¸ ATENÃ‡ÃƒO EXTREMA**: Chave privada Ã© como **"senha do banco"** - NUNCA compartilhe!

**Passo a passo no MetaMask:**

**1. ğŸ¦Š Abrir MetaMask:**
- Clique na extensÃ£o
- FaÃ§a login

**2. âš™ï¸ Acessar ConfiguraÃ§Ãµes:**
- Clique nos **3 pontinhos** (menu)
- **"Account Details"**

**3. ğŸ”‘ Exportar Chave:**
- **"Show private key"**
- Digite sua **senha do MetaMask**
- **Copie a chave privada**

**Exemplo de chave privada:**
```
0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
```

**ğŸš¨ SEGURANÃ‡A MÃXIMA**:
- âŒ **NUNCA** cole em sites duvidosos
- âŒ **NUNCA** compartilhe com ninguÃ©m
- âŒ **NUNCA** commit no Git
- âœ… Use apenas para deploy local/teste
- âœ… Crie uma carteira separada sÃ³ para desenvolvimento

#### ğŸš€ **Deploy Manual na Sepolia - Passo a Passo**

Agora vamos **"construir nossa loja"** na cidade real!

#### ğŸ› ï¸ **PreparaÃ§Ã£o do Ambiente:**

**1. ğŸ“ Criar arquivo .env:**

Na pasta do projeto, crie `.env`:
```bash
# .env (NUNCA commit este arquivo!)
PRIVATE_KEY=0xSUA_CHAVE_PRIVADA_AQUI
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/SEU_PROJECT_ID
ETHERSCAN_API_KEY=SUA_API_KEY_DO_ETHERSCAN
```

**2. ğŸ”’ Proteger .env:**

Adicione no `.gitignore`:
```
.env
```

**Analogia**: Como **"trancar o cofre"** onde vocÃª guarda senhas.

#### ğŸ—ï¸ **Executando o Deploy:**

**1. ğŸ’» Comando de Deploy:**

```bash
forge script script/DeployTaskManager.s.sol:DeployTaskManager \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  --verify \
  --etherscan-api-key $ETHERSCAN_API_KEY \
  -vvvv
```

**Quebrado em partes:**
- `forge script` = Executar script de deploy
- `--rpc-url` = Conectar via Infura na Sepolia
- `--private-key` = Usar sua carteira para pagar gas
- `--broadcast` = Realmente enviar para blockchain
- `--verify` = Publicar cÃ³digo no Etherscan
- `-vvvv` = Mostrar TUDO que estÃ¡ acontecendo

**2. ğŸ’¸ O que acontece:**

```
[â ¢] Compiling...
[âœ…] Compilation completed successfully.

== Logs ==
TaskManager deployed at: 0x742d35Cc6636C0532925a3b8D8C9a76C4577F6B5
Deployer address: 0xYourAddress
Minimum stake required: 1000000000000000

## Setting up 1 EVM.
##
## Environment
Chain: sepolia

## Sender
Address: 0xYourAddress
Balance: 0.123456789 ETH

âœ… Transaction sent! Hash: 0xabc123...
â³ Waiting for confirmation...
âœ… Transaction confirmed!
â›½ Gas used: 1,234,567
ğŸ’° Gas cost: 0.001234 ETH
```

**3. ğŸ” VerificaÃ§Ã£o no Etherscan:**

- Acesse: https://sepolia.etherscan.io/
- Cole o endereÃ§o do contrato
- Veja seu contrato deployado!

#### ğŸ¯ **Testando o Contrato Deployado:**

**1. ğŸ“ Consultar dados (grÃ¡tis):**

```bash
# Ver total de tarefas
cast call 0xSEU_CONTRATO_ADDRESS "totalTasks()" --rpc-url $SEPOLIA_RPC_URL

# Ver stake mÃ­nimo
cast call 0xSEU_CONTRATO_ADDRESS "MINIMUM_STAKE()" --rpc-url $SEPOLIA_RPC_URL
```

**2. ğŸ“ Criar tarefa (custa gas):**

```bash
cast send 0xSEU_CONTRATO_ADDRESS \
  "createTask(string,string,uint256)" \
  "Estudar Solidity" \
  "Completar tutorial completo" \
  1703980800 \
  --value 0.001ether \
  --private-key $PRIVATE_KEY \
  --rpc-url $SEPOLIA_RPC_URL
```

#### ğŸ‰ **ParabÃ©ns! Seu Contrato estÃ¡ Vivo!**

**ğŸŒ Links Ãºteis apÃ³s deploy:**
- **Contrato**: https://sepolia.etherscan.io/address/SEU_ENDEREÃ‡O
- **CÃ³digo Verificado**: Aba "Contract" â†’ "Read Contract"
- **TransaÃ§Ãµes**: Aba "Txns" mostra todas as interaÃ§Ãµes

**Analogia**: Como **"inaugurar sua loja"** numa rua movimentada - agora todo mundo pode visitÃ¡-la!

**ğŸ¯ PrÃ³ximos passos:**
- Criar interface front-end
- Conectar MetaMask ao seu site
- Permitir que usuÃ¡rios interajam visualmente

---

## ğŸ Bonus - Prompt do Contrato

Para referÃªncia e estudo, aqui estÃ¡ o **prompt original** usado para criar o contrato TaskManager:

```
Crie um contrato inteligente em Solidity chamado "TaskManager" que permita aos usuÃ¡rios criar, gerenciar e concluir tarefas associadas a prazos e valores apostados (stakes). O contrato deve atender aos seguintes requisitos:

Estrutura de Dados

Armazenar informaÃ§Ãµes de cada tarefa, incluindo:

Um identificador Ãºnico para cada tarefa.

Um tÃ­tulo descritivo.

Uma descriÃ§Ã£o detalhada.

A data de criaÃ§Ã£o da tarefa.

Um prazo para conclusÃ£o (data futura).

O status atual da tarefa (pendente ou concluÃ­da).

O endereÃ§o do criador da tarefa.

O valor apostado (stake) associado Ã  tarefa.

Um indicador que mostre se o valor apostado jÃ¡ foi processado.

Funcionalidades Principais

Permitir que usuÃ¡rios criem novas tarefas fornecendo:

Um tÃ­tulo, uma descriÃ§Ã£o e um prazo (que deve ser uma data futura).

Um valor apostado mÃ­nimo de 0.001 ether, enviado junto com a criaÃ§Ã£o.

Restringir a conclusÃ£o de tarefas apenas ao criador da tarefa.

Processar o valor apostado da seguinte forma:

Devolver o valor ao criador se a tarefa for concluÃ­da antes do prazo.

Considerar o valor perdido se o prazo expirar sem conclusÃ£o.

Oferecer uma maneira de os usuÃ¡rios consultarem todas as tarefas que eles prÃ³prios criaram.

Possibilitar a verificaÃ§Ã£o se uma tarefa estÃ¡ atrasada com base no prazo e no tempo atual.

Disponibilizar informaÃ§Ãµes gerais, como:

O nÃºmero total de tarefas criadas no contrato.

O saldo total de ether atualmente armazenado no contrato.

NotificaÃ§Ãµes

Gerar notificaÃ§Ãµes pÃºblicas (eventos) nos seguintes casos:

Quando uma nova tarefa Ã© criada.

Quando uma tarefa Ã© concluÃ­da.

Quando o valor apostado Ã© perdido devido ao atraso.

SeguranÃ§a

Garantir que as transferÃªncias de ether sejam feitas de forma segura, verificando se foram concluÃ­das com sucesso.

EspecificaÃ§Ãµes TÃ©cnicas

Utilizar a versÃ£o 0.8.13 do Solidity.

Incluir a licenÃ§a MIT no inÃ­cio do cÃ³digo.

Usar estruturas de mapeamento para organizar as tarefas e associÃ¡-las aos respectivos criadores.

Fornecer uma forma de consultar os detalhes completos de uma tarefa especÃ­fica.

Incluir uma maneira de determinar se uma tarefa estÃ¡ atrasada em relaÃ§Ã£o ao prazo.

Permitir consulta ao nÃºmero total de tarefas criadas e ao saldo atual do contrato.
```

**ğŸ’¡ Dica**: Este prompt pode servir como **base** para criar outros contratos similares ou para **estudar** como traduzir requisitos em cÃ³digo Solidity!
