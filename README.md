# Web3 todo interface

*Automatically synced with your [v0.dev](https://v0.dev) deployments*

[![Deployed on Vercel](https://img.shields.io/badge/Deployed%20on-Vercel-black?style=for-the-badge&logo=vercel)](https://vercel.com/manoelgomesdevs-projects/v0-web3-todo-interface)
[![Built with v0](https://img.shields.io/badge/Built%20with-v0.dev-black?style=for-the-badge)](https://v0.dev/chat/projects/Tw7JzfnvoEm)

## Overview

This repository will stay in sync with your deployed chats on [v0.dev](https://v0.dev).
Any changes you make to your deployed app will be automatically pushed to this repository from [v0.dev](https://v0.dev).

## Deployment

Your project is live at:

**[https://vercel.com/manoelgomesdevs-projects/v0-web3-todo-interface](https://vercel.com/manoelgomesdevs-projects/v0-web3-todo-interface)**

## Build your app

Continue building your app on:

**[https://v0.dev/chat/projects/Tw7JzfnvoEm](https://v0.dev/chat/projects/Tw7JzfnvoEm)**

## How It Works

1. Create and modify your project using [v0.dev](https://v0.dev)
2. Deploy your chats from the v0 interface
3. Changes are automatically pushed to this repository
4. Vercel deploys the latest version from this repository

---

## ğŸ“š Aula 1

### ğŸš€ Prompt para criar seu Front com mais agilidade

```
WEB3 TODO â€” Interface de UsuÃ¡rio

O objetivo deste projeto Ã© desenvolver a interface de usuÃ¡rio do WEB3 TODO, um aplicativo de gerenciamento de tarefas com integraÃ§Ã£o Ã  tecnologia Web3. O sistema permitirÃ¡ que os usuÃ¡rios conectem sua carteira digital, criem e acompanhem tarefas, alÃ©m de visualizarem mÃ©tricas em tempo real, sempre priorizando a usabilidade e o design moderno.

A estrutura da interface Ã© dividida em trÃªs Ã¡reas principais:

1. CabeÃ§alho

Exibir no topo da pÃ¡gina um botÃ£o de destaque com o rÃ³tulo "Conectar Carteira".

Abaixo do botÃ£o, apresentar uma mensagem de alerta:
"Conecte sua carteira para gerenciar suas tarefas na blockchain."

O botÃ£o e a mensagem devem indicar visualmente o status da conexÃ£o com a carteira, facilitando o entendimento do usuÃ¡rio sobre o que estÃ¡ ou nÃ£o disponÃ­vel.

2. SeÃ§Ã£o de MÃ©tricas

Criar uma grade horizontal com quatro cards informativos:

Total de Tarefas

Tarefas ConcluÃ­das

Tarefas Pendentes

Wei em Stake

Cada card deve:

Utilizar cores que remetam Ã  tecnologia, como azul cobalto, ciano elÃ©trico e violeta digital.

Conter Ã­cones visuais que facilitem a leitura rÃ¡pida dos dados.

3. SeÃ§Ã£o de Tarefas

Exibir o tÃ­tulo da seÃ§Ã£o: "Tarefas".

Ao lado do tÃ­tulo, adicionar um botÃ£o destacado: "Nova Tarefa".

Exibir a lista de tarefas em formato de cards horizontais, contendo:

Nome da tarefa

Status: Pendente ou ConcluÃ­do

DescriÃ§Ã£o

Data de criaÃ§Ã£o

Data de conclusÃ£o (se aplicÃ¡vel)

Valor em wei associado

Ãcone de aÃ§Ã£o para "Concluir Tarefa" (sem ediÃ§Ã£o ou exclusÃ£o)

Os cards devem:

ReforÃ§ar visualmente as aÃ§Ãµes disponÃ­veis.

Diferenciar claramente tarefas pendentes e tarefas concluÃ­das.

Diretrizes de Design

Estilo Visual

Interface clean e moderna, com tema claro (light mode).

Aplicar a regra 60-30-10 para proporÃ§Ã£o de cores.

Utilizar no mÃ¡ximo duas cores principais.

Tipografia clara com hierarquia visual definida.

Design minimalista, com espaÃ§amento adequado.

Fornecer feedback visual para:

AÃ§Ãµes do usuÃ¡rio

Estados de carregamento

Erros ou validaÃ§Ãµes

Interface responsiva para se adaptar a diferentes dispositivos.

Clareza e ConsistÃªncia

Utilizar rÃ³tulos descritivos e Ã­cones intuitivos.

Manter coerÃªncia visual em:

Cores

Tamanhos

Fontes

EspaÃ§amentos

Destacar visualmente elementos que dependem da conexÃ£o da carteira.

Interatividade

Fornecer feedback imediato com animaÃ§Ãµes suaves.

Criar transiÃ§Ãµes fluidas entre os diferentes estados da interface.

BotÃµes devem apresentar estados visuais distintos:

Hover

Ativo

Desativado

Carregando

Acessibilidade

Garantir contraste de cores adequado.

Incluir textos alternativos (alt) para Ã­cones e imagens.

Permitir navegaÃ§Ã£o completa por teclado.

Evitar a comunicaÃ§Ã£o exclusiva por cor (ex: nÃ£o usar sÃ³ cor para indicar status).

ConsideraÃ§Ãµes Finais

A interface deve ser intuitiva e acessÃ­vel para iniciantes em Web3, deixando claro quando determinadas funcionalidades exigem a carteira conectada. Todos os elementos interativos devem responder com feedback visual, e a experiÃªncia deve manter consistÃªncia e fluidez em toda a jornada do usuÃ¡rio.
```

---

## ğŸ“ Aula 2

### ğŸ”— O que Ã© Blockchain Ethereum?

**Blockchain** Ã© como um **livro de registros digital** que funciona de forma descentralizada:

- **ğŸ“– Livro PÃºblico**: Todas as transaÃ§Ãµes ficam registradas e visÃ­veis para todos
- **ğŸ”’ ImutÃ¡vel**: Uma vez registrado, nÃ£o pode ser alterado ou apagado
- **ğŸŒ Descentralizado**: NÃ£o hÃ¡ uma autoridade central controlando
- **â›“ï¸ Em Blocos**: InformaÃ§Ãµes organizadas em "blocos" conectados em sequÃªncia

**Ethereum** Ã© uma blockchain especial que permite executar **programas** (smart contracts), nÃ£o apenas transferir dinheiro como o Bitcoin.

### ğŸ“‹ O que Ã© Smart Contract?

**Smart Contract** Ã© um **programa de computador** que roda na blockchain:

- **ğŸ¤– AutomÃ¡tico**: Executa sozinho quando as condiÃ§Ãµes sÃ£o atendidas
- **ğŸ“ CÃ³digo Ã© Lei**: As regras estÃ£o escritas em cÃ³digo e nÃ£o podem ser quebradas
- **ğŸ” Transparente**: Qualquer pessoa pode ver o cÃ³digo e verificar como funciona
- **ğŸ’° Lida com Dinheiro**: Pode receber, guardar e enviar criptomoedas

**Exemplo prÃ¡tico**: 
- VocÃª cria uma tarefa no nosso sistema
- Envia 0.001 ETH como "aposta" 
- Se completar no prazo = recebe o dinheiro de volta
- Se atrasar = perde o dinheiro
- Tudo acontece automaticamente, sem intermediÃ¡rios!

### â›½ O que Ã© "Gas"?

**Gas** Ã© a **"gasolina"** da blockchain Ethereum:

- **ğŸ’¸ Taxa de TransaÃ§Ã£o**: VocÃª paga para usar a blockchain
- **âš¡ Energia Computacional**: Quanto mais complexa a operaÃ§Ã£o, mais gas custa
- **ğŸ‘· Pagamento aos Mineradores**: Quem mantÃ©m a rede funcionando recebe essas taxas
- **ğŸš€ Velocidade**: Pagar mais gas = transaÃ§Ã£o mais rÃ¡pida

**Analogia simples**:
- Blockchain = Estrada
- Smart Contract = Destino  
- Gas = CombustÃ­vel para chegar lÃ¡
- Mais gas = Viagem mais rÃ¡pida, menos gas = Viagem mais lenta

**Exemplo de custos**:
- Criar tarefa: ~50,000 gas
- Completar tarefa: ~30,000 gas  
- Consultar dados: 0 gas (leitura Ã© grÃ¡tis!)

**ğŸ’¡ Dica**: Gas varia conforme a demanda da rede. Em horÃ¡rios de pico, fica mais caro!

### ğŸ’» Entendendo Solidity - A Linguagem dos Smart Contracts

**Solidity** Ã© como o **"idioma oficial"** para escrever contratos inteligentes no Ethereum.

#### ğŸŒ **Onde Solidity Ã© Usado?**

**Analogia**: Como **idiomas do mundo real**:

- **PortuguÃªs**: Usado no Brasil, Portugal, alguns paÃ­ses da Ãfrica
- **InglÃªs**: Usado nos EUA, Inglaterra, AustrÃ¡lia
- **Solidity**: Usado em **blockchains compatÃ­veis com Ethereum**

**Principais blockchains que "falam" Solidity**:
- ğŸ”· **Ethereum** (a blockchain original)
- ğŸŸ£ **Polygon** (mais rÃ¡pida e barata)
- ğŸŸ¡ **Binance Smart Chain** (BSC)
- ğŸ”µ **Avalanche** 
- âšª **Arbitrum** e **Optimism** (Layer 2 do Ethereum)

#### ğŸ“š **Conceitos BÃ¡sicos de Solidity**

#### ğŸ—ï¸ **1. Struct - O "FormulÃ¡rio PadrÃ£o"**

```solidity
struct Task {
    uint256 id;
    string title;
    bool isCompleted;
}
```

**Analogia**: Como **formulÃ¡rio de cadastro** mÃ©dico:

- **Struct** = O **modelo em branco** do formulÃ¡rio
- Cada struct define **exatamente quais campos** existem
- Ã‰ como dizer: "Todo paciente tem: Nome, CPF, Idade"
- **ReutilizÃ¡vel**: VocÃª pode preencher **milhares** de formulÃ¡rios iguais

**No nosso caso**:
- `Task` = Modelo do formulÃ¡rio de tarefa
- Toda tarefa **sempre** tem: id, tÃ­tulo, descriÃ§Ã£o, prazo, etc.
- Ã‰ como ter um **"carimbo"** que sempre cria fichas idÃªnticas

#### ğŸ’¾ **2. Memory vs Storage - "Caderno vs Arquivo"**

**Analogia**: Como **diferentes tipos de anotaÃ§Ã£o**:

**ğŸ“ Memory - "Rascunho"**:
```solidity
string memory tempTitle = "Estudar Solidity";
```
- Ã‰ como escrever num **papel rascunho**
- **TemporÃ¡rio**: Depois que a funÃ§Ã£o termina, some
- **RÃ¡pido**: NÃ£o custa muito gas
- **Uso**: Calculations, variÃ¡veis temporÃ¡rias

**ğŸ“ Storage - "Arquivo Permanente"**:
```solidity
Task storage task = tasks[1];  // Pegando uma tarefa jÃ¡ salva
task.isCompleted = true;       // Modificando permanentemente
```
- Ã‰ como escrever num **arquivo oficial**
- **Permanente**: Fica gravado na blockchain para sempre
- **Caro**: Custa mais gas (vocÃª estÃ¡ pagando pelo "papel oficial")
- **Uso**: Dados que precisam ser salvos

**Exemplo PrÃ¡tico**:
```solidity
function completeTask(uint256 _taskId) public {
    string memory message = "Completing task...";  // MEMORY (temporÃ¡rio)
    Task storage task = tasks[_taskId];             // STORAGE (permanente)
    task.isCompleted = true;                        // Modifica permanentemente
}
```

#### ğŸ”¢ **3. Tipos de Dados BÃ¡sicos**

**Analogia**: Como **tipos de gaveta** para guardar coisas:

```solidity
uint256 public totalTasks;           // Gaveta para NÃšMEROS (sempre positivos)
string public title;                 // Gaveta para TEXTO
bool public isCompleted;             // Gaveta para SIM/NÃƒO
address public creator;              // Gaveta para ENDEREÃ‡OS da blockchain
mapping(uint256 => Task) tasks;      // Gaveta para DICIONÃRIOS (chave â†’ valor)
```

- **`uint256`**: Como gaveta para **"nÃºmeros grandes positivos"** (0, 1, 2, 1000000...)
- **`string`**: Como gaveta para **"textos"** ("JoÃ£o", "Estudar Solidity")
- **`bool`**: Como gaveta para **"verdadeiro/falso"** (true/false, sim/nÃ£o)
- **`address`**: Como gaveta para **"CPF da blockchain"** (0x1a2b3c4d...)
- **`mapping`**: Como gaveta para **"agenda telefÃ´nica"** (nome â†’ telefone)

#### ğŸ›¡ï¸ **4. Modificadores de Visibilidade**

**Analogia**: Como **nÃ­veis de privacidade** numa empresa:

```solidity
uint256 public totalTasks;     // PÃšBLICO - Qualquer um pode ver
uint256 private secretData;    // PRIVADO - SÃ³ este contrato vÃª
uint256 internal teamData;     // INTERNO - SÃ³ "funcionÃ¡rios" (contratos filhos) veem
```

- **`public`**: Como **"mural da empresa"** - todo mundo pode ler
- **`private`**: Como **"cofre do diretor"** - sÃ³ o prÃ³prio contrato acessa
- **`internal`**: Como **"pasta da equipe"** - sÃ³ contratos "da famÃ­lia" acessam

#### âš¡ **5. Functions - As "MÃ¡quinas" do Contrato**

```solidity
function createTask(string memory _title) public payable returns (uint256) {
    // CÃ³digo aqui
    return newTaskId;
}
```

**Partes da funÃ§Ã£o**:
- **`function`**: "Esta Ã© uma mÃ¡quina"
- **`createTask`**: Nome da mÃ¡quina
- **`(string memory _title)`**: "Ingredientes" que vocÃª coloca na mÃ¡quina
- **`public`**: "Qualquer um pode usar esta mÃ¡quina"
- **`payable`**: "Esta mÃ¡quina aceita dinheiro"
- **`returns (uint256)`**: "Esta mÃ¡quina devolve um nÃºmero"

### ğŸ”¨ Framework Foundry - A "Oficina Profissional"

**Foundry** Ã© como uma **oficina mecÃ¢nica completa** para desenvolver smart contracts.

#### ğŸ¯ **Por que Foundry Ã© Especial?**

**Analogia**: Comparando **oficinas**:

**ğŸ”§ Oficina Antiga (Remix, Truffle)**:
- Como oficina de **"fundo de quintal"**
- Ferramentas bÃ¡sicas
- Tudo manual e lento
- DifÃ­cil de organizar projetos grandes

**ğŸ­ Foundry - "Oficina da Mercedes"**:
- Como oficina **profissional de montadora**
- Ferramentas de Ãºltima geraÃ§Ã£o
- Tudo automatizado e rÃ¡pido
- OrganizaÃ§Ã£o industrial

#### âš™ï¸ **Ferramentas do Foundry**

**1. ğŸ”¨ Forge - O "Martelo Inteligente"**:
```bash
forge build    # ConstrÃ³i o contrato
forge test     # Testa todas as funcionalidades
forge deploy   # Coloca na blockchain
```
- **Analogia**: Como **robÃ´ de montagem** que faz tudo automaticamente

**2. ğŸ“Š Cast - O "Medidor Universal"**:
```bash
cast call 0x... "totalTasks()"  # Consulta dados do contrato
cast send 0x... "createTask()"  # Executa funÃ§Ã£o
```
- **Analogia**: Como **multÃ­metro profissional** que mede qualquer coisa

**3. âš¡ Anvil - A "Bancada de Teste"**:
```bash
anvil  # Cria blockchain local para testes
```
- **Analogia**: Como **bancada com todos os equipamentos** para testar peÃ§as

#### ğŸš€ **Vantagens do Foundry**

**1. ğŸƒâ€â™‚ï¸ Velocidade Extrema**:
- **Testes rodam em milissegundos** (vs. segundos em outras ferramentas)
- Como comparar **Ferrari vs. bicicleta**

**2. ğŸ§ª Testes em Solidity**:
- VocÃª escreve testes **na mesma linguagem** do contrato
- Como mecÃ¢nico **usar as mesmas ferramentas** para construir e testar

**3. ğŸ“¦ GestÃ£o de DependÃªncias**:
```bash
forge install OpenZeppelin/openzeppelin-contracts
```
- Como **loja de auto-peÃ§as integrada** na oficina

**4. ğŸ” Debugging AvanÃ§ado**:
- Mostra **exatamente onde** o erro aconteceu
- Como **raio-X** que mostra problema interno

**5. â›½ AnÃ¡lise de Gas**:
- Calcula **exatamente quanto** cada funÃ§Ã£o custa
- Como **calculadora de combustÃ­vel** precisa

#### ğŸ“¦ **InstalaÃ§Ã£o do Foundry - "Montando sua Oficina"**

**Analogia**: Como **montar uma oficina profissional** em casa - vocÃª precisa das ferramentas certas!

#### ğŸ”§ **PrÃ©-requisitos (O que vocÃª precisa ter)**

**1. ğŸ’» Sistema Operacional CompatÃ­vel**:
- âœ… **Linux** (recomendado)
- âœ… **macOS** 
- âœ… **Windows** (via WSL - Windows Subsystem for Linux)

**Analogia**: Como verificar se sua **garagem tem espaÃ§o** para a oficina.

**2. ğŸ¦€ Rust (Linguagem de ProgramaÃ§Ã£o)**:
- Foundry Ã© escrito em **Rust**
- Ã‰ como o **"motor"** que faz tudo funcionar

**3. ğŸ“‹ Git (Controle de VersÃ£o)**:
- Para baixar bibliotecas e gerenciar cÃ³digo
- Como o **"sistema de entrega"** da oficina

#### ğŸš€ **InstalaÃ§Ã£o Passo a Passo**

#### **MÃ©todo 1: InstalaÃ§Ã£o AutomÃ¡tica (Recomendado)**

**1. ğŸ“¥ Instalar Foundry com um comando:**

```bash
curl -L https://foundry.paradigm.xyz | bash
```

**Analogia**: Como **"kit de oficina automÃ¡tico"** - um caminhÃ£o chega e instala tudo de uma vez!

**2. ğŸ”„ Reiniciar o terminal ou executar:**

```bash
source ~/.bashrc
```

**3. ğŸ“¦ Instalar as ferramentas:**

```bash
foundryup
```

**Analogia**: Como **"ligar todas as mÃ¡quinas"** da oficina pela primeira vez.

#### **MÃ©todo 2: InstalaÃ§Ã£o Manual (Para UsuÃ¡rios AvanÃ§ados)**

```bash
# 1. Instalar Rust (se nÃ£o tiver)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 2. Instalar Foundry via Cargo (gerenciador do Rust)
cargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked
```

#### **Para Windows (WSL)**

**1. ğŸªŸ Instalar WSL primeiro:**

```powershell
wsl --install Ubuntu
```

**2. ğŸ§ Dentro do WSL, seguir os passos do Linux:**

```bash
curl -L https://foundry.paradigm.xyz | bash
foundryup
```

**Analogia**: Como **"construir uma oficina dentro do porÃ£o"** (WSL Ã© como o porÃ£o do Windows).

#### âœ… **Verificando se Funcionou**

**Teste se as ferramentas estÃ£o instaladas:**

```bash
forge --version    # Deve mostrar versÃ£o do Forge
cast --version     # Deve mostrar versÃ£o do Cast  
anvil --version    # Deve mostrar versÃ£o do Anvil
```

**Analogia**: Como **"testar se todas as mÃ¡quinas ligam"** na sua nova oficina.

#### ğŸ› ï¸ **Criando seu Primeiro Projeto**

```bash
# 1. Criar novo projeto
forge init meu-primeiro-contrato

# 2. Entrar na pasta
cd meu-primeiro-contrato

# 3. Compilar contratos de exemplo
forge build

# 4. Rodar testes
forge test
```

**Estrutura criada automaticamente:**
```
meu-primeiro-contrato/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ Counter.sol           # Contrato de exemplo
â”œâ”€â”€ test/
â”‚   â””â”€â”€ Counter.t.sol         # Teste de exemplo
â”œâ”€â”€ script/
â”‚   â””â”€â”€ Counter.s.sol         # Script de deploy
â”œâ”€â”€ foundry.toml              # ConfiguraÃ§Ãµes
â””â”€â”€ lib/                      # Bibliotecas (vazio inicialmente)
```

**Analogia**: Como receber uma **"oficina prÃ©-montada"** com tudo organizado e um projeto de exemplo para vocÃª comeÃ§ar!

#### ğŸš¨ **Problemas Comuns e SoluÃ§Ãµes**

**1. ğŸ’£ "command not found: forge"**

**SoluÃ§Ã£o**: Reiniciar terminal ou executar:
```bash
source ~/.bashrc
# ou
source ~/.zshrc
```

**2. ğŸŒ InstalaÃ§Ã£o muito lenta**

**SoluÃ§Ã£o**: Usar um VPN ou tentar em horÃ¡rio diferente:
```bash
# Usar proxy se necessÃ¡rio
export https_proxy=http://proxy:port
```

**3. ğŸªŸ Problemas no Windows**

**SoluÃ§Ã£o**: Instalar WSL2:
```powershell
# No PowerShell como administrador
wsl --install
wsl --set-default-version 2
```

#### ğŸ’¡ **Dicas Pro**

**1. ğŸ”„ Manter Atualizado:**
```bash
foundryup  # Atualiza para a versÃ£o mais recente
```

**2. ğŸ“š Instalar Bibliotecas Ãšteis:**
```bash
# OpenZeppelin (biblioteca de seguranÃ§a)
forge install OpenZeppelin/openzeppelin-contracts

# Solmate (biblioteca otimizada)
forge install transmissions11/solmate
```

**3. âš™ï¸ Configurar VS Code:**
- Instalar extensÃ£o "Solidity"
- Configurar para usar Foundry como formatter

**Analogia**: Como **"personalizar sua oficina"** com ferramentas extras e organizaÃ§Ã£o prÃ³pria!

#### ğŸ’¼ **Foundry vs. Outras Ferramentas**

| CaracterÃ­stica | Foundry | Hardhat | Remix |
|---|---|---|---|
| **Velocidade** | ğŸï¸ Ferrari | ğŸš— Carro normal | ğŸš² Bicicleta |
| **Linguagem dos testes** | Solidity | JavaScript | Manual |
| **InstalaÃ§Ã£o** | 1 comando | ConfiguraÃ§Ã£o complexa | Browser |
| **Para iniciantes** | ğŸ“š Curva de aprendizado | ğŸ˜Š Mais fÃ¡cil | ğŸ¯ Muito simples |
| **Para profissionais** | ğŸ‘‘ PadrÃ£o da indÃºstria | âœ… Boa opÃ§Ã£o | âŒ Limitado |

#### ğŸ—ï¸ **Estrutura de Projeto Foundry**

```
meu-projeto/
â”œâ”€â”€ src/           # Contratos principais
â”œâ”€â”€ test/          # Testes
â”œâ”€â”€ script/        # Scripts de deploy  
â”œâ”€â”€ lib/           # Bibliotecas externas
â””â”€â”€ foundry.toml   # ConfiguraÃ§Ãµes
```

**Analogia**: Como **organizaÃ§Ã£o de oficina profissional**:
- `src/` = **"Ãrea de montagem"** (onde vocÃª constrÃ³i)
- `test/` = **"Ãrea de testes"** (onde vocÃª verifica qualidade)
- `script/` = **"Manuais de procedimento"** (como fazer deploy)
- `lib/` = **"Estoque de peÃ§as"** (bibliotecas de terceiros)

**ğŸ¯ ConclusÃ£o**: Foundry Ã© como **"evoluir de oficina caseira para fÃ¡brica da Tesla"** - mais profissional, mais rÃ¡pido, mais confiÃ¡vel!

### ğŸ“ Anatomia do Smart Contract TaskManager

Imagine que vamos construir uma **fÃ¡brica de gerenciamento de tarefas** na blockchain. Vamos dissecar cada peÃ§a desta mÃ¡quina:

#### ğŸ—ï¸ **Estrutura BÃ¡sica do Contrato - A "CertidÃ£o de Nascimento"**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract TaskManager {
    // CÃ³digo do contrato aqui
}
```

**Analogia**: Ã‰ como o **cabeÃ§alho de um documento oficial**:

- **`SPDX-License-Identifier: MIT`**: Como uma **"licenÃ§a de uso"** - MIT significa "qualquer um pode usar gratuitamente"
  - Ã‰ como colocar "DomÃ­nio PÃºblico" numa mÃºsica
  
- **`pragma solidity ^0.8.13`**: Define a **"versÃ£o do idioma"** que estamos falando
  - Como dizer "este documento estÃ¡ escrito em PortuguÃªs versÃ£o 2024"
  - `^0.8.13` = "versÃ£o 8.13 ou mais nova, mas nÃ£o versÃ£o 9"
  
- **`contract TaskManager`**: Ã‰ o **nome da nossa empresa/fÃ¡brica**
  - Como "Papelaria JoÃ£o" ou "Padaria do Seu JosÃ©"

#### ğŸ’ **VariÃ¡veis e Constantes - As "Regras da Casa"**

```solidity
uint256 public constant MINIMUM_STAKE = 0.001 ether;
uint256 public totalTasks;
```

**Analogia**: Como **regras afixadas na parede** de um estabelecimento:

- **`MINIMUM_STAKE = 0.001 ether`**: Ã‰ o **"preÃ§o mÃ­nimo da entrada"**
  - Como uma placa: "Taxa mÃ­nima: R$ 5,00"
  - `constant` = Esta regra **NUNCA muda** (como "gravada em pedra")
  - `public` = **Todos podem ver** esta regra (estÃ¡ na parede para todos lerem)
  - `uint256` = Tipo de nÃºmero (sempre positivo, muito grande)
  
- **`totalTasks`**: Ã‰ o **"contador da porta"** daqueles cinemas
  - Conta quantas pessoas (tarefas) jÃ¡ entraram
  - ComeÃ§a em 0 e vai aumentando: 1, 2, 3, 4...
  - Ã‰ como um **"odÃ´metro" de tarefas criadas**

#### ğŸ“‹ **Struct Task - Nossa "Ficha de Cadastro"**

```solidity
struct Task {
    uint256 id;           // Identificador Ãºnico
    string title;         // TÃ­tulo da tarefa
    string description;   // DescriÃ§Ã£o detalhada
    uint256 createdAt;    // Quando foi criada (timestamp)
    uint256 deadline;     // Prazo limite (timestamp)
    bool isCompleted;     // Se foi concluÃ­da (true/false)
    address creator;      // Quem criou a tarefa
    uint256 stake;        // Valor apostado em wei
    bool stakeProcessed;  // Se o stake jÃ¡ foi processado
}
```

**Analogia**: Ã‰ como uma **ficha de cadastro mÃ©dico completa**:

- **`id`**: NÃºmero da **carteirinha do paciente** (Ãºnico, nunca repete)
- **`title`**: **Nome do tratamento** ("Consulta cardiolÃ³gica")
- **`description`**: **Detalhes do procedimento** ("Exame completo do coraÃ§Ã£o")
- **`createdAt`**: **Data de abertura da ficha** (quando foi criado o cadastro)
- **`deadline`**: **Data da consulta marcada** (prazo para completar)
- **`isCompleted`**: **"Paciente compareceu?"** (âœ… Sim / âŒ NÃ£o)
- **`creator`**: **EndereÃ§o de quem fez o agendamento** (CPF da pessoa)
- **`stake`**: **Valor da consulta** (quanto foi pago)
- **`stakeProcessed`**: **"Pagamento foi processado?"** (evita cobrar duas vezes)

**Por que struct?** Ã‰ como ter um **"formulÃ¡rio padrÃ£o"** - toda tarefa tem exatamente os mesmos campos preenchidos!

#### ğŸ—ºï¸ **Mappings - Nossos "Arquivos Organizados"**

```solidity
mapping(uint256 => Task) public tasks;
mapping(address => uint256[]) public userTasks;
```

**Analogia**: Como **dois sistemas de arquivo diferentes**:

**1. `tasks` - O "Arquivo Geral por NÃºmero"**
- Ã‰ como um **arquivo mÃ©dico por nÃºmero de protocolo**
- VocÃª fala: "Quero ver a ficha nÃºmero 1" â†’ Recebe todos os dados da Tarefa 1
- `uint256` = nÃºmero da tarefa (1, 2, 3...)
- `Task` = ficha completa com todos os dados
- Ã‰ como uma **gaveta numerada**: Gaveta 1 = Ficha 1, Gaveta 2 = Ficha 2...

**2. `userTasks` - O "Ãndice por Pessoa"**
- Ã‰ como um **caderno de "quem tem consulta marcada"**
- VocÃª fala: "Quais sÃ£o as consultas do JoÃ£o?" â†’ Recebe: [1, 5, 8] (nÃºmeros das fichas dele)
- `address` = "CPF" da pessoa na blockchain (0x1a2b3c4d...)
- `uint256[]` = lista de nÃºmeros das tarefas daquela pessoa

**Exemplo prÃ¡tico**:
- JoÃ£o criou 3 tarefas (IDs: 1, 3, 5)
- Maria criou 2 tarefas (IDs: 2, 4)
- `tasks[1]` = dados completos da tarefa 1 (do JoÃ£o)
- `userTasks[JoÃ£o]` = [1, 3, 5] (lista das tarefas do JoÃ£o)

#### ğŸ“¢ **Eventos - O "Jornal da Empresa"**

```solidity
event TaskCreated(uint256 taskId, address creator, string title, uint256 deadline, uint256 stake);
event TaskCompleted(uint256 taskId, address creator, uint256 stakeReturned);
event StakeLost(uint256 taskId, address creator, uint256 stakeLost);
```

**Analogia**: Como **manchetes de jornal que ficam arquivadas para sempre**:

**ğŸ” Por que eventos?**
- A blockchain Ã© como um **"cofre fechado"** - vocÃª nÃ£o pode "bisbilhotar" o que estÃ¡ dentro
- Eventos sÃ£o como **"recortes de jornal"** que saem do cofre e ficam acessÃ­veis
- Ã‰ uma forma de **"avisar o mundo exterior"** o que aconteceu

**ğŸ“° Nossos "tipos de notÃ­cia"**:

**1. `TaskCreated` - "Nascimentos"**
- **Manchete**: "Nova tarefa foi criada!"
- **Detalhes**: ID da tarefa, quem criou, tÃ­tulo, prazo, quanto apostou
- Como anunciar: "FamÃ­lia Silva teve um bebÃª! Nome: JoÃ£o, nasceu dia 15/03"

**2. `TaskCompleted` - "Sucessos"**
- **Manchete**: "Tarefa concluÃ­da no prazo!"
- **Detalhes**: Qual tarefa, quem completou, quanto dinheiro recebeu de volta
- Como anunciar: "JoÃ£o Silva se formou! Recebeu diploma e prÃªmio de R$ 1000"

**3. `StakeLost` - "Penalties"**
- **Manchete**: "Prazo perdido!"
- **Detalhes**: Qual tarefa, quem perdeu o prazo, quanto dinheiro foi perdido
- Como anunciar: "JoÃ£o Silva perdeu aposta de R$ 500 por nÃ£o entregar projeto"

**ğŸ”— Importante**: Estes "jornais" ficam **gravados para sempre** na blockchain - qualquer site pode ler e mostrar essas notificaÃ§Ãµes!

#### ğŸ› ï¸ **FunÃ§Ã£o createTask() - A "MÃ¡quina de Fazer Tarefas"**

```solidity
function createTask(string memory _title, string memory _description, uint256 _deadline) 
    public payable
{
    // VerificaÃ§Ãµes de seguranÃ§a
    require(_deadline > block.timestamp, "Deadline must be in the future");
    require(msg.value >= MINIMUM_STAKE, "Stake must be at least 0.001 ether");

    totalTasks++;  // Incrementa contador

    // Cria nova tarefa
    tasks[totalTasks] = Task({
        id: totalTasks,
        title: _title,
        description: _description,
        createdAt: block.timestamp,
        deadline: _deadline,
        isCompleted: false,
        creator: msg.sender,
        stake: msg.value,
        stakeProcessed: false
    });

    userTasks[msg.sender].push(totalTasks);  // Adiciona Ã  lista do usuÃ¡rio
    
    emit TaskCreated(totalTasks, msg.sender, _title, _deadline, msg.value);  // Emite evento
}
```

**Analogia**: Como uma **mÃ¡quina de fazer apostas em corrida de cavalos**:

**ğŸ° Como funciona a mÃ¡quina:**

**Entrada (ParÃ¢metros)**:
- **`_title`**: Nome do seu cavalo ("Estudar Solidity")
- **`_description`**: DescriÃ§Ã£o da corrida ("Completar curso em 30 dias")
- **`_deadline`**: Data da corrida (timestamp futuro)
- **`payable`**: A mÃ¡quina **aceita dinheiro** junto com o pedido

**ğŸ›¡ï¸ SeguranÃ§as da MÃ¡quina (require)**:
```solidity
require(_deadline > block.timestamp, "Deadline must be in the future");
```
- **Analogia**: Como um **seguranÃ§a na porta** que verifica se vocÃª nÃ£o estÃ¡ tentando apostar numa corrida que jÃ¡ acabou
- `block.timestamp` = "que horas sÃ£o agora na blockchain"
- Ã‰ como dizer: "SÃ³ aceito apostas para corridas futuras!"

```solidity
require(msg.value >= MINIMUM_STAKE, "Stake must be at least 0.001 ether");
```
- **Analogia**: Como um **caixa** que verifica se vocÃª trouxe dinheiro suficiente
- `msg.value` = quanto dinheiro vocÃª colocou na mÃ¡quina
- Ã‰ como: "Aposta mÃ­nima: R$ 5,00"

**ğŸ­ ProduÃ§Ã£o da Ficha (CriaÃ§Ã£o da Task)**:
```solidity
totalTasks++;  // Gera nÃºmero sequencial da ficha
```
- Como uma **mÃ¡quina de senha do banco**: 001, 002, 003...

```solidity
tasks[totalTasks] = Task({...});
```
- **Analogia**: Como **preencher uma ficha de aposta completa**:
  - `id`: NÃºmero da sua aposta (Ãºnico)
  - `title` e `description`: Nome e detalhes do cavalo
  - `createdAt`: "Hora que fez a aposta" (agora)
  - `deadline`: "Hora da corrida"
  - `isCompleted: false`: "Corrida ainda nÃ£o aconteceu"
  - `creator`: "Seu CPF" (quem fez a aposta)
  - `stake`: "Quanto vocÃª apostou"
  - `stakeProcessed: false`: "Pagamento ainda nÃ£o foi processado"

**ğŸ“ OrganizaÃ§Ã£o (userTasks)**:
```solidity
userTasks[msg.sender].push(totalTasks);
```
- **Analogia**: Como **anotar no seu caderno pessoal**: "Apostas que fiz: 1, 5, 12"
- A mÃ¡quina lembra **todas as suas apostas**

**ğŸ“¢ DivulgaÃ§Ã£o (Evento)**:
```solidity
emit TaskCreated(...);
```
- **Analogia**: Como **anunciar no alto-falante**: "JoÃ£o Silva fez aposta #5 no cavalo 'Estudar Solidity' para corrida do dia 15!"
- Todo mundo pode **ouvir** este anÃºncio

#### âœ… **FunÃ§Ã£o completeTask() - O "Juiz da Corrida"**

```solidity
function completeTask(uint256 _taskId) public
{
    // VerificaÃ§Ãµes
    require(_taskId > 0 && _taskId <= totalTasks, "Task does not exist");
    require(tasks[_taskId].creator == msg.sender, "Only task creator can call this function");
    
    Task storage task = tasks[_taskId];
    require(!task.isCompleted, "Task is already completed");
    require(!task.stakeProcessed, "Stake has already been processed");

    task.isCompleted = true;
    task.stakeProcessed = true;

    // LÃ³gica do stake
    if (block.timestamp <= task.deadline) {
        // No prazo = devolve o dinheiro
        (bool success, ) = payable(task.creator).call{value: task.stake}("");
        require(success, "Failed to return stake");
        emit TaskCompleted(_taskId, task.creator, task.stake);
    } else {
        // Atrasado = perde o dinheiro
        emit StakeLost(_taskId, task.creator, task.stake);
    }
}
```

**Analogia**: Como um **juiz rigoroso de corrida** que decide se vocÃª ganhou ou perdeu a aposta:

**ğŸ” VerificaÃ§Ãµes do Juiz (requires)**:

```solidity
require(_taskId > 0 && _taskId <= totalTasks, "Task does not exist");
```
- **Analogia**: "Esta aposta existe?" - Como verificar se o **bilhete Ã© vÃ¡lido**
- Evita que alguÃ©m invente nÃºmeros de apostas

```solidity
require(tasks[_taskId].creator == msg.sender, "Only task creator can call this function");
```
- **Analogia**: "VocÃª Ã© realmente dono desta aposta?" - Como pedir **documento de identidade**
- SÃ³ quem fez a aposta pode reivindicar o prÃªmio

```solidity
require(!task.isCompleted, "Task is already completed");
require(!task.stakeProcessed, "Stake has already been processed");
```
- **Analogia**: "Esta corrida jÃ¡ foi julgada?" - Evita **duplicar pagamentos**
- Como carimbar "PAGO" no bilhete para nÃ£o pagar duas vezes

**ğŸ“ MarcaÃ§Ã£o dos Resultados**:
```solidity
task.isCompleted = true;
task.stakeProcessed = true;
```
- **Analogia**: Carimbar na ficha: **"CORRIDA FINALIZADA"** e **"PAGAMENTO PROCESSADO"**

**ğŸ’° A Grande DecisÃ£o - LÃ³gica do Pagamento**:
```solidity
if (block.timestamp <= task.deadline) {
    // GANHOU!
} else {
    // PERDEU!
}
```

**ğŸ¯ CENÃRIO 1 - GANHOU (No prazo)**:
```solidity
(bool success, ) = payable(task.creator).call{value: task.stake}("");
require(success, "Failed to return stake");
emit TaskCompleted(_taskId, task.creator, task.stake);
```
- **Analogia**: Como o **caixa do hipÃ³dromo pagando sua aposta**
- `payable(task.creator).call{value: task.stake}("")` = "Transferir dinheiro para o ganhador"
- `require(success...)` = "Garantir que o dinheiro chegou na conta"
- `emit TaskCompleted(...)` = "Anunciar no alto-falante: JoÃ£o ganhou R$ 100!"

**ğŸ’¸ CENÃRIO 2 - PERDEU (Atrasado)**:
```solidity
emit StakeLost(_taskId, task.creator, task.stake);
```
- **Analogia**: Como **rasgar o bilhete de aposta perdida**
- O dinheiro fica "na casa" (no contrato)
- `emit StakeLost(...)` = "Anunciar: JoÃ£o perdeu R$ 100 por atraso"

**ğŸ° Sistema de Incentivos**:
- â° **Chegou no prazo**: Dinheiro volta 100% + sensaÃ§Ã£o de vitÃ³ria
- âŒ **Atrasou**: Perde o dinheiro + liÃ§Ã£o aprendida
- ğŸ§  **Psicologia**: A possibilidade de perder dinheiro **motiva** vocÃª a cumprir prazos!

#### ğŸ“‹ **FunÃ§Ãµes de Consulta - Os "RelatÃ³rios" do Sistema**

Agora vamos entender as funÃ§Ãµes que **apenas consultam dados** (nÃ£o gastam gas e nÃ£o modificam nada):

#### ğŸ” **1. getUserTasks() - O "Extrato de Tarefas"**

```solidity
function getUserTasks(address _user) public view returns (uint256[] memory) {
    return userTasks[_user];
}
```

**Analogia**: Como **"pedir extrato bancÃ¡rio"** de uma pessoa especÃ­fica.

**ğŸ“– ExplicaÃ§Ã£o:**
- **`address _user`**: "CPF" da pessoa que queremos consultar
- **`uint256[] memory`**: Lista dos **nÃºmeros das tarefas** (nÃ£o os dados completos)
- **`userTasks[_user]`**: Busca na "agenda" quais tarefas pertencem Ã quela pessoa
- **Exemplo de retorno**: `[1, 3, 7]` = pessoa tem as tarefas 1, 3 e 7

#### ğŸ“Š **2. getUserTasksWithData() - O "RelatÃ³rio Completo"**

```solidity
function getUserTasksWithData(address _user) public view returns (Task[] memory) {
    uint256[] memory taskIds = userTasks[_user];
    Task[] memory userTasksData = new Task[](taskIds.length);
    
    for (uint256 i = 0; i < taskIds.length; i++) {
        userTasksData[i] = tasks[taskIds[i]];
    }
    
    return userTasksData;
}
```

**Analogia**: Como **"pedir histÃ³rico completo"** ao invÃ©s de sÃ³ os nÃºmeros das operaÃ§Ãµes.

**ğŸ“– ExplicaÃ§Ã£o linha por linha:**

```solidity
uint256[] memory taskIds = userTasks[_user];
```
- **O que faz**: Primeiro pega a **lista de nÃºmeros** das tarefas da pessoa
- **Analogia**: Como pegar a lista "1, 3, 7" do extrato

```solidity
Task[] memory userTasksData = new Task[](taskIds.length);
```
- **O que faz**: Cria um **"relatÃ³rio em branco"** com espaÃ§o para todas as tarefas
- **Analogia**: Como preparar uma pasta com o nÃºmero exato de folhas necessÃ¡rias

```solidity
for (uint256 i = 0; i < taskIds.length; i++) {
    userTasksData[i] = tasks[taskIds[i]];
}
```
- **O que faz**: **Para cada nÃºmero** da lista, busca os **dados completos** da tarefa
- **Analogia**: Como "pegar cada nÃºmero do extrato e buscar os detalhes completos da operaÃ§Ã£o"

**ğŸš€ Por que esta funÃ§Ã£o Ã© importante:**
- **Uma Ãºnica chamada**: Ao invÃ©s de chamar `getUserTasks()` + vÃ¡rias vezes `getTask()`
- **Mais eficiente**: Economiza gas e tempo
- **Dados completos**: Retorna tudo: tÃ­tulo, descriÃ§Ã£o, prazo, status, etc.

#### ğŸ” **3. getTask() - O "Consultor Individual"**

```solidity
function getTask(uint256 _id) public view returns (Task memory) {
    return tasks[_id];
}
```

**Analogia**: Como **"pedir detalhes de uma compra especÃ­fica"** pelo nÃºmero da nota fiscal.

**ğŸ“– ExplicaÃ§Ã£o:**
- **`uint256 _id`**: NÃºmero da tarefa que queremos consultar
- **`Task memory`**: Dados completos da tarefa (struct inteira)
- **Uso**: Para ver detalhes de UMA tarefa especÃ­fica

#### ğŸ“Š **4. getTaskCount() - O "Contador Global"**

```solidity
function getTaskCount() public view returns (uint256) {
    return taskCount;
}
```

**Analogia**: Como **"quantas pessoas jÃ¡ se cadastraram"** no sistema.

**ğŸ“– ExplicaÃ§Ã£o:**
- **Retorna**: NÃºmero total de tarefas jÃ¡ criadas por todos os usuÃ¡rios
- **Uso**: Para estatÃ­sticas gerais do sistema

#### ğŸ’° **5. getContractBalance() - O "Cofre do Sistema"**

```solidity
function getContractBalance() public view returns (uint256) {
    return address(this).balance;
}
```

**Analogia**: Como **"quanto dinheiro tem no cofre"** da empresa.

**ğŸ“– ExplicaÃ§Ã£o:**
- **`address(this).balance`**: Saldo total do contrato em wei
- **O que representa**: Todo o ETH apostado em tarefas pendentes + tarefas perdidas
- **Uso**: Para transparÃªncia financeira do sistema

#### â° **6. isTaskOverdue() - O "Detector de Atraso"**

```solidity
function isTaskOverdue(uint256 _id) public view returns (bool) {
    Task memory task = tasks[_id];
    return !task.status && block.timestamp > task.deadline;
}
```

**Analogia**: Como **"verificar se a conta estÃ¡ vencida"**.

**ğŸ“– ExplicaÃ§Ã£o linha por linha:**

```solidity
Task memory task = tasks[_id];
```
- **O que faz**: Busca os dados da tarefa pelo ID

```solidity
return !task.status && block.timestamp > task.deadline;
```
- **`!task.status`**: Tarefa ainda **nÃ£o foi concluÃ­da** (false)
- **`block.timestamp > task.deadline`**: **Agora** Ã© depois do prazo
- **`&&`**: SÃ³ Ã© "atrasada" se **AMBAS** as condiÃ§Ãµes forem verdadeiras
- **Retorna**: `true` = atrasada, `false` = nÃ£o atrasada

**ğŸ¯ LÃ³gica completa:**
- âœ… **ConcluÃ­da no prazo**: `status = true` â†’ nÃ£o Ã© atrasada
- âœ… **Pendente no prazo**: `status = false` + `agora < prazo` â†’ nÃ£o Ã© atrasada  
- âŒ **Pendente apÃ³s prazo**: `status = false` + `agora > prazo` â†’ **Ã‰ ATRASADA**

### ğŸ§ª LaboratÃ³rio de Testes (TaskManager.t.sol)

Os testes sÃ£o como **laboratÃ³rio de qualidade** - testamos tudo antes de lanÃ§ar no mercado. Vamos dissecar cada teste para entender como garantimos que nosso contrato funciona perfeitamente:

#### ğŸ”§ **PreparaÃ§Ã£o do LaboratÃ³rio (Setup)**

```solidity
contract TaskManagerTest is Test {
    TaskManager public taskManager;
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");

    event TaskCreated(uint256 id, string title, address creator, uint256 stakeAmount, uint256 deadline);
    event TaskCompleted(uint256 id, uint256 stakeReturned);
    event StakeLost(uint256 id, uint256 stakeAmount);

    function setUp() public {
        taskManager = new TaskManager();
        vm.deal(user1, 1 ether);
        vm.deal(user2, 1 ether);
    }
}
```

**Analogia**: Como **montar um laboratÃ³rio de teste** para uma fÃ¡brica de carros:

**ğŸ“‹ DeclaraÃ§Ãµes de recursos:**
- **`TaskManager public taskManager`**: O **"protÃ³tipo do carro"** que vamos testar
- **`address public user1/user2`**: **"Motoristas de teste"** (bonecos de crash test)
- **`event ...`**: **"Sensores"** que detectam se os eventos corretos foram emitidos

**ğŸ­ PreparaÃ§Ã£o antes de cada teste (`setUp()`):**
- **`taskManager = new TaskManager()`**: **"Construir um carro novo"** para cada teste
- **`vm.deal(user1, 1 ether)`**: **"Dar combustÃ­vel"** para o motorista de teste
- **Analogia**: Como resetar completamente o laboratÃ³rio antes de cada experimento

---

#### âœ… **Teste 1: test_CreateTask() - "Teste de IgniÃ§Ã£o"**

```solidity
function test_CreateTask() public {
    uint256 stakeAmount = 0.001 ether;
    uint256 deadline = block.timestamp + 1000;
    
    vm.prank(user1);
    taskManager.createTask{value: stakeAmount}("Estudar Solidity", "Completar tutorial", deadline);
    
    assertEq(taskManager.getTaskCount(), 1);
    
    TaskManager.Task memory task = taskManager.getTask(1);
    assertEq(task.stakeAmount, stakeAmount);
    assertEq(task.deadline, deadline);
    assertEq(task.status, false);
    assertEq(task.creator, user1);
}
```

**Analogia**: Como **testar se o carro liga e acelera**:

**ğŸ”‘ PreparaÃ§Ã£o do Teste:**
```solidity
uint256 stakeAmount = 0.001 ether;
uint256 deadline = block.timestamp + 1000;
```
- **Analogia**: **"Preparar o combustÃ­vel e definir destino"**
- **stakeAmount**: Quanto "combustÃ­vel" colocar (0.001 ETH)
- **deadline**: "Quando queremos chegar" (agora + 1000 segundos)

**ğŸš— Simular motorista:**
```solidity
vm.prank(user1);
```
- **Analogia**: **"Colocar o user1 no banco do motorista"**
- **vm.prank()**: Simula que a prÃ³xima aÃ§Ã£o vem do user1

**ğŸ”¥ AÃ§Ã£o testada:**
```solidity
taskManager.createTask{value: stakeAmount}("Estudar Solidity", "Completar tutorial", deadline);
```
- **Analogia**: **"Virar a chave, pisar no acelerador e partir"**
- **{value: stakeAmount}**: Envia ETH junto com a transaÃ§Ã£o

**ğŸ” VerificaÃ§Ãµes mÃºltiplas:**
```solidity
assertEq(taskManager.getTaskCount(), 1);  // Contador aumentou?
TaskManager.Task memory task = taskManager.getTask(1);  // Buscar dados da tarefa
assertEq(task.stakeAmount, stakeAmount);  // Valor salvo corretamente?
assertEq(task.deadline, deadline);       // Prazo salvo corretamente?
assertEq(task.status, false);           // Status inicial pendente?
assertEq(task.creator, user1);          // Criador correto?
```
- **Analogia**: **"Verificar se todos os instrumentos do painel funcionam"**

**âœ… O que este teste garante:**
- Motor da criaÃ§Ã£o funciona
- Dados sÃ£o salvos corretamente
- Contador estÃ¡ funcionando
- Valores sÃ£o preservados

---

#### âœ… **Teste 2: test_CompleteTask() - "Teste de Freios e DevoluÃ§Ã£o"**

```solidity
function test_CompleteTask() public {
    uint256 stakeAmount = 0.001 ether;
    uint256 deadline = block.timestamp + 1000;
    uint256 initialBalance = user1.balance;
    
    // Criar tarefa
    vm.prank(user1);
    taskManager.createTask{value: stakeAmount}("Estudar Solidity", "Completar tutorial", deadline);
    
    // Completar tarefa
    vm.prank(user1);
    taskManager.completeTask(1);
    
    // Verificar se recebeu o stake de volta
    uint256 finalBalance = user1.balance;
    assertEq(finalBalance, initialBalance);
    
    TaskManager.Task memory task = taskManager.getTask(1);
    assertEq(task.status, true);
    assertEq(task.stakeReturned, true);
}
```

**Analogia**: Como **testar freios e sistema de devoluÃ§Ã£o**:

**ğŸ“Š MediÃ§Ãµes iniciais:**
```solidity
uint256 initialBalance = user1.balance;
```
- **Analogia**: **"Medir velocidade antes de frear"** (dinheiro inicial)

**ğŸ Primeira fase - Acelerar:**
```solidity
vm.prank(user1);
taskManager.createTask{value: stakeAmount}("Estudar Solidity", "Completar tutorial", deadline);
```
- **Analogia**: **"Acelerar atÃ© 100 km/h"** (criar tarefa e apostar dinheiro)

**ğŸ›‘ Segunda fase - Frear:**
```solidity
vm.prank(user1);
taskManager.completeTask(1);
```
- **Analogia**: **"Pisar no freio"** (completar a tarefa)

**ğŸ” VerificaÃ§Ã£o do sistema de seguranÃ§a:**
```solidity
uint256 finalBalance = user1.balance;
assertEq(finalBalance, initialBalance);  // Dinheiro voltou?
assertEq(task.status, true);            // Status mudou para concluÃ­da?
assertEq(task.stakeReturned, true);     // Flag de devoluÃ§Ã£o ativada?
```
- **Analogia**: **"Confirmar que parou na posiÃ§Ã£o exata e airbag nÃ£o disparou"**

**âœ… O que este teste garante:**
- Sistema de conclusÃ£o funciona
- Dinheiro Ã© devolvido corretamente
- Status Ã© atualizado
- NÃ£o hÃ¡ vazamentos de dinheiro

---

#### ğŸ“‹ **Teste 3: test_ListUserTasks() - "Teste do Sistema de NavegaÃ§Ã£o"**

```solidity
function test_ListUserTasks() public {
    uint256 stakeAmount = 0.001 ether;
    uint256 deadline = block.timestamp + 1000;
    
    // User1 cria 3 tarefas
    vm.startPrank(user1);
    taskManager.createTask{value: stakeAmount}("Tarefa 1", "Primeira tarefa", deadline);
    taskManager.createTask{value: stakeAmount}("Tarefa 2", "Segunda tarefa", deadline);
    taskManager.createTask{value: stakeAmount}("Tarefa 3", "Terceira tarefa", deadline);
    vm.stopPrank();
    
    // Verificar tarefas do usuÃ¡rio
    uint256[] memory userTasks = taskManager.getUserTasks(user1);
    
    assertEq(userTasks.length, 3);
    assertEq(userTasks[0], 1);
    assertEq(userTasks[1], 2);
    assertEq(userTasks[2], 3);
    
    // Verificar que total de tarefas Ã© 3
    assertEq(taskManager.getTaskCount(), 3);
    
    // Verificar detalhes de cada tarefa
    for (uint i = 0; i < userTasks.length; i++) {
        TaskManager.Task memory task = taskManager.getTask(userTasks[i]);
        assertEq(task.creator, user1);
        assertEq(task.stakeAmount, stakeAmount);
        assertEq(task.status, false); // Todas ainda pendentes
    }
}
```

**Analogia**: Como **testar o sistema de navegaÃ§Ã£o GPS completo**:

**ğŸ—ºï¸ Programar mÃºltiplos destinos:**
```solidity
vm.startPrank(user1);  // User1 assume controle
// Criar 3 destinos: Casa â†’ Trabalho â†’ Shopping
taskManager.createTask{value: stakeAmount}("Tarefa 1", "Primeira tarefa", deadline);
taskManager.createTask{value: stakeAmount}("Tarefa 2", "Segunda tarefa", deadline);
taskManager.createTask{value: stakeAmount}("Tarefa 3", "Terceira tarefa", deadline);
vm.stopPrank();  // User1 solta controle
```
- **Analogia**: **"Programar rota com 3 paradas"**

**ğŸ“± Consultar GPS:**
```solidity
uint256[] memory userTasks = taskManager.getUserTasks(user1);
```
- **Analogia**: **"Perguntar ao GPS: qual minha rota?"**

**ğŸ” Verificar se GPS lembra tudo:**
```solidity
assertEq(userTasks.length, 3);  // GPS lembra dos 3 destinos?
assertEq(userTasks[0], 1);      // Primeiro destino Ã© o ID 1?
assertEq(userTasks[1], 2);      // Segundo destino Ã© o ID 2?
assertEq(userTasks[2], 3);      // Terceiro destino Ã© o ID 3?
```

**ğŸ“Š Verificar estatÃ­sticas globais:**
```solidity
assertEq(taskManager.getTaskCount(), 3);  // Total no sistema = 3?
```

**ğŸ” Verificar detalhes individuais:**
```solidity
for (uint i = 0; i < userTasks.length; i++) {
    TaskManager.Task memory task = taskManager.getTask(userTasks[i]);
    assertEq(task.creator, user1);      // Todas pertencem ao user1?
    assertEq(task.stakeAmount, stakeAmount);  // Mesmo valor apostado?
    assertEq(task.status, false);       // Todas ainda pendentes?
}
```
- **Analogia**: **"Verificar cada destino individualmente"**

**âœ… O que este teste garante:**
- Sistema de listagem funciona
- Isolamento entre usuÃ¡rios
- Contadores estÃ£o corretos
- Dados individuais preservados

---

#### ğŸš€ **Teste 4: test_GetUserTasksWithData() - "Teste do RelatÃ³rio Completo"**

```solidity
function test_GetUserTasksWithData() public {
    uint256 stakeAmount = 0.001 ether;
    uint256 deadline = block.timestamp + 1000;
    
    // User1 cria 4 tarefas
    vm.startPrank(user1);
    taskManager.createTask{value: stakeAmount}("Tarefa A", "Descricao A", deadline);
    taskManager.createTask{value: stakeAmount}("Tarefa B", "Descricao B", deadline + 100);
    taskManager.createTask{value: stakeAmount}("Tarefa C", "Descricao C", deadline + 200);
    taskManager.createTask{value: stakeAmount}("Tarefa D", "Descricao D", deadline + 300);
    vm.stopPrank();
    
    // User2 cria 1 tarefa (para garantir isolamento)
    vm.prank(user2);
    taskManager.createTask{value: stakeAmount}("Tarefa User2", "Descricao User2", deadline);
    
    // Completar 2 tarefas do user1
    vm.startPrank(user1);
    taskManager.completeTask(1); // Tarefa A completada
    taskManager.completeTask(3); // Tarefa C completada
    vm.stopPrank();
    
    // ğŸ¯ BUSCAR TAREFAS COM DADOS COMPLETOS
    TaskManager.Task[] memory userTasksWithData = taskManager.getUserTasksWithData(user1);
    
    // VerificaÃ§Ãµes extensivas...
}
```

**Analogia**: Como **testar um sistema de relatÃ³rio empresarial completo**:

**ğŸ“Š Criar cenÃ¡rio complexo:**
- **4 projetos** do user1 com prazos diferentes
- **1 projeto** do user2 (para testar isolamento)
- **2 projetos concluÃ­dos** pelo user1
- **2 projetos pendentes** do user1

**ğŸ¯ Buscar relatÃ³rio completo:**
```solidity
TaskManager.Task[] memory userTasksWithData = taskManager.getUserTasksWithData(user1);
```
- **Analogia**: **"Gerar relatÃ³rio executivo com todos os detalhes"**

**ğŸ” VerificaÃ§Ãµes detalhadas:**
- **Quantidade correta**: 4 tarefas do user1
- **Dados individuais**: TÃ­tulo, descriÃ§Ã£o, criador, stake
- **Status corretos**: 2 concluÃ­das, 2 pendentes
- **Flags corretas**: stakeReturned para as concluÃ­das
- **Isolamento**: User2 tem apenas 1 tarefa
- **ConsistÃªncia**: Dados idÃªnticos ao `getTask()` individual

**ğŸ“Š CÃ¡lculos de mÃ©tricas:**
```solidity
uint256 completedTasks = 0;
uint256 pendingTasks = 0;
uint256 totalStakeInPending = 0;

for (uint i = 0; i < userTasksWithData.length; i++) {
    if (userTasksWithData[i].status) {
        completedTasks++;
    } else {
        pendingTasks++;
        totalStakeInPending += userTasksWithData[i].stakeAmount;
    }
}
```
- **Analogia**: **"Calcular estatÃ­sticas do relatÃ³rio"**

**âœ… O que este teste garante:**
- FunÃ§Ã£o otimizada funciona corretamente
- Isolamento entre usuÃ¡rios
- ConsistÃªncia dos dados
- CÃ¡lculos de mÃ©tricas corretos
- Performance (uma chamada vs. mÃºltiplas)

---

#### ğŸ”„ **Teste 5: test_GetUserTasksWithData_EmptyUser() - "Teste de UsuÃ¡rio Vazio"**

```solidity
function test_GetUserTasksWithData_EmptyUser() public {
    address emptyUser = makeAddr("emptyUser");
    
    TaskManager.Task[] memory emptyUserTasks = taskManager.getUserTasksWithData(emptyUser);
    
    assertEq(emptyUserTasks.length, 0, "Usuario sem tarefas deve retornar array vazio");
}
```

**Analogia**: Como **testar o que acontece com cliente novo**:

**ğŸ†• Cliente sem histÃ³rico:**
- **emptyUser**: Cliente que nunca fez nada no sistema
- **Expectativa**: Sistema deve retornar lista vazia (nÃ£o dar erro)

**âœ… O que este teste garante:**
- Sistema nÃ£o quebra com usuÃ¡rios novos
- Arrays vazios sÃ£o tratados corretamente
- NÃ£o hÃ¡ vazamentos entre usuÃ¡rios

---

#### ğŸ¯ **Por que Estes Testes SÃ£o Cruciais?**

**ğŸ›¡ï¸ SeguranÃ§a financeira:**
- **Testa devoluÃ§Ã£o de ETH**: Garante que dinheiro nÃ£o se perde
- **Verifica isolamento**: User1 nÃ£o acessa dados do User2
- **Previne reentrancy**: Flags impedem duplos saques

**ğŸ“Š Confiabilidade dos dados:**
- **ConsistÃªncia**: Dados sÃ£o os mesmos em diferentes funÃ§Ãµes
- **Integridade**: Contadores e listas sempre corretos
- **Performance**: FunÃ§Ãµes otimizadas funcionam igual Ã s bÃ¡sicas

**ğŸ”„ Cobertura completa:**
- **Casos normais**: CriaÃ§Ã£o e conclusÃ£o de tarefas
- **Casos extremos**: UsuÃ¡rios vazios, mÃºltiplas tarefas
- **Casos mistos**: Algumas concluÃ­das, outras pendentes

**ğŸš€ ConfianÃ§a para produÃ§Ã£o:**
- **Cada linha testada**: Sabemos que tudo funciona
- **Casos reais simulados**: Testamos como usuÃ¡rios reais usariam
- **Prova de funcionamento**: EvidÃªncia que o cÃ³digo estÃ¡ correto

**âœ… Resultado:** Um contrato **blindado** e pronto para lidar com dinheiro real! ğŸ›¡ï¸

#### ğŸ¯ **Dicas de Testes Adicionais - "Expandindo o LaboratÃ³rio"**

Nosso contrato atual tem 3 testes bÃ¡sicos, mas poderÃ­amos **"testar muito mais"**! Aqui estÃ£o ideias de **testes que vocÃª pode implementar**:

#### ğŸ›¡ï¸ **Testes de SeguranÃ§a - "Teste de InvasÃ£o"**

**Analogia**: Como **testar a seguranÃ§a de um banco** - tentar todas as formas de roubar!

**1. Teste de AutorizaÃ§Ã£o:**
```solidity
function testOnlyOwnerCanComplete() public {
    // UsuÃ¡rio 1 cria tarefa
    // UsuÃ¡rio 2 tenta completar tarefa do usuÃ¡rio 1
    // Deve FALHAR
}
```
- **O que testa**: Se alguÃ©m pode completar tarefa de outra pessoa
- **Analogia**: Como testar se **vizinho pode sacar na sua conta**

**2. Teste de Double Spending:**
```solidity
function testCannotCompleteTaskTwice() public {
    // Criar tarefa
    // Completar uma vez (sucesso)
    // Tentar completar segunda vez (deve falhar)
}
```
- **O que testa**: Se Ã© possÃ­vel receber dinheiro duas vezes
- **Analogia**: Como testar se dÃ¡ para **sacar o prÃªmio duas vezes**

**3. Teste de Overflow/Underflow:**
```solidity
function testMassiveTaskCreation() public {
    // Criar 1000+ tarefas
    // Verificar se totalTasks nÃ£o "quebra"
}
```
- **O que testa**: Se o contador aguenta nÃºmeros gigantes
- **Analogia**: Como testar se **odÃ´metro nÃ£o volta ao zero** quando chega ao limite

#### â° **Testes de Tempo - "Teste da MÃ¡quina do Tempo"**

**Analogia**: Como **testar diferentes cenÃ¡rios temporais** numa corrida!

**1. Teste de Tarefa Atrasada:**
```solidity
function testLateTaskCompletion() public {
    // Criar tarefa com prazo de 1 dia
    // AvanÃ§ar tempo para 2 dias (vm.warp)
    // Completar tarefa
    // Verificar se stake foi perdido (nÃ£o devolvido)
}
```
- **O que testa**: Se stake Ã© realmente perdido quando atrasado
- **Analogia**: **Chegar atrasado na corrida** e perder a aposta

**2. Teste de VerificaÃ§Ã£o de Atraso:**
```solidity
function testIsTaskOverdueLogic() public {
    // Criar tarefa
    // Verificar que nÃ£o estÃ¡ atrasada
    // AvanÃ§ar tempo apÃ³s prazo
    // Verificar que estÃ¡ atrasada
    // Completar tarefa
    // Verificar que nÃ£o estÃ¡ mais "atrasada" (foi concluÃ­da)
}
```
- **O que testa**: Se a lÃ³gica de "atrasado" funciona corretamente
- **Analogia**: **CronÃ´metro da corrida** estÃ¡ funcionando direito

#### ğŸ’° **Testes Financeiros - "Teste do Cofre"**

**Analogia**: Como **testar todos os cenÃ¡rios de dinheiro** num cassino!

**1. Teste de Stake Insuficiente:**
```solidity
function testInsufficientStake() public {
    // Tentar criar tarefa com 0.0001 ether (menos que mÃ­nimo)
    // Deve FALHAR
}
```
- **O que testa**: Se valores baixos sÃ£o rejeitados
- **Analogia**: **Tentar apostar centavos** numa mesa que exige reais

**2. Teste de Stake Exato:**
```solidity
function testExactMinimumStake() public {
    // Criar tarefa com exatamente 0.001 ether
    // Deve FUNCIONAR
}
```
- **O que testa**: Se o valor mÃ­nimo exato Ã© aceito
- **Analogia**: **Apostar exatamente o mÃ­nimo** permitido

**3. Teste de Stakes Diferentes:**
```solidity
function testDifferentStakeAmounts() public {
    // Criar tarefas com 0.001, 0.01, 0.1, 1 ether
    // Completar todas no prazo
    // Verificar se cada um recebeu o valor correto de volta
}
```
- **O que testa**: Se valores diferentes sÃ£o manuseados corretamente
- **Analogia**: **Apostas de valores diferentes** na mesma corrida

#### ğŸ“Š **Testes de Estado - "Teste do InventÃ¡rio"**

**Analogia**: Como **conferir se o estoque** da loja estÃ¡ correto!

**1. Teste de Contador Global:**
```solidity
function testTotalTasksIncrement() public {
    uint256 initialCount = taskManager.totalTasks();
    
    // Criar 3 tarefas
    // Verificar se totalTasks aumentou em 3
    
    assertEq(taskManager.totalTasks(), initialCount + 3);
}
```
- **O que testa**: Se o contador global estÃ¡ certo
- **Analogia**: **Conferir se o caixa** registrou todas as vendas

**2. Teste de Lista de UsuÃ¡rio:**
```solidity
function testUserTasksList() public {
    // UsuÃ¡rio A cria 2 tarefas
    // UsuÃ¡rio B cria 3 tarefas
    // Verificar se cada um tem a quantidade correta na sua lista
    // Verificar se as listas nÃ£o se misturam
}
```
- **O que testa**: Se cada usuÃ¡rio vÃª apenas suas tarefas
- **Analogia**: **Cada cliente sÃ³ vÃª seus prÃ³prios pedidos**

#### ğŸ² **Testes de Casos Extremos - "Teste do ImpossÃ­vel"**

**Analogia**: Como **testar situaÃ§Ãµes malucas** que provavelmente nunca vÃ£o acontecer!

**1. Teste de Deadline no Futuro Distante:**
```solidity
function testFarFutureDeadline() public {
    // Criar tarefa com deadline em 100 anos
    // Deve funcionar normalmente
}
```
- **O que testa**: Se o contrato aguenta datas muito futuras
- **Analogia**: **Apostar numa corrida de 2124**

**2. Teste de String Vazia:**
```solidity
function testEmptyTaskTitle() public {
    // Tentar criar tarefa com tÃ­tulo vazio ""
    // Pode aceitar ou rejeitar (depende da regra)
}
```
- **O que testa**: Como o contrato lida com dados vazios
- **Analogia**: **Apostar sem dar nome ao cavalo**

**3. Teste de String Gigante:**
```solidity
function testMassiveTaskDescription() public {
    // Criar tarefa com descriÃ§Ã£o de 10.000 caracteres
    // Verificar custo de gas e funcionamento
}
```
- **O que testa**: Se textos enormes causam problemas
- **Analogia**: **Escrever uma redaÃ§Ã£o de 50 pÃ¡ginas** como descriÃ§Ã£o

#### ğŸ† **Testes de Performance - "Teste de Velocidade"**

**Analogia**: Como **testar se o carro aguenta** FÃ³rmula 1!

**1. Teste de Gas Cost:**
```solidity
function testGasCosts() public {
    // Medir gas de createTask
    // Medir gas de completeTask
    // Verificar se estÃ¡ dentro de limites aceitÃ¡veis
}
```
- **O que testa**: Quanto "combustÃ­vel" cada funÃ§Ã£o gasta
- **Analogia**: **Testar consumo** de cada carro

**2. Teste de Stress:**
```solidity
function testStressTest() public {
    // Criar 100 tarefas em sequÃªncia
    // Completar todas
    // Verificar se tudo ainda funciona
}
```
- **O que testa**: Se o contrato aguenta uso intenso
- **Analogia**: **Dirigir 1000km** sem parar para ver se quebra

#### ğŸ’¡ **Como Implementar Estes Testes**

**1. ğŸ“ Organizar por Categoria:**
```
test/
â”œâ”€â”€ TestSecurity.t.sol     # Testes de seguranÃ§a
â”œâ”€â”€ TestTiming.t.sol       # Testes de tempo
â”œâ”€â”€ TestFinancial.t.sol    # Testes financeiros
â”œâ”€â”€ TestState.t.sol        # Testes de estado
â””â”€â”€ TestEdgeCases.t.sol    # Casos extremos
```

**2. ğŸ¯ Usar Foundry Features:**
```solidity
// Testar com fuzzing (dados aleatÃ³rios)
function testFuzzCreateTask(string memory title, uint256 deadline) public {
    vm.assume(deadline > block.timestamp);
    // Foundry vai testar com centenas de valores aleatÃ³rios
}

// Testar invariants (regras que nunca devem quebrar)
function invariant_totalTasksNeverDecrease() public {
    // Esta regra deve ser sempre verdadeira
    assert(taskManager.totalTasks() >= previousTotalTasks);
}
```

**3. ğŸš¨ Usar vm Commands:**
```solidity
vm.warp(timestamp);        // Viajar no tempo
vm.deal(user, amount);     // Dar dinheiro fake
vm.expectRevert("error");  // Esperar que falhe
vm.startPrank(user);       // Simular outro usuÃ¡rio
```

**ğŸ¯ Meta**: Com estes testes, seu contrato fica **blindado** como Fort Knox! ğŸ°

### ğŸš€ Script de Deploy (DeployTaskManager.s.sol)

O script de deploy Ã© como um **"manual de instalaÃ§Ã£o"** do nosso contrato na blockchain:

#### ğŸ—ï¸ **Estrutura do Script de Deploy**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Script.sol";
import "../src/TaskManager.sol";

contract DeployTaskManager is Script {
    function setUp() public {}

    function run() public {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        vm.startBroadcast(deployerPrivateKey);

        TaskManager taskManager = new TaskManager();
        
        console.log("TaskManager deployed at:", address(taskManager));
        console.log("Deployer address:", vm.addr(deployerPrivateKey));
        console.log("Minimum stake required:", taskManager.MINIMUM_STAKE());

        vm.stopBroadcast();
    }
}
```

**Analogia**: Como **abrir uma nova loja fÃ­sica**:

#### ğŸ“‹ **PreparaÃ§Ã£o (Imports)**
```solidity
import "forge-std/Script.sol";
import "../src/TaskManager.sol";
```
- **Analogia**: Como **reunir todas as ferramentas** necessÃ¡rias antes de construir
- `Script.sol` = "Kit de ferramentas para construÃ§Ã£o"
- `TaskManager.sol` = "Planta da loja que vamos construir"

#### ğŸ”‘ **AutenticaÃ§Ã£o (Private Key)**
```solidity
uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
```
- **Analogia**: Como **pegar a chave do proprietÃ¡rio** para autorizar a construÃ§Ã£o
- `PRIVATE_KEY` = Sua "chave secreta" (como a senha do banco)
- `vm.envUint()` = Pega a chave de um arquivo seguro (variÃ¡vel de ambiente)

#### ğŸ“¢ **InÃ­cio da ConstruÃ§Ã£o (startBroadcast)**
```solidity
vm.startBroadcast(deployerPrivateKey);
```
- **Analogia**: Como **avisar a prefeitura**: "Vou comeÃ§ar a construir agora!"
- A partir daqui, tudo que vocÃª fizer **custa dinheiro real** (gas)
- Ã‰ como ligar um **"taxÃ­metro"** da blockchain

#### ğŸ­ **ConstruÃ§Ã£o da Loja (new TaskManager)**
```solidity
TaskManager taskManager = new TaskManager();
```
- **Analogia**: Como **construir fisicamente a loja**
- `new TaskManager()` = "Erguer um prÃ©dio novo do zero"
- A partir daqui, sua loja existe **para sempre** na blockchain

#### ğŸ“ **RelatÃ³rio de ConclusÃ£o (console.log)**
```solidity
console.log("TaskManager deployed at:", address(taskManager));
console.log("Deployer address:", vm.addr(deployerPrivateKey));
console.log("Minimum stake required:", taskManager.MINIMUM_STAKE());
```
- **Analogia**: Como **entregar a certidÃ£o de conclusÃ£o da obra**:
  - "Loja construÃ­da no endereÃ§o: Rua A, nÂº 123"
  - "ProprietÃ¡rio: JoÃ£o Silva (CPF: 123.456.789-00)"
  - "Taxa de entrada: R$ 5,00"

#### ğŸ›‘ **Fim da ConstruÃ§Ã£o (stopBroadcast)**
```solidity
vm.stopBroadcast();
```
- **Analogia**: Como **desligar o taxÃ­metro** e avisar: "Obra concluÃ­da!"
- A partir daqui, nÃ£o gastamos mais gas

#### ğŸ¯ **Por que usar Script de Deploy?**

- **ğŸ”„ RepetÃ­vel**: Pode rodar vÃ¡rias vezes (testnet, mainnet, etc.)
- **ğŸ“ Documentado**: Fica registrado exatamente como o contrato foi criado
- **ğŸ›¡ï¸ Seguro**: Usa variÃ¡veis de ambiente para proteger chaves privadas
- **ğŸ“Š Informativo**: Mostra endereÃ§os e informaÃ§Ãµes importantes
- **âš¡ Automatizado**: Um comando sÃ³ faz tudo

**Comando para usar**:
```bash
forge script script/TaskManager.s.sol:TaskManagerScript --rpc-url <REDE> --private-key <SUA_CHAVE> --broadcast
```

**ğŸ¯ Importante**: Note que o script se chama `TaskManager.s.sol` e a classe Ã© `TaskManagerScript`. Este Ã© o comando correto baseado na estrutura real do projeto.

**Analogia**: Como usar um **"app de construÃ§Ã£o"** que faz tudo automaticamente!

### ğŸŒ Deploy Manual na Rede Sepolia - "Construindo na Cidade Real"

Agora vamos aprender a **"construir nossa loja"** numa cidade real (rede de teste), nÃ£o apenas no terreno de treino (rede local).

#### ğŸ¢ **Entendendo os Provedores - "Companhias TelefÃ´nicas da Blockchain"**

**Analogia**: Como **empresas de telecomunicaÃ§Ãµes** que conectam vocÃª Ã  internet.

**ğŸ¤” Por que precisamos de provedores?**

Imagine que vocÃª quer **ligar para alguÃ©m** numa cidade distante:
- VocÃª nÃ£o pode ir fisicamente atÃ© lÃ¡
- Precisa de uma **"empresa telefÃ´nica"** para fazer a conexÃ£o
- A empresa tem **torres e cabos** que conectam as cidades

**Na blockchain Ã© igual**:
- Sua aplicaÃ§Ã£o local nÃ£o consegue "falar" diretamente com Ethereum
- Precisa de um **"provedor RPC"** para fazer a conexÃ£o
- O provedor tem **servidores e nÃ³s** que conectam vocÃª Ã  rede

#### ğŸ“¡ **Infura - A "Operadora Premium"**

**Infura** Ã© como a **"Vivo/Claro da blockchain"** - uma empresa que oferece conexÃ£o profissional.

**ğŸ”— Outros provedores similares:**
- **Alchemy** (concorrente principal)
- **QuickNode** 
- **Moralis**
- **GetBlock**

**Analogia**: Como **operadoras de celular** - todas fazem a mesma coisa (conectar), mas com preÃ§os e qualidades diferentes.

#### ğŸ—ï¸ **Obtendo API Key da Infura - "Seu CartÃ£o de Acesso"**

**Passo a passo para pegar sua "linha telefÃ´nica":**

**1. ğŸ“ Criar Conta na Infura:**
- Acesse: https://infura.io/
- Clique em **"Sign Up"** (criar conta)
- Use um email vÃ¡lido (vocÃª receberÃ¡ confirmaÃ§Ã£o)

**Analogia**: Como **"contratar um plano de celular"** numa operadora.

**2. âœ… Confirmar Email:**
- VÃ¡ ao seu email
- Clique no link de confirmaÃ§Ã£o
- FaÃ§a login na Infura

**3. ğŸ¯ Criar um Projeto:**
- No painel, clique **"Create New Key"**
- **Name**: "TaskManager Project" (ou qualquer nome)
- **Network**: **"Web3 API"** (nÃ£o Ethereum 2.0)
- Clique **"Create"**

**Analogia**: Como **"registrar um novo nÃºmero"** na operadora.

**4. ğŸ“‹ Copiar as URLs:**

ApÃ³s criar, vocÃª verÃ¡ algo assim:
```
PROJECT ID: 9aa3d95b3bc440fa88ea12eaa4456161

ENDPOINTS:
Mainnet: https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161
Sepolia: https://sepolia.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161
```

**ğŸ¯ Importante**: Copie a URL da **Sepolia** - Ã© ela que vamos usar!

**Analogia**: Como **"pegar seu nÃºmero de telefone"** depois de contratar o plano.

#### ğŸ” **Etherscan - O "Google da Blockchain"**

**Etherscan** Ã© como o **"Google"** da blockchain Ethereum - vocÃª pode pesquisar qualquer coisa.

**ğŸŒ Links importantes:**
- **Mainnet**: https://etherscan.io/ (rede principal)
- **Sepolia**: https://sepolia.etherscan.io/ (rede de teste)

**O que vocÃª pode fazer no Etherscan:**
- ğŸ” **Pesquisar transaÃ§Ãµes** (como rastrear encomenda dos Correios)
- ğŸ‘€ **Ver contratos** deployados (como ver lojas numa rua)
- ğŸ’° **Verificar saldos** (como extrato bancÃ¡rio)
- â›½ **Monitorar gas** (como preÃ§o da gasolina)

#### ğŸ”‘ **Configurando API Key do Etherscan**

**Por que precisamos?**
- Para **verificar contratos** automaticamente
- Como ter **"acesso VIP"** ao Google da blockchain

**Passo a passo:**

**1. ğŸ“ Criar Conta no Etherscan:**
- Acesse: https://etherscan.io/
- Clique **"Sign In"** â†’ **"Click to sign up"**
- Registre-se com email

**2. ğŸ—ï¸ Gerar API Key:**
- FaÃ§a login
- VÃ¡ em **"API Keys"** (no menu do usuÃ¡rio)
- Clique **"Add"** 
- **App Name**: "TaskManager"
- Copie a **API Key** gerada

**Exemplo da API Key:**
```
YourApiKeyToken: ABC123DEF456GHI789JKL012MNO345PQR678
```

**Analogia**: Como **"pegar cartÃ£o VIP"** para ter acesso especial ao shopping.

#### ğŸ¦Š **MetaMask - Sua "Carteira Digital"**

**MetaMask** Ã© como sua **"carteira fÃ­sica"**, mas para criptomoedas.

#### ğŸ“¥ **Instalando MetaMask:**

**1. ğŸ’» Instalar ExtensÃ£o:**
- Acesse: https://metamask.io/
- Clique **"Download"**
- Adicione ao Chrome/Firefox/Safari

**2. ğŸ†• Criar Carteira Nova:**
- Abra a extensÃ£o
- **"Create a new wallet"**
- Criar senha forte
- **âš ï¸ ANOTAR AS 12 PALAVRAS** (seed phrase) num papel

**Analogia**: As 12 palavras sÃ£o como **"chave mestre do cofre"** - se perder, perde tudo!

#### ğŸŒ **Configurando Rede Sepolia:**

**Sepolia jÃ¡ vem configurada** no MetaMask moderno, mas se nÃ£o estiver:

```
Network Name: Sepolia test network
New RPC URL: https://sepolia.infura.io/v3/SEU_PROJECT_ID
Chain ID: 11155111
Currency Symbol: ETH
Block Explorer: https://sepolia.etherscan.io
```

#### ğŸ’° **Conseguindo Ethereum de Teste (Sepolia ETH):**

**Analogia**: Como **"dinheiro de Monopoly"** - vale apenas no jogo (rede de teste).

**Faucets (torneiras) gratuitas:**
1. **Sepolia Faucet**: https://sepoliafaucet.com/
2. **Alchemy Faucet**: https://sepoliafaucet.com/
3. **Infura Faucet**: https://www.infura.io/faucet

**Como usar:**
- Copie seu endereÃ§o MetaMask
- Cole no faucet
- Aguarde 1-2 minutos
- Receba ~0.5 ETH de teste

#### ğŸ” **Obtendo Chave Privada - "Senha do Cofre"**

**âš ï¸ ATENÃ‡ÃƒO EXTREMA**: Chave privada Ã© como **"senha do banco"** - NUNCA compartilhe!

**Passo a passo no MetaMask:**

**1. ğŸ¦Š Abrir MetaMask:**
- Clique na extensÃ£o
- FaÃ§a login

**2. âš™ï¸ Acessar ConfiguraÃ§Ãµes:**
- Clique nos **3 pontinhos** (menu)
- **"Account Details"**

**3. ğŸ”‘ Exportar Chave:**
- **"Show private key"**
- Digite sua **senha do MetaMask**
- **Copie a chave privada**

**Exemplo de chave privada:**
```
0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
```

**ğŸš¨ SEGURANÃ‡A MÃXIMA**:
- âŒ **NUNCA** cole em sites duvidosos
- âŒ **NUNCA** compartilhe com ninguÃ©m
- âŒ **NUNCA** commit no Git
- âœ… Use apenas para deploy local/teste
- âœ… Crie uma carteira separada sÃ³ para desenvolvimento

#### ğŸš€ **Deploy Manual na Sepolia - Passo a Passo**

Agora vamos **"construir nossa loja"** na cidade real!

#### ğŸ› ï¸ **PreparaÃ§Ã£o do Ambiente:**

**1. ğŸ“ Criar arquivo .env:**

Na pasta do projeto, crie `.env`:
```bash
# .env (NUNCA commit este arquivo!)
PRIVATE_KEY=0xSUA_CHAVE_PRIVADA_AQUI
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/SEU_PROJECT_ID
ETHERSCAN_API_KEY=SUA_API_KEY_DO_ETHERSCAN
```

**2. ğŸ”’ Proteger .env:**

Adicione no `.gitignore`:
```
.env
```

**Analogia**: Como **"trancar o cofre"** onde vocÃª guarda senhas.

#### ğŸ—ï¸ **Executando o Deploy:**

**ğŸ”§ PrÃ©-requisito IMPORTANTE: Carregar VariÃ¡veis de Ambiente**

Antes de executar o comando de deploy, vocÃª **DEVE** carregar as variÃ¡veis do arquivo `.env`:

```bash
# ğŸ”‘ PRIMEIRO: Carregar as variÃ¡veis de ambiente
source .env

# âœ… Verificar se as variÃ¡veis foram carregadas
echo "RPC: $SEPOLIA_RPC_URL"
echo "Private Key configurada: $([ -n "$PRIVATE_KEY" ] && echo "âœ… SIM" || echo "âŒ NÃƒO")"
echo "Etherscan API: $([ -n "$ETHERSCAN_API_KEY" ] && echo "âœ… SIM" || echo "âŒ NÃƒO")"
```

**ğŸ’¡ Por que isso Ã© necessÃ¡rio?**
- O comando usa variÃ¡veis como `$SEPOLIA_RPC_URL`, `$PRIVATE_KEY`, `$ETHERSCAN_API_KEY`
- Sem o `source .env`, essas variÃ¡veis ficam vazias e o comando falha
- Ã‰ como **"logar no sistema"** antes de usar seus dados

**ğŸ“‹ Exemplo Visual:**

```bash
# âŒ SEM carregar .env - FALHA!
forge script script/TaskManager.s.sol:TaskManagerScript --rpc-url $SEPOLIA_RPC_URL
# Resultado: --rpc-url ""  (vazio!)

# âœ… COM source .env - FUNCIONA!
source .env
forge script script/TaskManager.s.sol:TaskManagerScript --rpc-url $SEPOLIA_RPC_URL  
# Resultado: --rpc-url "https://sepolia.infura.io/v3/1b375955f267496abf270f2423801349"
```

**ğŸ” Como as variÃ¡veis sÃ£o substituÃ­das:**
- `$SEPOLIA_RPC_URL` â†’ `https://sepolia.infura.io/v3/SEU_PROJECT_ID`
- `$PRIVATE_KEY` â†’ `0x1234567890abcdef...` (sua chave privada)
- `$ETHERSCAN_API_KEY` â†’ `ABC123DEF456...` (sua API key)

**1. ğŸ’» Comando de Deploy:**

```bash
# OpÃ§Ã£o A: Carregar variÃ¡veis E executar deploy em um comando
source .env && forge script script/TaskManager.s.sol:TaskManagerScript \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  --verify \
  --etherscan-api-key $ETHERSCAN_API_KEY \
  -vvvv

# OpÃ§Ã£o B: Carregar variÃ¡veis primeiro, depois executar
source .env
forge script script/TaskManager.s.sol:TaskManagerScript \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  --verify \
  --etherscan-api-key $ETHERSCAN_API_KEY \
  -vvvv
```

**âœ… Este Ã© o comando testado e funcionando!** Note que usamos `TaskManager.s.sol:TaskManagerScript` (nÃ£o `DeployTaskManager.s.sol`).

**Quebrado em partes:**
- `forge script` = Executar script de deploy
- `--rpc-url` = Conectar via Infura na Sepolia
- `--private-key` = Usar sua carteira para pagar gas
- `--broadcast` = Realmente enviar para blockchain
- `--verify` = Publicar cÃ³digo no Etherscan
- `-vvvv` = Mostrar TUDO que estÃ¡ acontecendo

**2. ğŸ’¸ O que acontece:**

```
[â ¢] Compiling...
[âœ…] Compilation completed successfully.

== Logs ==
TaskManager deployed at: 0x742d35Cc6636C0532925a3b8D8C9a76C4577F6B5
Deployer address: 0xYourAddress
Minimum stake required: 1000000000000000

## Setting up 1 EVM.
##
## Environment
Chain: sepolia

## Sender
Address: 0xYourAddress
Balance: 0.123456789 ETH

âœ… Transaction sent! Hash: 0xabc123...
â³ Waiting for confirmation...
âœ… Transaction confirmed!
â›½ Gas used: 1,234,567
ğŸ’° Gas cost: 0.001234 ETH
```

**3. ğŸ” VerificaÃ§Ã£o no Etherscan:**

- Acesse: https://sepolia.etherscan.io/
- Cole o endereÃ§o do contrato
- Veja seu contrato deployado!

#### ğŸ¯ **Testando o Contrato Deployado:**

**1. ğŸ“ Consultar dados (grÃ¡tis):**

```bash
# Ver total de tarefas
cast call 0xSEU_CONTRATO_ADDRESS "totalTasks()" --rpc-url $SEPOLIA_RPC_URL

# Ver stake mÃ­nimo
cast call 0xSEU_CONTRATO_ADDRESS "MINIMUM_STAKE()" --rpc-url $SEPOLIA_RPC_URL
```

**2. ğŸ“ Criar tarefa (custa gas):**

```bash
cast send 0xSEU_CONTRATO_ADDRESS \
  "createTask(string,string,uint256)" \
  "Estudar Solidity" \
  "Completar tutorial completo" \
  1703980800 \
  --value 0.001ether \
  --private-key $PRIVATE_KEY \
  --rpc-url $SEPOLIA_RPC_URL
```

#### ğŸ‰ **ParabÃ©ns! Seu Contrato estÃ¡ Vivo!**

**ğŸŒ Links Ãºteis apÃ³s deploy:**
- **Contrato**: https://sepolia.etherscan.io/address/SEU_ENDEREÃ‡O
- **CÃ³digo Verificado**: Aba "Contract" â†’ "Read Contract"
- **TransaÃ§Ãµes**: Aba "Txns" mostra todas as interaÃ§Ãµes

**Analogia**: Como **"inaugurar sua loja"** numa rua movimentada - agora todo mundo pode visitÃ¡-la!

#### ğŸš¨ **Troubleshooting - Problemas Comuns**

**Erro: "No such file or directory: script/DeployTaskManager.s.sol"**
- **âŒ Problema**: Script nÃ£o existe com esse nome
- **âœ… SoluÃ§Ã£o**: Use `script/TaskManager.s.sol:TaskManagerScript`

**Erro: "a value is required for '--fork-url' but none was supplied"**
- **âŒ Problema**: Comando quebrado em mÃºltiplas linhas
- **âœ… SoluÃ§Ã£o**: Execute o comando completo em uma linha ou use `\` para quebra

**ğŸš¨ Erro: VariÃ¡veis vazias ou "Invalid RPC URL"**
- **âŒ Problema**: NÃ£o carregou o arquivo `.env` antes do comando
- **âœ… SoluÃ§Ã£o**: SEMPRE execute `source .env` primeiro
- **ğŸ” Como verificar**: `echo $SEPOLIA_RPC_URL` deve mostrar a URL completa

**ğŸš¨ Erro: "insufficient funds for gas * price + value"**
- **âŒ Problema**: Carteira sem ETH suficiente para pagar gas
- **âœ… SoluÃ§Ã£o**: Pegue ETH de teste no faucet Sepolia

**ğŸ“‹ Checklist antes do deploy:**
```bash
# 1. Verificar se estÃ¡ na pasta smartcontract
pwd  # Deve mostrar: .../fb02/smartcontract

# 2. Verificar se arquivo .env existe
ls -la .env

# 3. Carregar variÃ¡veis
source .env

# 4. Verificar se variÃ¡veis estÃ£o carregadas
echo "âœ… RPC: $SEPOLIA_RPC_URL"
echo "âœ… Private Key: $([ -n "$PRIVATE_KEY" ] && echo "configurada" || echo "âŒ VAZIA")"
echo "âœ… Etherscan API: $([ -n "$ETHERSCAN_API_KEY" ] && echo "configurada" || echo "âŒ VAZIA")"
```

**Comando COMPLETO que FUNCIONA:**
```bash
source .env && forge script script/TaskManager.s.sol:TaskManagerScript --rpc-url $SEPOLIA_RPC_URL --private-key $PRIVATE_KEY --broadcast --verify --etherscan-api-key $ETHERSCAN_API_KEY -vvvv
```

**ğŸ¯ PrÃ³ximos passos:**
- Criar interface front-end
- Conectar MetaMask ao seu site
- Permitir que usuÃ¡rios interajam visualmente

---

## ğŸ Bonus - Prompt do Contrato

Para referÃªncia e estudo, aqui estÃ¡ o **prompt original** usado para criar o contrato TaskManager:

```
Crie um contrato inteligente em Solidity chamado "TaskManager" que permita aos usuÃ¡rios criar, gerenciar e concluir tarefas associadas a prazos e valores apostados (stakes). O contrato deve atender aos seguintes requisitos:

Estrutura de Dados

Armazenar informaÃ§Ãµes de cada tarefa, incluindo:

Um identificador Ãºnico para cada tarefa.

Um tÃ­tulo descritivo.

Uma descriÃ§Ã£o detalhada.

A data de criaÃ§Ã£o da tarefa.

Um prazo para conclusÃ£o (data futura).

O status atual da tarefa (pendente ou concluÃ­da).

O endereÃ§o do criador da tarefa.

O valor apostado (stake) associado Ã  tarefa.

Um indicador que mostre se o valor apostado jÃ¡ foi processado.

Funcionalidades Principais

Permitir que usuÃ¡rios criem novas tarefas fornecendo:

Um tÃ­tulo, uma descriÃ§Ã£o e um prazo (que deve ser uma data futura).

Um valor apostado mÃ­nimo de 0.001 ether, enviado junto com a criaÃ§Ã£o.

Restringir a conclusÃ£o de tarefas apenas ao criador da tarefa.

Processar o valor apostado da seguinte forma:

Devolver o valor ao criador se a tarefa for concluÃ­da antes do prazo.

Considerar o valor perdido se o prazo expirar sem conclusÃ£o.

Oferecer uma maneira de os usuÃ¡rios consultarem todas as tarefas que eles prÃ³prios criaram.

Possibilitar a verificaÃ§Ã£o se uma tarefa estÃ¡ atrasada com base no prazo e no tempo atual.

Disponibilizar informaÃ§Ãµes gerais, como:

O nÃºmero total de tarefas criadas no contrato.

O saldo total de ether atualmente armazenado no contrato.

NotificaÃ§Ãµes

Gerar notificaÃ§Ãµes pÃºblicas (eventos) nos seguintes casos:

Quando uma nova tarefa Ã© criada.

Quando uma tarefa Ã© concluÃ­da.

Quando o valor apostado Ã© perdido devido ao atraso.

SeguranÃ§a

Garantir que as transferÃªncias de ether sejam feitas de forma segura, verificando se foram concluÃ­das com sucesso.

EspecificaÃ§Ãµes TÃ©cnicas

Utilizar a versÃ£o 0.8.13 do Solidity.

Incluir a licenÃ§a MIT no inÃ­cio do cÃ³digo.

Usar estruturas de mapeamento para organizar as tarefas e associÃ¡-las aos respectivos criadores.

Fornecer uma forma de consultar os detalhes completos de uma tarefa especÃ­fica.

Incluir uma maneira de determinar se uma tarefa estÃ¡ atrasada em relaÃ§Ã£o ao prazo.

Permitir consulta ao nÃºmero total de tarefas criadas e ao saldo atual do contrato.
```

**ğŸ’¡ Dica**: Este prompt pode servir como **base** para criar outros contratos similares ou para **estudar** como traduzir requisitos em cÃ³digo Solidity!

---

### ğŸ“Œ **AtualizaÃ§Ã£o: Deploy Corrigido**

**âœ… Deploy Funcional**: O comando de deploy foi corrigido e testado com sucesso!
- **Contrato**: TaskManager deployado em: `0xb17d39826a1b83f7685de1ebc924b3185b677383`
- **Rede**: Sepolia Testnet
- **Hash**: `0x317b05ffccb85fad4a670cdee712c2f908322101767e78b4ad809e4b0fe8d10e`
- **Verificado**: âœ… CÃ³digo verificado no Etherscan

**ğŸ”— Ver contrato**: [https://sepolia.etherscan.io/address/0xb17d39826a1b83f7685de1ebc924b3185b677383](https://sepolia.etherscan.io/address/0xb17d39826a1b83f7685de1ebc924b3185b677383)

#### ğŸ”‘ **LEMBRE-SE: Sempre Carregar VariÃ¡veis de Ambiente!**

**âš ï¸ ERRO MAIS COMUM**: Esquecer de executar `source .env` antes do deploy.

**âœ… PROCESSO CORRETO:**
1. `cd smartcontract` (entrar na pasta do smart contract)
2. `source .env` (carregar variÃ¡veis)
3. Executar comando de deploy
4. âœ¨ Deploy funciona perfeitamente!

**ğŸ’¡ Dica**: Sempre que abrir um novo terminal, execute `source .env` novamente, pois as variÃ¡veis sÃ³ ficam carregadas na sessÃ£o atual do terminal.

---

## ğŸ¯ Aula 3 - IntegraÃ§Ã£o Frontend com Smart Contract

### ğŸŒ‰ **Construindo a Ponte entre Seu Site e a Blockchain**

**Analogia**: Imagine que vocÃª tem um **restaurante fÃ­sico** (smart contract) e quer criar um **aplicativo de delivery** (frontend). VocÃª precisa de uma **"ponte"** para conectar os dois mundos!

**ğŸ”— O que vamos fazer nesta aula:**
- Conectar nosso site Next.js com o smart contract deployado
- Usar **wagmi** e **viem** para fazer essa conexÃ£o
- Criar componentes e hooks organizados para Web3
- Implementar interface funcional e intuitiva

#### ğŸ§© **As PeÃ§as do Quebra-CabeÃ§a**

```
ğŸ  Seu Site (Next.js)     ğŸŒ‰ Ponte (wagmi + viem)     ğŸª Smart Contract (Blockchain)
     â”‚                           â”‚                           â”‚
     â”‚ "Quero criar tarefa"       â”‚                           â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Traduz para blockchain   â”‚
     â”‚                           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Executa createTask()
     â”‚                           â”‚                           â”‚
     â”‚ "Mostrar minhas tarefas"   â”‚                           â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Consulta dados           â”‚
     â”‚                           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Retorna lista [1,2,3]
     â”‚                           â”‚                           â”‚
     â”‚ Exibe na interface âœ¨      â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                           â”‚
```

### ğŸ“‹ **SequÃªncia de IntegraÃ§Ã£o (Siga esta ordem!)**

**1. ğŸ“¦ Instalar dependÃªncias necessÃ¡rias**
**2. ğŸ“ Copiar ABI e endereÃ§o do contrato**  
**3. ğŸ”Œ Criar componente de conexÃ£o Web3**
**4. ğŸ­ Configurar providers da aplicaÃ§Ã£o**
**5. ğŸ£ Criar hooks customizados**
**6. ğŸ”§ Atualizar layout.tsx**
**7. ğŸ’» Implementar interface na page.tsx**

---

### ğŸ› ï¸ **Passo 1: InstalaÃ§Ã£o das DependÃªncias**

#### ğŸ“¦ **Bibliotecas Web3 Essenciais**

```bash
# ğŸ“¦ Bibliotecas principais para Web3
pnpm add wagmi viem @tanstack/react-query @wagmi/connectors

# ğŸ¨ Componentes UI (se ainda nÃ£o instalados)
npx shadcn@latest add dialog button input textarea label card badge tooltip alert
```

**ğŸ“– Por que cada biblioteca:**

- **`wagmi`**: O "assistente pessoal" que busca dados da blockchain automaticamente
- **`viem`**: O "tradutor" que converte JavaScript â†” Blockchain  
- **`@tanstack/react-query`**: A "memÃ³ria inteligente" que guarda dados em cache
- **`@wagmi/connectors`**: Os "adaptadores" para diferentes carteiras (MetaMask, etc.)

**ğŸ¯ O que fazem juntos:**
```
ğŸ“± Seu App (React)
    â†“ usa
ğŸ£ Wagmi (busca dados automaticamente)
    â†“ usa
âš¡ Viem (traduz para blockchain)
    â†“ usa
ğŸ¦Š MetaMask (assina transaÃ§Ãµes)
    â†“ envia para
ğŸŒ Blockchain (executa contratos)
```

---

### ğŸ“ **Passo 2: Copiando ABI e EndereÃ§o do Contrato**

#### **ğŸ“‹ O que Ã© ABI e por que precisamos?**

**Analogia**: ABI Ã© como um **"cardÃ¡pio de restaurante"** que lista todos os pratos (funÃ§Ãµes) disponÃ­veis e seus ingredientes (parÃ¢metros).

**ğŸ¤” Sem ABI**: Ã‰ como tentar pedir comida sem ver o cardÃ¡pio - vocÃª nÃ£o sabe o que estÃ¡ disponÃ­vel

**âœ… Com ABI**: VocÃª sabe exatamente quais funÃ§Ãµes pode chamar e como chamar

**ğŸ“– ABI (Application Binary Interface):**
- **O que Ã©**: "Manual de instruÃ§Ãµes" em formato JSON
- **ContÃ©m**: Lista de todas as funÃ§Ãµes, eventos e variÃ¡veis do contrato  
- **Como funciona**: Seu frontend usa o ABI para saber como "falar" com o contrato
- **Analogia**: Como um tradutor que sabe exatamente como conversar com o restaurante

#### **ğŸ“ 2.1 Encontrar e Copiar o ABI**

**Onde estÃ¡ o ABI**: ApÃ³s compilar com Foundry, fica em:
```
smartcontract/out/TaskManager.sol/TaskManager.json
```

**ğŸ” Como extrair:**

1. **Abra o arquivo**:
```bash
cd smartcontract
cat out/TaskManager.sol/TaskManager.json
```

2. **Procure pela seÃ§Ã£o "abi"** (Ã© um array gigante):
```json
{
  "abi": [
    {
      "inputs": [...],
      "name": "createTask", 
      "outputs": [...],
      "stateMutability": "payable",
      "type": "function"
    },
    // ... muitas outras funÃ§Ãµes
  ]
}
```

3. **Copie APENAS o array da seÃ§Ã£o "abi"** (tudo entre `"abi": [` e `]`)

#### **ğŸ“ 2.2 Obter EndereÃ§o do Contrato Deployado**

**De onde vem**: Quando vocÃª fez o deploy, apareceu algo como:
```
TaskManager deployed at: 0xb17d39826a1b83f7685de1ebc924b3185b677383
```

**ğŸ“‹ Como confirmar se estÃ¡ correto:**
- Acesse: https://sepolia.etherscan.io/address/SEU_ENDERECO
- Se mostrar seu contrato = estÃ¡ correto âœ…

#### **ğŸ’¾ 2.3 Criar arquivo de configuraÃ§Ã£o Web3**

**ğŸ“ Criar `lib/web3.ts`**:

```typescript
// lib/web3.ts - Central de ConfiguraÃ§Ãµes Web3

import { createConfig, http } from 'wagmi'
import { sepolia } from 'wagmi/chains'
import { metaMask } from 'wagmi/connectors'

// ğŸ”‘ ConfiguraÃ§Ã£o do provedor Infura
const infuraProjectId = process.env.NEXT_PUBLIC_INFURA_PROJECT_ID

// âš™ï¸ ConfiguraÃ§Ã£o principal do wagmi
export const config = createConfig({
  chains: [sepolia],
  connectors: [metaMask()],
  transports: {
    [sepolia.id]: http(`https://sepolia.infura.io/v3/${infuraProjectId}`)
  },
})

// ğŸ“ COLE AQUI: EndereÃ§o do seu contrato deployado
export const CONTRACT_ADDRESS = '0xSEU_ENDERECO_DEPLOYADO_AQUI'

// ğŸ“‹ COLE AQUI: ABI copiado do arquivo TaskManager.json
export const CONTRACT_ABI = [
  // Cole aqui todo o array ABI que vocÃª copiou
  {
    "inputs": [
      { "internalType": "string", "name": "_title", "type": "string" },
      { "internalType": "string", "name": "_description", "type": "string" },
      { "internalType": "uint256", "name": "_deadline", "type": "uint256" }
    ],
    "name": "createTask",
    "outputs": [],
    "stateMutability": "payable", 
    "type": "function"
  },
  // ... resto das funÃ§Ãµes do ABI
] as const
```

#### **ğŸ“– AnÃ¡lise Detalhada do CÃ³digo `lib/web3.ts`**

Vamos dissecar cada linha do nosso arquivo de configuraÃ§Ã£o para entender como funciona essa **"central de comando"** do nosso DApp:

#### **ğŸ“¦ 2.3.1 Imports - "Ferramentas da Oficina"**

```typescript
// lib/web3.ts - Nossa "Central de ConexÃµes"

// ğŸ“¦ Importa as ferramentas necessÃ¡rias
import { createConfig, http } from 'wagmi'
import { sepolia } from 'wagmi/chains'
import { metaMask } from 'wagmi/connectors'
```

**Analogia**: Como **organizar as ferramentas** antes de montar um mÃ³vel:

**`createConfig`**: A **"furadeira principal"**
- **O que faz**: FunÃ§Ã£o que monta toda a configuraÃ§Ã£o Web3
- **Por que importante**: Centraliza todas as configuraÃ§Ãµes em um lugar
- **Analogia**: Como um **"manual de montagem"** que junta todas as instruÃ§Ãµes

**`http`**: O **"cabo de forÃ§a"**
- **O que faz**: Protocolo de comunicaÃ§Ã£o com provedores RPC
- **Por que importante**: Define como seu app "fala" com a blockchain
- **Analogia**: Como o **"fio elÃ©trico"** que leva energia para a furadeira

**`sepolia`**: A **"planta do terreno"**
- **O que faz**: ConfiguraÃ§Ã£o prÃ©-definida da rede Sepolia
- **ContÃ©m**: Chain ID (11155111), nome, URLs oficiais, configuraÃ§Ãµes
- **Analogia**: Como **"certidÃ£o do terreno"** com todas as informaÃ§Ãµes legais

**`metaMask`**: O **"adaptador universal"**
- **O que faz**: Conector especÃ­fico para carteira MetaMask
- **Por que importante**: Permite comunicaÃ§Ã£o com a extensÃ£o do navegador
- **Analogia**: Como **"tomada adaptadora"** que conecta diferentes aparelhos

#### **ğŸ”‘ 2.3.2 VariÃ¡veis de Ambiente - "Cofre de Senhas"**

```typescript
// ğŸ”‘ ConfiguraÃ§Ã£o do provedor Infura
// ğŸ“ Adicione sua chave da Infura no arquivo .env.local:
// NEXT_PUBLIC_INFURA_PROJECT_ID=sua_chave_infura_aqui
const sepoliaRpcUrl = process.env.NEXT_PUBLIC_SEPOLIA_RPC_URL
```

**ğŸ“– ExplicaÃ§Ã£o detalhada:**

**`process.env.NEXT_PUBLIC_SEPOLIA_RPC_URL`**:
- **`process.env`**: "Cofre de senhas" do sistema operacional
- **`NEXT_PUBLIC_`**: Prefixo especial do Next.js para variÃ¡veis pÃºblicas
- **Por que NEXT_PUBLIC?**: Permite que o navegador acesse a variÃ¡vel
- **SeguranÃ§a**: NÃ£o coloque chaves privadas aqui (sÃ³ RPC URLs pÃºblicas)

**Analogia**: Como ter um **"cofre com gavetas"**:
- **Gaveta pÃºblica**: `NEXT_PUBLIC_` - qualquer um pode ver
- **Gaveta privada**: Sem prefixo - sÃ³ o servidor vÃª

**Exemplo do arquivo `.env.local`**:
```bash
# .env.local
NEXT_PUBLIC_SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/sua_chave_infura
```

#### **âš™ï¸ 2.3.3 ConfiguraÃ§Ã£o Principal - "Receita de ConexÃ£o"**

```typescript
// âš™ï¸ ConfiguraÃ§Ã£o principal - nossa "receita de conexÃ£o"
export const config = createConfig({
  // ğŸŒ Em qual blockchain vamos trabalhar
  chains: [sepolia],
  
  // ğŸ”Œ Apenas MetaMask como conector
  connectors: [
    metaMask(),  // MetaMask (mais popular e confiÃ¡vel)
  ],
  
  // ğŸŒ ConexÃ£o via Infura - provedor profissional
  transports: {
    [sepolia.id]: http(sepoliaRpcUrl)
  },
})
```

**ğŸ“– ExplicaÃ§Ã£o de cada propriedade:**

**`chains: [sepolia]`**: **"Lista de cidades onde trabalhamos"**
- **O que define**: Quais blockchains seu DApp suporta
- **Sepolia**: Rede de teste do Ethereum (gratuita)
- **Por que array?**: Pode suportar mÃºltiplas redes (Ethereum, Polygon, etc.)
- **Analogia**: Como **"lista de franquias"** de uma empresa

**`connectors: [metaMask()]`**: **"Tipos de carteira aceitos"**
- **O que define**: Quais carteiras os usuÃ¡rios podem conectar
- **MetaMask()**: FunÃ§Ã£o que configura integraÃ§Ã£o com MetaMask
- **Outros conectores**: WalletConnect, Coinbase Wallet, etc.
- **Analogia**: Como **"bandeiras de cartÃ£o aceitas"** numa loja

**`transports: { [sepolia.id]: http(sepoliaRpcUrl) }`**: **"Sistema de entrega"**
- **O que define**: Como se conectar a cada blockchain
- **`[sepolia.id]`**: Chave dinÃ¢mica usando ID da Sepolia (11155111)
- **`http(sepoliaRpcUrl)`**: Protocolo HTTP usando URL da Infura
- **Analogia**: Como **"rotas de entrega"** - cada cidade tem sua rota especÃ­fica

**ğŸ” Por que essa estrutura?**
```typescript
transports: {
  [sepolia.id]: http(sepoliaRpcUrl),
  // [mainnet.id]: http(mainnetRpcUrl),  // Poderia ter mais redes
  // [polygon.id]: http(polygonRpcUrl),  
}
```

#### **ğŸ“ 2.3.4 EndereÃ§o do Contrato - "GPS da Blockchain"**

```typescript
// ğŸ“ EndereÃ§o do nosso smart contract (deployado com sucesso!)
// âœ… ATUALIZADO: Contrato TaskManager na rede Sepolia
export const CONTRACT_ADDRESS = '0xa4545d4bF47D46d5AE101C02eE670aE0052d94Bb' as `0x${string}`
```

**ğŸ“– AnÃ¡lise do endereÃ§o:**

**`0xa4545d4bF47D46d5AE101C02eE670aE0052d94Bb`**: **"CEP da blockchain"**
- **Formato**: Sempre 42 caracteres (0x + 40 hex)
- **Ãšnico**: SÃ³ existe um contrato neste endereÃ§o
- **ImutÃ¡vel**: Nunca muda depois de deployado
- **Analogia**: Como **"coordenadas GPS"** exatas de uma casa

**`as `0x${string}``**: **"Etiqueta de tipo TypeScript"**
- **O que faz**: Diz ao TypeScript "isso Ã© um endereÃ§o vÃ¡lido"
- **Por que importante**: Evita erros de digitaÃ§Ã£o
- **Formato esperado**: 0x seguido de letras/nÃºmeros
- **Analogia**: Como **"carimbo de autenticidade"** num documento

#### **ğŸ“‹ 2.3.5 ABI Completo - "Manual de InstruÃ§Ãµes Detalhado"**

```typescript
// ğŸ“‹ ABI - "Manual de instruÃ§Ãµes" do contrato
export const CONTRACT_ABI = [
    {
        "type": "function",
        "name": "createTask",
        "inputs": [
            {
                "name": "_title",
                "type": "string",
                "internalType": "string"
            },
            {
                "name": "_description", 
                "type": "string",
                "internalType": "string"
            },
            {
                "name": "_deadline",
                "type": "uint256",
                "internalType": "uint256"
            }
        ],
        "outputs": [],
        "stateMutability": "payable"
    },
    // ... outras funÃ§Ãµes
] as const
```

**ğŸ“– Anatomia de uma funÃ§Ã£o ABI:**

**FunÃ§Ã£o `createTask` explicada:**

**`"type": "function"`**: **"Tipo de item do cardÃ¡pio"**
- **OpÃ§Ãµes**: function, event, error, constructor
- **function**: Algo que vocÃª pode chamar/executar
- **Analogia**: Como **"categoria no menu"** (prato principal, sobremesa, etc.)

**`"name": "createTask"`**: **"Nome do prato"**
- **O que Ã©**: Nome exato da funÃ§Ã£o no contrato
- **Case-sensitive**: Deve ser exatamente igual
- **Analogia**: Como **"nome no cardÃ¡pio"** - "Pizza Margherita"

**`"inputs": [...]`**: **"Ingredientes necessÃ¡rios"**
- **O que Ã©**: Lista de parÃ¢metros que a funÃ§Ã£o precisa
- **Ordem importante**: Deve passar na sequÃªncia correta
- **Analogia**: Como **"lista de ingredientes"** de uma receita

**Detalhamento dos inputs:**
```typescript
{
    "name": "_title",           // Nome do parÃ¢metro
    "type": "string",           // Tipo em Solidity  
    "internalType": "string"    // Tipo interno (pode diferir)
}
```

**`"outputs": []`**: **"O que vocÃª recebe de volta"**
- **Array vazio**: Esta funÃ§Ã£o nÃ£o retorna nada
- **Se tivesse**: Lista dos tipos de dados retornados
- **Analogia**: Como **"tempo de preparo"** - quanto tempo atÃ© receber o prato

**`"stateMutability": "payable"`**: **"PolÃ­tica de pagamento"**
- **payable**: FunÃ§Ã£o aceita ETH junto com a chamada
- **view**: SÃ³ lÃª dados (grÃ¡tis)
- **pure**: NÃ£o acessa dados do contrato (grÃ¡tis)
- **nonpayable**: NÃ£o aceita ETH
- **Analogia**: Como **"polÃ­tica de pagamento"** (Ã  vista, cartÃ£o, PIX)

#### **ğŸ¯ 2.3.6 FunÃ§Ãµes Importantes do ABI**

**ğŸ“– Vamos analisar as principais funÃ§Ãµes:**

**1. `getUserTasksWithData` - "Buscar HistÃ³rico Completo":**
```typescript
{
    "type": "function",
    "name": "getUserTasksWithData",
    "inputs": [
        {
            "name": "_user",
            "type": "address",
            "internalType": "address"
        }
    ],
    "outputs": [
        {
            "name": "",
            "type": "tuple[]",  // Array de structs
            "internalType": "struct TaskManager.Task[]",
            "components": [      // DefiniÃ§Ã£o da struct Task
                {
                    "name": "id",
                    "type": "uint256",
                    "internalType": "uint256"
                },
                {
                    "name": "title",
                    "type": "string", 
                    "internalType": "string"
                },
                // ... outros campos da struct
            ]
        }
    ],
    "stateMutability": "view"
}
```

**ExplicaÃ§Ã£o**:
- **Input**: EndereÃ§o do usuÃ¡rio (`address`)
- **Output**: Array de structs `Task[]` completos
- **`tuple[]`**: Array de objetos estruturados
- **`components`**: Define a estrutura interna de cada Task
- **`view`**: FunÃ§Ã£o gratuita (sÃ³ leitura)

**2. `completeTask` - "Finalizar Tarefa":**
```typescript
{
    "type": "function",
    "name": "completeTask", 
    "inputs": [
        {
            "name": "_id",
            "type": "uint256",
            "internalType": "uint256"
        }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
}
```

**ExplicaÃ§Ã£o**:
- **Input**: ID da tarefa (`uint256`)
- **Output**: Nada (sÃ³ executa aÃ§Ã£o)
- **`nonpayable`**: NÃ£o aceita ETH (mas gasta gas)

#### **ğŸ“¢ 2.3.7 Eventos do ABI - "Sistema de NotificaÃ§Ãµes"**

```typescript
{
    "type": "event",
    "name": "TaskCreated",
    "inputs": [
        {
            "name": "id",
            "type": "uint256",
            "indexed": false,
            "internalType": "uint256"
        },
        {
            "name": "title",
            "type": "string",
            "indexed": false,
            "internalType": "string"
        },
        {
            "name": "creator",
            "type": "address",
            "indexed": false,
            "internalType": "address"
        },
        {
            "name": "stakeAmount",
            "type": "uint256",
            "indexed": false,
            "internalType": "uint256"
        },
        {
            "name": "deadline",
            "type": "uint256",
            "indexed": false,
            "internalType": "uint256"
        }
    ],
    "anonymous": false
}
```

**ğŸ“– ExplicaÃ§Ã£o dos eventos:**

**`"type": "event"`**: **"Tipo de notificaÃ§Ã£o"**
- **Eventos**: Logs que ficam gravados na blockchain
- **Uso**: Acompanhar o que aconteceu no contrato
- **Analogia**: Como **"notificaÃ§Ãµes push"** do seu celular

**`"indexed": false`**: **"Tipo de busca"**
- **false**: Dados armazenados, mas nÃ£o indexados para busca
- **true**: Dados otimizados para busca rÃ¡pida
- **Limite**: MÃ¡ximo 3 campos indexed por evento

**`"anonymous": false`**: **"Evento nomeado"**
- **false**: Evento tem nome (normal)
- **true**: Evento anÃ´nimo (raro, economia de gas)

#### **ğŸ”’ 2.3.8 O Modificador `as const` - "ProteÃ§Ã£o TypeScript"**

```typescript
] as const
```

**ğŸ“– Por que `as const` Ã© crucial:**

**Sem `as const`:**
```typescript
const ABI = [{ "name": "createTask", "type": "function" }]
// TypeScript vÃª: Array<object>
// Problema: NÃ£o sabe os nomes das funÃ§Ãµes
```

**Com `as const`:**
```typescript
const ABI = [{ "name": "createTask", "type": "function" }] as const
// TypeScript vÃª: readonly [{ readonly "name": "createTask", readonly "type": "function" }]
// BenefÃ­cio: Conhece exatamente cada funÃ§Ã£o
```

**Vantagens concretas:**
- **Autocompletar**: VS Code sugere nomes de funÃ§Ãµes
- **VerificaÃ§Ã£o**: TypeScript detecta erros de digitaÃ§Ã£o
- **Performance**: Wagmi otimiza melhor o cÃ³digo
- **Analogia**: Como **"lista prÃ©-aprovada"** vs **"lista genÃ©rica"**

#### **ğŸ¯ 2.3.9 Fluxo Completo de Uso**

**Como tudo se conecta:**

```
1. ğŸŒ Usuario acessa site
         â†“
2. âš™ï¸ wagmi carrega config
         â†“  
3. ğŸ”Œ MetaMask conecta
         â†“
4. ğŸ“¡ Infura faz ponte com Sepolia  
         â†“
5. ğŸ“ CONTRACT_ADDRESS localiza contrato
         â†“
6. ğŸ“‹ CONTRACT_ABI "traduz" chamadas
         â†“
7. âš¡ FunÃ§Ã£o executa na blockchain
```

**âœ… Resultado**: Seu frontend consegue **"conversar fluentemente"** com a blockchain, sabendo exatamente onde encontrar o contrato e como usar cada funÃ§Ã£o!

**ğŸ“– ExplicaÃ§Ã£o das configuraÃ§Ãµes:**

**`sepoliaRpcUrl`**: Sua "chave de acesso" Ã  blockchain via Infura
- **Como obter**: https://infura.io/ â†’ Criar conta â†’ Criar projeto â†’ Copiar Project ID
- **Configurar**: Criar `.env.local` e adicionar `NEXT_PUBLIC_SEPOLIA_RPC_URL=sua_url_completa`

**`CONTRACT_ADDRESS`**: "EndereÃ§o fÃ­sico" onde seu contrato mora na blockchain
- **Analogia**: Como endereÃ§o de uma casa - permite encontrar seu contrato

**`CONTRACT_ABI`**: "CardÃ¡pio completo" de todas as funÃ§Ãµes disponÃ­veis
- **`as const`**: Diz ao TypeScript "estes dados nunca mudam" (otimizaÃ§Ã£o)

---

### ğŸ”Œ **Passo 3: Criando Componente de ConexÃ£o Web3**

#### **ğŸ¤” Por que precisamos de um componente de conexÃ£o?**

**Analogia**: Ã‰ como criar um **"porteiro inteligente"** que gerencia quem entra e sai do seu prÃ©dio (DApp).

**ğŸ¯ O que o componente faz:**
- Detecta se MetaMask estÃ¡ instalado
- Conecta/desconecta carteiras
- Mostra status da conexÃ£o (conectado/desconectado)
- Verifica se estÃ¡ na rede correta (Sepolia)
- Exibe endereÃ§o do usuÃ¡rio de forma amigÃ¡vel

#### **ğŸ“ 3.1 Criar `components/WalletConnection.tsx`**

```typescript
// components/WalletConnection.tsx - Gerenciador de ConexÃ£o

'use client'

import { useConnect, useDisconnect, useAccount, useChainId } from 'wagmi'
import { Button } from '@/components/ui/button'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Wallet, AlertCircle } from 'lucide-react'
import { sepolia } from 'wagmi/chains'

export function WalletConnection() {
  // ğŸ£ Hooks do wagmi para gerenciar conexÃ£o
  const { connectors, connect, isPending } = useConnect()
  const { disconnect } = useDisconnect()
  const { address, isConnected } = useAccount()
  const chainId = useChainId()

  // ğŸŒ Verificar se estÃ¡ na rede correta
  const isCorrectNetwork = chainId === sepolia.id
  const networkName = isCorrectNetwork ? 'Sepolia' : `Rede ${chainId}`

  // ğŸ“± Encontrar MetaMask nos conectores disponÃ­veis
  const metamaskConnector = connectors.find(connector => connector.name === 'MetaMask')

  // ğŸ”„ FunÃ§Ã£o para conectar/desconectar
  const handleConnection = () => {
    if (isConnected) {
      disconnect()
    } else if (metamaskConnector) {
      connect({ connector: metamaskConnector })
    }
  }

  // ğŸ“ Formatar endereÃ§o para exibiÃ§Ã£o (0x1234...abcd)
  const shortAddress = address ? `${address.slice(0, 6)}...${address.slice(-4)}` : null

  return (
    <div className="space-y-4">
      {/* ğŸ”Œ BotÃ£o de ConexÃ£o */}
      <div className="flex items-center gap-4">
        {isConnected && (
          <div className="flex flex-col items-end text-sm">
            <span className="text-green-600 font-medium">{shortAddress}</span>
            <div className="flex items-center gap-1">
              <div className={`w-2 h-2 rounded-full ${isCorrectNetwork ? 'bg-green-500' : 'bg-red-500'}`}></div>
              <span className={`text-xs ${isCorrectNetwork ? 'text-green-600' : 'text-red-600'}`}>
                {networkName}
              </span>
            </div>
          </div>
        )}
        
        <Button
          onClick={handleConnection}
          disabled={isPending}
          className={`transition-all duration-300 ${
            isConnected ? "bg-green-600 hover:bg-green-700" : "bg-violet-600 hover:bg-violet-700"
          }`}
        >
          <Wallet className="mr-2 h-4 w-4" />
          {isPending ? 'Conectando...' : isConnected ? 'Carteira Conectada' : 'Conectar Carteira'}
        </Button>
      </div>

      {/* âš ï¸ Alertas informativos */}
      {!isConnected && (
        <Alert variant="destructive" className="border-yellow-500/50 text-yellow-700">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>
            Conecte sua carteira para gerenciar suas tarefas na blockchain.
          </AlertDescription>
        </Alert>
      )}

      {isConnected && !isCorrectNetwork && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>
            VocÃª estÃ¡ na rede {networkName}. Mude para Sepolia para usar este DApp.
          </AlertDescription>
        </Alert>
      )}
    </div>
  )
}
```

#### **ğŸ“– ExplicaÃ§Ã£o detalhada do cÃ³digo:**

**ğŸ£ Hooks do wagmi:**
```typescript
const { connectors, connect, isPending } = useConnect()
const { disconnect } = useDisconnect()
const { address, isConnected } = useAccount()
const chainId = useChainId()
```

- **`useConnect()`**: Gerencia processo de conexÃ£o
  - `connectors`: Lista de carteiras disponÃ­veis (MetaMask, WalletConnect, etc.)
  - `connect()`: FunÃ§Ã£o para conectar uma carteira especÃ­fica
  - `isPending`: `true` enquanto estÃ¡ conectando

- **`useDisconnect()`**: Fornece funÃ§Ã£o para desconectar carteira

- **`useAccount()`**: InformaÃ§Ãµes da conta conectada
  - `address`: EndereÃ§o da carteira (0x123...)
  - `isConnected`: `true` se carteira estÃ¡ conectada

- **`useChainId()`**: ID da rede atual (Sepolia = 11155111)

**ğŸŒ VerificaÃ§Ã£o de rede:**
```typescript
const isCorrectNetwork = chainId === sepolia.id
const networkName = isCorrectNetwork ? 'Sepolia' : `Rede ${chainId}`
```
- **Por que importante**: Evita transaÃ§Ãµes na rede errada
- **Sepolia ID**: 11155111 (rede de teste)

**ğŸ“± Encontrar MetaMask:**
```typescript
const metamaskConnector = connectors.find(connector => connector.name === 'MetaMask')
```
- **Por que**: wagmi suporta vÃ¡rias carteiras, queremos especificamente MetaMask
- **FlexÃ­vel**: Se MetaMask nÃ£o estiver disponÃ­vel, botÃ£o fica desabilitado

**ğŸ“ FormataÃ§Ã£o de endereÃ§o:**
```typescript
const shortAddress = address ? `${address.slice(0, 6)}...${address.slice(-4)}` : null
```
- **Antes**: `0x1234567890abcdef1234567890abcdef12345678`
- **Depois**: `0x1234...5678` (mais legÃ­vel)

#### **ğŸ¨ 3.2 Elementos visuais inteligentes**

**ğŸ”˜ BotÃ£o dinÃ¢mico:**
- **Estado 1**: "Conectar Carteira" (violet) - quando desconectado
- **Estado 2**: "Conectando..." (disabled) - durante conexÃ£o  
- **Estado 3**: "Carteira Conectada" (green) - quando conectado

**ğŸš¨ Sistema de alertas:**
- **Alerta amarelo**: Quando nÃ£o conectado (instructivo)
- **Alerta vermelho**: Quando na rede errada (crÃ­tico)

**ğŸ’¡ Indicador de rede:**
- **Ponto verde**: Rede correta (Sepolia)
- **Ponto vermelho**: Rede incorreta

---

### ğŸ­ **Passo 4: Configurar Providers da AplicaÃ§Ã£o**

Agora vamos configurar os **"fornecedores de energia"** do nosso DApp. Os providers sÃ£o como a **"fiaÃ§Ã£o elÃ©trica"** que distribui funcionalidades Web3 para todo o aplicativo.

#### **ğŸ“ 4.1 Criar `providers/Web3Provider.tsx`**

**Analogia**: Ã‰ como instalar um **"quadro de forÃ§a especializado"** que distribui energia Web3 para todos os cÃ´modos da casa.

```typescript
// providers/Web3Provider.tsx - Provider Web3 isolado

'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from '@/lib/web3'
import { useState, ReactNode } from 'react'

interface Web3ProviderProps {
  children: ReactNode
}

export function Web3Provider({ children }: Web3ProviderProps) {
  // ğŸ§  Cria a "memÃ³ria inteligente" (cache)
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        // âš¡ ConfiguraÃ§Ãµes otimizadas para Web3
        refetchOnWindowFocus: false,
        retry: 1,
        staleTime: 1000 * 60 * 5, // 5 minutos
      },
    },
  }))

  return (
    {/* ğŸ”§ WAGMI: Fornece conexÃ£o Web3 para todo o app */}
    <WagmiProvider config={config}>
      {/* ğŸ—„ï¸ QUERY: Gerencia cache e atualizaÃ§Ãµes automÃ¡ticas */}
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    </WagmiProvider>
  )
}
```

#### **ğŸ“– AnÃ¡lise Detalhada do CÃ³digo `providers/Web3Provider.tsx`**

Vamos dissecar cada linha deste arquivo crucial para entender como funciona nossa **"central de distribuiÃ§Ã£o de energia Web3"**:

#### **ğŸ“¦ 4.1.1 Imports - "Ferramentas Especializadas"**

```typescript
// providers/Web3Provider.tsx - Provider Web3 isolado

'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from '@/lib/web3'
import { useState, ReactNode } from 'react'
```

**Analogia**: Como **reunir ferramentas especializadas** para montar uma central elÃ©trica:

**`'use client'`**: **"Etiqueta de localizaÃ§Ã£o"**
- **O que faz**: Diz ao Next.js "este cÃ³digo roda no navegador"
- **Por que necessÃ¡rio**: Providers precisam gerenciar estado no cliente
- **Analogia**: Como **"placa: Esta mÃ¡quina funciona com eletricidade"**

**`QueryClient, QueryClientProvider`**: **"Sistema de memÃ³ria inteligente"**
- **QueryClient**: Classe que gerencia cache de dados
- **QueryClientProvider**: Componente que distribui cache para filhos
- **Por que importante**: Evita buscar os mesmos dados repetidamente
- **Analogia**: Como **"HD com cache automÃ¡tico"** que lembra dados recentes

**`WagmiProvider`**: **"Distribuidor de energia Web3"**
- **O que faz**: Componente que fornece funcionalidades Web3 para filhos
- **Por que central**: Todos os hooks Web3 dependem dele
- **Analogia**: Como **"quadro de forÃ§a principal"** da casa

**`config`**: **"Manual de instalaÃ§Ã£o"**
- **Vem de**: `@/lib/web3` (o arquivo que configuramos antes)
- **ContÃ©m**: Redes, conectores, transportes, endereÃ§os, ABIs
- **Analogia**: Como **"diagrama elÃ©trico"** com todas as especificaÃ§Ãµes

**`useState, ReactNode`**: **"Ferramentas bÃ¡sicas do React"**
- **useState**: Para gerenciar estado local
- **ReactNode**: Tipo TypeScript para componentes filhos
- **Analogia**: Como **"chaves de fenda bÃ¡sicas"** para montagem

#### **ğŸ“‹ 4.1.2 Interface TypeScript - "EspecificaÃ§Ãµes TÃ©cnicas"**

```typescript
interface Web3ProviderProps {
  children: ReactNode
}
```

**ğŸ“– ExplicaÃ§Ã£o da interface:**

**`Web3ProviderProps`**: **"Manual de uso do componente"**
- **FunÃ§Ã£o**: Define exatamente o que o componente espera receber
- **children**: Todos os componentes filhos que vÃ£o usar Web3
- **ReactNode**: Pode ser qualquer elemento React vÃ¡lido
- **Analogia**: Como **"especificaÃ§Ãµes de entrada"** numa tomada (110V, 220V, etc.)

#### **ğŸ›ï¸ 4.1.3 FunÃ§Ã£o Principal - "Centro de Controle"**

```typescript
export function Web3Provider({ children }: Web3ProviderProps) {
```

**ğŸ“– Anatomia da funÃ§Ã£o:**

**`export function`**: **"FunÃ§Ã£o pÃºblica"**
- **export**: Permite que outros arquivos importem esta funÃ§Ã£o
- **function**: Componente funcional React
- **Analogia**: Como **"porta principal"** da central elÃ©trica

**`{ children }`**: **"DesestruturaÃ§Ã£o de props"**
- **Recebe**: Objeto com propriedade children
- **Extrai**: Diretamente a propriedade children
- **Equivale a**: `props.children` mas mais limpo

#### **ğŸ§  4.1.4 ConfiguraÃ§Ã£o do Cache - "MemÃ³ria Inteligente"**

```typescript
// ğŸ§  Cria a "memÃ³ria inteligente" (cache)
const [queryClient] = useState(() => new QueryClient({
  defaultOptions: {
    queries: {
      // âš¡ ConfiguraÃ§Ãµes otimizadas para Web3
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 1000 * 60 * 5, // 5 minutos
    },
  },
}))
```

**ğŸ“– ExplicaÃ§Ã£o detalhada linha por linha:**

**`const [queryClient] = useState(() => ...)`**: **"Lazy Initialization"**
- **Por que array?**: useState retorna `[valor, setter]`, queremos sÃ³ o valor
- **Por que funÃ§Ã£o?**: `() => new QueryClient(...)` sÃ³ executa uma vez
- **BenefÃ­cio**: QueryClient nÃ£o Ã© recriado a cada render
- **Analogia**: Como **"instalar sistema de cache uma Ãºnica vez"** na central

**`new QueryClient({...})`**: **"Configurar sistema de memÃ³ria"**
- **QueryClient**: Classe principal do TanStack Query
- **defaultOptions**: ConfiguraÃ§Ãµes que se aplicam a todas as consultas
- **Analogia**: Como **"configurar polÃ­ticas padrÃ£o"** do sistema de cache

**`queries: {...}`**: **"Regras para consultas"**
- **queries**: ConfiguraÃ§Ãµes especÃ­ficas para busca de dados
- **Aplicam-se**: A todas as consultas feitas pelos hooks
- **Analogia**: Como **"polÃ­ticas de armazenamento"** de uma biblioteca

**ConfiguraÃ§Ãµes especÃ­ficas:**

**`refetchOnWindowFocus: false`**: **"NÃ£o recarregar ao voltar"**
- **O que faz**: NÃ£o busca dados novos quando usuÃ¡rio volta para aba
- **Por que desabilitado**: Blockchain muda lentamente, nÃ£o precisa de updates frequentes
- **Economia**: Reduz chamadas desnecessÃ¡rias Ã  API
- **Analogia**: Como **"nÃ£o verificar correio toda vez que chega em casa"**

**`retry: 1`**: **"Tentar apenas uma vez extra"**
- **O que faz**: Se consulta falhar, tenta mais 1 vez antes de desistir
- **Por que 1?**: Blockchain pode estar temporariamente ocupada
- **Economia**: Evita spam de requisiÃ§Ãµes se rede estiver congestionada
- **Analogia**: Como **"bater na porta duas vezes antes de desistir"**

**`staleTime: 1000 * 60 * 5`**: **"Dados frescos por 5 minutos"**
- **O que faz**: Considera dados "frescos" por 5 minutos
- **CÃ¡lculo**: 1000ms Ã— 60s Ã— 5min = 300.000ms
- **BenefÃ­cio**: NÃ£o busca dados novos se ainda estÃ£o "frescos"
- **Analogia**: Como **"leite fica bom por 5 minutos fora da geladeira"**

#### **ğŸ”Œ 4.1.5 Estrutura de Providers - "InstalaÃ§Ã£o ElÃ©trica"**

```typescript
return (
  {/* ğŸ”§ WAGMI: Fornece conexÃ£o Web3 para todo o app */}
  <WagmiProvider config={config}>
    {/* ğŸ—„ï¸ QUERY: Gerencia cache e atualizaÃ§Ãµes automÃ¡ticas */}
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  </WagmiProvider>
)
```

**ğŸ“– Hierarquia dos providers explicada:**

**Estrutura em camadas:**
```
ğŸ  Casa (sua aplicaÃ§Ã£o)
â””â”€â”€ ğŸ”§ WagmiProvider (energia Web3)
    â””â”€â”€ ğŸ—„ï¸ QueryClientProvider (sistema de cache)
        â””â”€â”€ ğŸ“± children (seus componentes)
```

**`<WagmiProvider config={config}>`**: **"InstalaÃ§Ã£o elÃ©trica principal"**
- **FunÃ§Ã£o**: Fornece todas as funcionalidades Web3 para componentes filhos
- **config**: Usa nossa configuraÃ§Ã£o do arquivo web3.ts
- **Habilita**: Todos os hooks wagmi (useAccount, useConnect, etc.)
- **Analogia**: Como **"quadro de forÃ§a principal"** que alimenta toda casa

**`<QueryClientProvider client={queryClient}>`**: **"Sistema de backup inteligente"**
- **FunÃ§Ã£o**: Fornece sistema de cache para componentes filhos
- **client**: Usa o QueryClient que configuramos acima
- **Habilita**: Cache automÃ¡tico, sincronizaÃ§Ã£o, atualizaÃ§Ãµes em background
- **Analogia**: Como **"no-break"** que mantÃ©m energia estÃ¡vel

**`{children}`**: **"Aparelhos da casa"**
- **FunÃ§Ã£o**: Todos os componentes que vÃ£o usar Web3
- **Recebem**: Tanto energia Web3 quanto sistema de cache
- **Podem usar**: Qualquer hook do wagmi ou TanStack Query
- **Analogia**: Como **"todos os aparelhos eletrÃ´nicos"** da casa

#### **ğŸ¯ 4.1.6 Por que essa ordem especÃ­fica?**

**âŒ Ordem incorreta seria:**
```typescript
<QueryClientProvider client={queryClient}>
  <WagmiProvider config={config}>  // âŒ ERRADO!
    {children}
  </WagmiProvider>
</QueryClientProvider>
```

**âœ… Ordem correta:**
```typescript
<WagmiProvider config={config}>
  <QueryClientProvider client={queryClient}>  // âœ… CORRETO!
    {children}
  </QueryClientProvider>
</WagmiProvider>
```

**ğŸ“– Por que a ordem importa:**

1. **WagmiProvider primeiro**: Precisa estar "mais externo" porque:
   - Fornece conexÃ£o bÃ¡sica com blockchain
   - TanStack Query vai fazer cache de dados Web3
   - Cache depende da conexÃ£o existir

2. **QueryClientProvider segundo**: "Mais interno" porque:
   - Vai cachear dados que vÃªm via wagmi
   - Precisa que wagmi jÃ¡ esteja disponÃ­vel
   - Ã‰ uma "camada de otimizaÃ§Ã£o" sobre wagmi

**Analogia**: Como **instalar primeiro a eletricidade bÃ¡sica**, depois o **sistema de backup e estabilizaÃ§Ã£o**.

#### **âš¡ 4.1.7 Fluxo de Funcionamento**

**Como tudo funciona na prÃ¡tica:**

```
1. ğŸš€ AplicaÃ§Ã£o inicia
     â†“
2. ğŸ”§ WagmiProvider carrega configuraÃ§Ã£o (web3.ts)
     â†“
3. ğŸ—„ï¸ QueryClient se prepara para cachear
     â†“
4. ğŸ“± Componentes filhos renderizam
     â†“
5. ğŸ£ Hooks wagmi fazem consultas
     â†“
6. ğŸ’¾ TanStack Query guarda resultados em cache
     â†“
7. ğŸ”„ PrÃ³ximas consultas usam cache quando possÃ­vel
```

#### **ğŸ›¡ï¸ 4.1.8 ConfiguraÃ§Ãµes Otimizadas para Web3**

**Por que essas configuraÃ§Ãµes especÃ­ficas para Web3?**

**Blockchain Ã© diferente de APIs tradicionais:**
- **Mais lenta**: TransaÃ§Ãµes levam segundos para confirmar
- **Mais cara**: Cada consulta pode custar gas
- **Mais estÃ¡vel**: Dados mudam menos frequentemente
- **Menos tolerante**: Muitas requisiÃ§Ãµes podem sobrecarregar nÃ³s

**Nossas otimizaÃ§Ãµes:**
- **refetchOnWindowFocus: false**: Blockchain nÃ£o muda quando vocÃª sai da aba
- **retry: 1**: Evita spam em redes congestionadas  
- **staleTime: 5min**: Dados blockchain sÃ£o estÃ¡veis por perÃ­odos longos

#### **ğŸ”§ 4.1.9 Alternativas de ConfiguraÃ§Ã£o**

**Para desenvolvimento local (mais agressivo):**
```typescript
{
  refetchOnWindowFocus: true,   // Ãštil para debugging
  retry: 3,                     // Rede local raramente falha
  staleTime: 1000 * 30,        // 30 segundos para ver mudanÃ§as rÃ¡pido
}
```

**Para produÃ§Ã£o mainnet (mais conservador):**
```typescript
{
  refetchOnWindowFocus: false,  // Mainnet Ã© cara
  retry: 0,                     // Falha rÃ¡pido para nÃ£o gastar gas
  staleTime: 1000 * 60 * 15,   // 15 minutos (dados mudam devagar)
}
```

**ğŸ¯ Resultado final**: Uma infraestrutura Web3 robusta, otimizada e pronta para escalar, que distribui energia Web3 e cache inteligente para toda sua aplicaÃ§Ã£o!

---

### ğŸ£ **Passo 5: Criar Hooks Customizados**

#### **ğŸ¤” Por que criar hooks customizados?**

**Analogia**: Hooks sÃ£o como **"funcionÃ¡rios especializados"** numa empresa:

- **ğŸ‘” Gerente de Tarefas** (useTaskMetrics): Calcula estatÃ­sticas automaticamente
- **ğŸ” Pesquisador** (useAllUserTasks): Busca dados completos da blockchain
- **âœï¸ Assistente de CriaÃ§Ã£o** (useCreateTask): Registra novas tarefas
- **âœ… Supervisor** (useCompleteTask): Marca tarefas como concluÃ­das
- **ğŸ”— Recepcionista** (useWeb3Status): Sabe quem estÃ¡ conectado

**âœ… Vantagens dos hooks customizados:**
- **ReutilizÃ¡vel**: Usa o mesmo hook em vÃ¡rios componentes
- **Organizado**: Cada hook tem uma responsabilidade especÃ­fica
- **AutomÃ¡tico**: Atualiza dados quando a blockchain muda
- **Limpo**: Componente fica simples, lÃ³gica fica nos hooks

#### **ğŸ“ 5.1 Criar `hooks/useTaskManager.ts`**

```typescript
// hooks/useTaskManager.ts - Nossos "assistentes especializados"

import { useReadContract, useWriteContract, useAccount } from 'wagmi'
import { CONTRACT_ADDRESS, CONTRACT_ABI } from '@/lib/web3'
import { parseEther } from 'viem'

// ğŸ” Hook: Buscar todas as tarefas de um usuÃ¡rio (com dados completos)
export function useAllUserTasks() {
  const { address } = useAccount()
  
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'getUserTasksWithData',
    args: address ? [address] : undefined,
    query: { enabled: !!address } // SÃ³ busca se tiver carteira conectada
  })
}

// ğŸ“Š Hook: Calcular mÃ©tricas automaticamente
export function useTaskMetrics() {
  const { data: allTasks, isLoading, error, refetch } = useAllUserTasks()
  
  // Se ainda estÃ¡ carregando ou sem dados
  if (isLoading || !allTasks) {
    return {
      total: 0, concluidas: 0, pendentes: 0, weiInStake: 0,
      tasks: [], isLoading: true, error: null, refetch
    }
  }

  // Se nÃ£o hÃ¡ tarefas
  if (!Array.isArray(allTasks) || allTasks.length === 0) {
    return {
      total: 0, concluidas: 0, pendentes: 0, weiInStake: 0,
      tasks: [], isLoading: false, error: null, refetch
    }
  }

  // ğŸ§® Calcular mÃ©tricas automaticamente
  let concluidas = 0
  let totalStake = 0

  allTasks.forEach((task: any) => {
    if (task.status) {
      concluidas++
    } else {
      totalStake += Number(task.stakeAmount)
    }
  })

  return {
    total: allTasks.length,
    concluidas,
    pendentes: allTasks.length - concluidas,
    weiInStake: totalStake / 1e18, // Converte wei para ETH
    tasks: allTasks,
    isLoading: false,
    error,
    refetch
  }
}

// âœï¸ Hook: Criar nova tarefa
export function useCreateTask() {
  const { writeContract, isPending, error } = useWriteContract()
  
  const createTask = async (
    title: string, 
    description: string, 
    deadline: Date,
    stakeAmount: string = '0.001'
  ) => {
    try {
      // ğŸ—“ï¸ Converte data para timestamp unix
      const deadlineTimestamp = Math.floor(deadline.getTime() / 1000)
      
      // ğŸ“ Chama funÃ§Ã£o do contrato
      await writeContract({
        address: CONTRACT_ADDRESS,
        abi: CONTRACT_ABI,
        functionName: 'createTask',
        args: [title, description, BigInt(deadlineTimestamp)],
        value: parseEther(stakeAmount), // Converte ETH para Wei
      })
      
    } catch (err) {
      console.error('âŒ Erro ao criar tarefa:', err)
      throw err
    }
  }
  
  return { createTask, isPending, error }
}

// âœ… Hook: Completar tarefa
export function useCompleteTask() {
  const { writeContract, isPending, error } = useWriteContract()
  
  const completeTask = async (taskId: number) => {
    try {
      await writeContract({
        address: CONTRACT_ADDRESS,
        abi: CONTRACT_ABI,
        functionName: 'completeTask',
        args: [BigInt(taskId)],
      })
    } catch (err) {
      console.error('âŒ Erro ao completar tarefa:', err)
      throw err
    }
  }
  
  return { completeTask, isPending, error }
}

// ğŸ’° Hook: Saldo do contrato
export function useContractBalance() {
  const { refetch } = useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'getContractBalance',
  })
  
  return { refetchBalance: refetch }
}

// ğŸ”— Hook: Status da conexÃ£o Web3
export function useWeb3Status() {
  const { address, isConnected } = useAccount()
  
  return {
    address,
    isConnected,
    shortAddress: address ? `${address.slice(0, 6)}...${address.slice(-4)}` : null
  }
}
```

#### **ğŸ“– AnÃ¡lise Detalhada dos Hooks Customizados `hooks/useTaskManager.ts`**

Vamos dissecar cada hook para entender como funcionam essas **"mÃ¡quinas especializadas"** que conectam nossa interface com a blockchain:

#### **ğŸ“¦ 5.1.1 Imports e DependÃªncias - "Ferramentas dos Especialistas"**

```typescript
// hooks/useTaskManager.ts - Nossos "assistentes especializados"

import { useReadContract, useWriteContract, useAccount } from 'wagmi'
import { CONTRACT_ADDRESS, CONTRACT_ABI } from '@/lib/web3'
import { parseEther } from 'viem'
```

**Analogia**: Como **reunir ferramentas especÃ­ficas** para cada tipo de trabalho especializado:

**`useReadContract, useWriteContract, useAccount`**: **"Ferramentas bÃ¡sicas do wagmi"**
- **useReadContract**: Como **"microscÃ³pio"** - sÃ³ olha/lÃª dados da blockchain
- **useWriteContract**: Como **"martelo"** - modifica/escreve dados na blockchain  
- **useAccount**: Como **"carteira de identidade"** - informa quem estÃ¡ conectado

**`CONTRACT_ADDRESS, CONTRACT_ABI`**: **"EndereÃ§o e manual do contrato"**
- **CONTRACT_ADDRESS**: "GPS" para encontrar nosso contrato
- **CONTRACT_ABI**: "Manual de instruÃ§Ãµes" para usar o contrato
- **Vem de**: `@/lib/web3` que configuramos antes

**`parseEther`**: **"Conversor de moeda"**
- **FunÃ§Ã£o**: Converte ETH (1.0) para wei (1000000000000000000)
- **Por que necessÃ¡rio**: Blockchain trabalha apenas com wei
- **Analogia**: Como **"conversor de real para centavos"**

#### **ğŸ” 5.1.2 useAllUserTasks() - O "Detetive de Dados"**

```typescript
// ğŸ” Hook: Buscar todas as tarefas de um usuÃ¡rio (com dados completos)
export function useAllUserTasks() {
  const { address } = useAccount()
  
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'getUserTasksWithData',
    args: address ? [address] : undefined,
    query: { enabled: !!address } // SÃ³ busca se tiver carteira conectada
  })
}
```

**ğŸ“– ExplicaÃ§Ã£o linha por linha:**

**`const { address } = useAccount()`**: **"Pegar carteira de identidade"**
- **useAccount()**: Hook do wagmi que monitora conexÃ£o da carteira
- **{ address }**: DesestruturaÃ§Ã£o - pega sÃ³ o endereÃ§o
- **address**: EndereÃ§o da carteira conectada (0x123...) ou `undefined`
- **Analogia**: Como **"verificar se a pessoa tem RG na mÃ£o"**

**`return useReadContract({...})`**: **"Configurar o microscÃ³pio"**
- **useReadContract**: Hook que faz consultas (leitura) Ã  blockchain
- **Retorna**: Objeto com dados, loading, error, refetch
- **Analogia**: Como **"ajustar lentes do microscÃ³pio"** para ver dados

**ConfiguraÃ§Ãµes do microscÃ³pio:**

**`address: CONTRACT_ADDRESS`**: **"Onde procurar"**
- **FunÃ§Ã£o**: Informa qual contrato consultar
- **Valor**: EndereÃ§o do nosso TaskManager deployado
- **Analogia**: Como **"endereÃ§o da empresa"** onde buscar informaÃ§Ãµes

**`abi: CONTRACT_ABI`**: **"Como falar"**
- **FunÃ§Ã£o**: Manual de como chamar funÃ§Ãµes do contrato
- **Valor**: Array com todas as funÃ§Ãµes disponÃ­veis
- **Analogia**: Como **"dicionÃ¡rio de idiomas"** para se comunicar

**`functionName: 'getUserTasksWithData'`**: **"Que pergunta fazer"**
- **FunÃ§Ã£o**: Nome exato da funÃ§Ã£o do contrato a chamar
- **Retorna**: Array completo com dados de todas as tarefas do usuÃ¡rio
- **Analogia**: Como **"fazer pergunta especÃ­fica"** ao atendente

**`args: address ? [address] : undefined`**: **"ParÃ¢metros da pergunta"**
- **Se tem address**: Passa `[endereÃ§o_da_carteira]` como parÃ¢metro
- **Se nÃ£o tem**: Passa `undefined` (nÃ£o faz a chamada)
- **Por que array?**: FunÃ§Ãµes Solidity esperam parÃ¢metros em array
- **Analogia**: Como **"mostrar RG"** quando perguntam seus dados

**`query: { enabled: !!address }`**: **"Quando fazer a pergunta"**
- **!!address**: Converte address em boolean (true se existe, false se nÃ£o)
- **enabled**: SÃ³ executa a consulta quando true
- **Comportamento**: SÃ³ busca dados se carteira estiver conectada
- **Analogia**: Como **"sÃ³ perguntar dados se a pessoa tem RG"**

#### **ğŸ“Š 5.1.3 useTaskMetrics() - A "Calculadora Super Inteligente"**

```typescript
// ğŸ“Š Hook: Calcular mÃ©tricas automaticamente
export function useTaskMetrics() {
  const { data: allTasks, isLoading, error, refetch } = useAllUserTasks()
  
  // Se ainda estÃ¡ carregando ou sem dados
  if (isLoading || !allTasks) {
    return {
      total: 0, concluidas: 0, pendentes: 0, weiInStake: 0,
      tasks: [], isLoading: true, error: null, refetch
    }
  }

  // Se nÃ£o hÃ¡ tarefas
  if (!Array.isArray(allTasks) || allTasks.length === 0) {
    return {
      total: 0, concluidas: 0, pendentes: 0, weiInStake: 0,
      tasks: [], isLoading: false, error: null, refetch
    }
  }

  // ğŸ§® Calcular mÃ©tricas automaticamente
  let concluidas = 0
  let totalStake = 0

  allTasks.forEach((task: any) => {
    if (task.status) {
      concluidas++
    } else {
      totalStake += Number(task.stakeAmount)
    }
  })

  return {
    total: allTasks.length,
    concluidas,
    pendentes: allTasks.length - concluidas,
    weiInStake: totalStake / 1e18, // Converte wei para ETH
    tasks: allTasks,
    isLoading: false,
    error,
    refetch
  }
}
```

**ğŸ“– ExplicaÃ§Ã£o detalhada da lÃ³gica:**

**`const { data: allTasks, isLoading, error, refetch } = useAllUserTasks()`**: **"Receber dados do detetive"**
- **data**: Dados retornados da blockchain (renomeado para allTasks)
- **isLoading**: Se ainda estÃ¡ buscando dados (true/false)
- **error**: Se deu erro na consulta
- **refetch**: FunÃ§Ã£o para buscar dados novamente
- **Analogia**: Como **"receber relatÃ³rio do detetive"** com status da investigaÃ§Ã£o

**Estados de carregamento e erro:**

**Estado 1 - "Aguardando dados":**
```typescript
if (isLoading || !allTasks) {
  return {
    total: 0, concluidas: 0, pendentes: 0, weiInStake: 0,
    tasks: [], isLoading: true, error: null, refetch
  }
}
```
- **Quando**: Primeira vez carregando ou dados ainda nÃ£o chegaram
- **Retorna**: Zeros em tudo + `isLoading: true`
- **Por que**: Evita erros na interface enquanto espera
- **Analogia**: Como **"mostrar '0' na calculadora"** enquanto espera nÃºmeros

**Estado 2 - "Sem tarefas":**
```typescript
if (!Array.isArray(allTasks) || allTasks.length === 0) {
  return {
    total: 0, concluidas: 0, pendentes: 0, weiInStake: 0,
    tasks: [], isLoading: false, error: null, refetch
  }
}
```
- **Quando**: Dados chegaram mas usuÃ¡rio nÃ£o tem tarefas
- **VerificaÃ§Ãµes**: `Array.isArray()` confirma que Ã© array vÃ¡lido
- **Retorna**: Zeros em tudo + `isLoading: false`
- **Analogia**: Como **"conta bancÃ¡ria zerada"** mas funcional

**CÃ¡lculo das mÃ©tricas:**

**PreparaÃ§Ã£o dos contadores:**
```typescript
let concluidas = 0
let totalStake = 0
```
- **concluidas**: Contador de tarefas finalizadas
- **totalStake**: Acumulador de ETH apostado em tarefas pendentes
- **Tipo let**: VariÃ¡veis que vÃ£o mudar durante o loop

**Loop de anÃ¡lise:**
```typescript
allTasks.forEach((task: any) => {
  if (task.status) {
    concluidas++
  } else {
    totalStake += Number(task.stakeAmount)
  }
})
```
- **forEach**: Analisa cada tarefa individualmente
- **task.status**: `true` = concluÃ­da, `false` = pendente
- **Se concluÃ­da**: Soma no contador de concluÃ­das
- **Se pendente**: Soma o stake no total apostado
- **Number()**: Converte string/BigInt para number
- **Analogia**: Como **"contar dinheiro"** separando notas por valor

**Resultado final:**
```typescript
return {
  total: allTasks.length,                    // Total de tarefas
  concluidas,                                // Tarefas finalizadas
  pendentes: allTasks.length - concluidas,   // CÃ¡lculo automÃ¡tico
  weiInStake: totalStake / 1e18,            // ConversÃ£o wei â†’ ETH
  tasks: allTasks,                           // Dados completos
  isLoading: false,                          // NÃ£o estÃ¡ mais carregando
  error,                                     // Repassa erros se houver
  refetch                                    // FunÃ§Ã£o para atualizar
}
```

**ConversÃ£o wei â†’ ETH:**
- **`totalStake / 1e18`**: Divide por 1 seguido de 18 zeros
- **Por que**: 1 ETH = 1.000.000.000.000.000.000 wei
- **Exemplo**: 1000000000000000 wei Ã· 1e18 = 0.001 ETH
- **Analogia**: Como **"converter centavos para reais"** (Ã· 100)

#### **âœï¸ 5.1.4 useCreateTask() - O "Assistente de CriaÃ§Ã£o Inteligente"**

```typescript
// âœï¸ Hook: Criar nova tarefa
export function useCreateTask() {
  const { writeContract, isPending, error } = useWriteContract()
  
  const createTask = async (
    title: string, 
    description: string, 
    deadline: Date,
    stakeAmount: string = '0.001'
  ) => {
    try {
      // ğŸ—“ï¸ Converte data para timestamp unix
      const deadlineTimestamp = Math.floor(deadline.getTime() / 1000)
      
      // ğŸ“ Chama funÃ§Ã£o do contrato
      await writeContract({
        address: CONTRACT_ADDRESS,
        abi: CONTRACT_ABI,
        functionName: 'createTask',
        args: [title, description, BigInt(deadlineTimestamp)],
        value: parseEther(stakeAmount), // Converte ETH para Wei
      })
      
    } catch (err) {
      console.error('âŒ Erro ao criar tarefa:', err)
      throw err
    }
  }
  
  return { createTask, isPending, error }
}
```

**ğŸ“– AnÃ¡lise completa da funÃ§Ã£o:**

**`const { writeContract, isPending, error } = useWriteContract()`**: **"Ferramentas de escrita"**
- **writeContract**: FunÃ§Ã£o para executar transaÃ§Ãµes na blockchain
- **isPending**: Se transaÃ§Ã£o estÃ¡ sendo processada (true/false)
- **error**: Erros que aconteceram durante transaÃ§Ã£o
- **Analogia**: Como **"pegar caneta, papel e borracha"** para escrever

**ParÃ¢metros da funÃ§Ã£o createTask:**
```typescript
const createTask = async (
  title: string,           // TÃ­tulo da tarefa
  description: string,     // DescriÃ§Ã£o detalhada
  deadline: Date,          // Prazo como objeto Date
  stakeAmount: string = '0.001'  // Valor apostado (padrÃ£o 0.001 ETH)
) => {
```
- **async**: FunÃ§Ã£o assÃ­ncrona (trabalha com blockchain)
- **title/description**: Textos que vÃ£o para o contrato
- **deadline**: Data JavaScript que serÃ¡ convertida
- **stakeAmount**: String porque parseEther espera string
- **Valor padrÃ£o**: '0.001' se usuÃ¡rio nÃ£o especificar

**ConversÃ£o de data:**
```typescript
const deadlineTimestamp = Math.floor(deadline.getTime() / 1000)
```
- **deadline.getTime()**: Converte Date para milissegundos desde 1970
- **/ 1000**: Converte milissegundos para segundos (formato blockchain)
- **Math.floor()**: Remove decimais (blockchain usa inteiros)
- **Exemplo**: 25/12/2024 15:30 â†’ 1735134600
- **Analogia**: Como **"converter data para cÃ³digo postal"**

**Chamada do contrato:**
```typescript
await writeContract({
  address: CONTRACT_ADDRESS,              // Onde enviar
  abi: CONTRACT_ABI,                     // Como falar
  functionName: 'createTask',            // Que funÃ§Ã£o chamar
  args: [title, description, BigInt(deadlineTimestamp)],  // ParÃ¢metros
  value: parseEther(stakeAmount),        // ETH a enviar
})
```

**Detalhamento dos parÃ¢metros:**

- **address/abi**: Igual ao useReadContract, define qual contrato e como falar
- **functionName**: Nome exato da funÃ§Ã£o no contrato Solidity
- **args**: Array com parÃ¢metros na ordem exata do contrato
- **value**: ETH a enviar junto com a transaÃ§Ã£o (para funÃ§Ãµes payable)

**PreparaÃ§Ã£o dos argumentos:**
```typescript
args: [title, description, BigInt(deadlineTimestamp)]
```
- **title**: String diretamente (Solidity aceita)
- **description**: String diretamente  
- **BigInt(deadlineTimestamp)**: Converte number para BigInt
- **Por que BigInt?**: Solidity uint256 Ã© muito grande para number JavaScript
- **Analogia**: Como **"usar calculadora cientÃ­fica"** para nÃºmeros grandes

**ConversÃ£o de valor:**
```typescript
value: parseEther(stakeAmount)
```
- **parseEther('0.001')**: Converte "0.001 ETH" para "1000000000000000 wei"
- **Por que**: Blockchain sÃ³ entende wei (menor unidade)
- **FunÃ§Ã£o viem**: Biblioteca otimizada para conversÃµes
- **Analogia**: Como **"converter R$ 1,00 para 100 centavos"**

**Tratamento de erros:**
```typescript
try {
  // ... cÃ³digo da transaÃ§Ã£o
} catch (err) {
  console.error('âŒ Erro ao criar tarefa:', err)
  throw err
}
```
- **try/catch**: Captura erros de rede, gas, rejeiÃ§Ã£o do usuÃ¡rio
- **console.error**: Registra erro para debugging
- **throw err**: Repassa erro para quem chamou a funÃ§Ã£o
- **Analogia**: Como **"ter plano B"** se algo der errado

#### **âœ… 5.1.5 useCompleteTask() - O "Finalizador Preciso"**

```typescript
// âœ… Hook: Completar tarefa
export function useCompleteTask() {
  const { writeContract, isPending, error } = useWriteContract()
  
  const completeTask = async (taskId: number) => {
    try {
      await writeContract({
        address: CONTRACT_ADDRESS,
        abi: CONTRACT_ABI,
        functionName: 'completeTask',
        args: [BigInt(taskId)],
      })
    } catch (err) {
      console.error('âŒ Erro ao completar tarefa:', err)
      throw err
    }
  }
  
  return { completeTask, isPending, error }
}
```

**ğŸ“– ExplicaÃ§Ã£o da simplicidade:**

**Por que mais simples que createTask?**
- **Apenas 1 parÃ¢metro**: SÃ³ precisa do ID da tarefa
- **Sem value**: NÃ£o envia ETH (funÃ§Ã£o nonpayable)
- **Sem conversÃµes complexas**: ID Ã© apenas nÃºmero
- **Analogia**: Como **"marcar checkbox"** numa lista

**ParÃ¢metro Ãºnico:**
```typescript
const completeTask = async (taskId: number) => {
```
- **taskId**: NÃºmero da tarefa (1, 2, 3...)
- **number**: Tipo JavaScript simples
- **SerÃ¡ convertido**: Para BigInt antes de enviar

**ConversÃ£o simples:**
```typescript
args: [BigInt(taskId)]
```
- **BigInt(taskId)**: Converte number para formato blockchain
- **Array Ãºnico**: FunÃ§Ã£o Solidity espera apenas um parÃ¢metro
- **Exemplo**: `BigInt(5)` â†’ `5n` (formato blockchain)

#### **ğŸ’° 5.1.6 useContractBalance() - O "Contador do Cofre"**

```typescript
// ğŸ’° Hook: Saldo do contrato
export function useContractBalance() {
  const { refetch } = useReadContract({
    address: CONTRACT_ADDRESS,
    abi: CONTRACT_ABI,
    functionName: 'getContractBalance',
  })
  
  return { refetchBalance: refetch }
}
```

**ğŸ“– ExplicaÃ§Ã£o da funÃ§Ã£o:**

**Por que sÃ³ refetch?**
- **FunÃ§Ã£o raramente usada**: SÃ³ para estatÃ­sticas administrativas
- **NÃ£o precisa dados automÃ¡ticos**: SÃ³ consulta quando solicitado
- **Economiza recursos**: NÃ£o fica fazendo consultas desnecessÃ¡rias
- **Analogia**: Como **"verificar saldo do cofre"** sÃ³ quando gerente pede

**Como usar na prÃ¡tica:**
```typescript
const { refetchBalance } = useContractBalance()

// Quando quiser consultar:
const checkBalance = async () => {
  const result = await refetchBalance()
  console.log('Saldo do contrato:', result.data)
}
```

#### **ğŸ”— 5.1.7 useWeb3Status() - O "Monitor da ConexÃ£o"**

```typescript
// ğŸ”— Hook: Status da conexÃ£o Web3
export function useWeb3Status() {
  const { address, isConnected } = useAccount()
  
  return {
    address,
    isConnected,
    shortAddress: address ? `${address.slice(0, 6)}...${address.slice(-4)}` : null
  }
}
```

**ğŸ“– Funcionalidade detalhada:**

**Dados originais:**
```typescript
const { address, isConnected } = useAccount()
```
- **address**: EndereÃ§o completo da carteira (42 caracteres)
- **isConnected**: Boolean indicando se estÃ¡ conectado
- **Fonte**: Hook nativo do wagmi

**FormataÃ§Ã£o inteligente:**
```typescript
shortAddress: address ? `${address.slice(0, 6)}...${address.slice(-4)}` : null
```
- **address.slice(0, 6)**: Primeiros 6 caracteres (0x1234)
- **address.slice(-4)**: Ãšltimos 4 caracteres (abcd)
- **Template string**: Junta com "..." no meio
- **Resultado**: "0x1234...abcd"
- **Se nÃ£o conectado**: Retorna null
- **Analogia**: Como **"resumir nÃºmero de telefone"** (11) 9999-1234

#### **ğŸ¯ 5.1.8 Fluxo de Uso dos Hooks**

**Como os hooks trabalham juntos:**

```
1. ğŸ”— useWeb3Status()
   â†“ (verifica se conectado)
   
2. ğŸ” useAllUserTasks()
   â†“ (busca dados se conectado)
   
3. ğŸ“Š useTaskMetrics()
   â†“ (processa e calcula)
   
4. ğŸ¨ Interface usa mÃ©tricas
   â†“
   
5. âœï¸ useCreateTask() (quando usuÃ¡rio cria)
   â†“
   
6. âœ… useCompleteTask() (quando usuÃ¡rio completa)
   â†“
   
7. ğŸ”„ Dados atualizam automaticamente
```

#### **ğŸ›¡ï¸ 5.1.9 PadrÃµes de SeguranÃ§a e OtimizaÃ§Ã£o**

**SeguranÃ§a implementada:**
- **VerificaÃ§Ã£o de conexÃ£o**: `enabled: !!address`
- **Tratamento de erros**: try/catch em todas as funÃ§Ãµes
- **ValidaÃ§Ã£o de tipos**: TypeScript + BigInt para nÃºmeros grandes
- **Estados de loading**: Evita aÃ§Ãµes durante processamento

**OtimizaÃ§Ãµes implementadas:**
- **Cache automÃ¡tico**: TanStack Query cacheia dados
- **Lazy loading**: SÃ³ busca quando conectado
- **Reuse de hooks**: useTaskMetrics reutiliza useAllUserTasks
- **Estados consistentes**: Sempre retorna formato padrÃ£o

**ğŸ¯ Resultado**: Hooks robustos, otimizados e seguros que abstraem toda a complexidade Web3 para desenvolvedores!

---

### ğŸ”§ **Passo 6: Atualizar layout.tsx**

Agora vamos conectar nossos providers Ã  aplicaÃ§Ã£o. O `layout.tsx` Ã© como a **"fiaÃ§Ã£o principal"** da casa que distribui energia para todos os cÃ´modos.

#### **ğŸ¤” Por que modificar o layout.tsx?**

**Analogia**: O `layout.tsx` Ã© como o **"chassi principal"** de um carro - tudo se conecta nele.

**ğŸ¯ O que vamos fazer:**
- Importar o Web3Provider que criamos
- Envolver toda a aplicaÃ§Ã£o com funcionalidades Web3
- Adicionar sistema de notificaÃ§Ãµes (Toaster)
- Manter otimizaÃ§Ãµes do Next.js (Server Components)

#### **ğŸ“ 6.1 Modificar `app/layout.tsx`**

```typescript
// app/layout.tsx - FiaÃ§Ã£o principal da aplicaÃ§Ã£o

import { Web3Provider } from '@/providers/Web3Provider'
import { Toaster } from '@/components/ui/toaster'
import type { Metadata } from 'next'
import './globals.css'

export const metadata: Metadata = {
  title: 'TaskManager DApp',
  description: 'Gerencie suas tarefas na blockchain Ethereum (Sepolia)',
  keywords: ['blockchain', 'ethereum', 'web3', 'dapp', 'task manager'],
  authors: [{ name: 'Seu Nome' }],
  viewport: 'width=device-width, initial-scale=1',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="pt-BR">
      <body className="min-h-screen bg-background font-sans antialiased">
        <Web3Provider>
          <main className="relative flex min-h-screen flex-col">
            {children}
          </main>
          <Toaster />
        </Web3Provider>
      </body>
    </html>
  )
  }
  ```

#### **ğŸ“– ExplicaÃ§Ã£o detalhada do cÃ³digo:**

**ğŸš« Nota sobre `'use client'`:**
```typescript
// âŒ NÃƒO tem 'use client' no layout.tsx
```
- **Por que nÃ£o**: Layout Ã© Server Component (roda no servidor)
- **BenefÃ­cios**: SEO melhor, carregamento mais rÃ¡pido
- **Como funciona**: SÃ³ o Web3Provider que tem 'use client'

```typescript
import { Web3Provider } from '@/providers/Web3Provider'
import { Toaster } from '@/components/ui/toaster'
import type { Metadata } from 'next'
import './globals.css'
```

- **`Web3Provider`**: O provider que criamos no Passo 4
- **`Toaster`**: Sistema de notificaÃ§Ãµes para transaÃ§Ãµes
- **`Metadata`**: Tipagem do Next.js para metadados
- **`globals.css`**: Estilos globais da aplicaÃ§Ã£o

**ğŸ”§ ConfiguraÃ§Ã£o de metadados:**
```typescript
export const metadata: Metadata = {
  title: 'TaskManager DApp',
  description: 'Gerencie suas tarefas na blockchain Ethereum (Sepolia)',
  keywords: ['blockchain', 'ethereum', 'web3', 'dapp', 'task manager'],
  authors: [{ name: 'Seu Nome' }],
  viewport: 'width=device-width, initial-scale=1',
}
```

- **title**: Aparece na aba do navegador
- **description**: Para Google e redes sociais
- **keywords**: Para SEO
- **viewport**: Para responsividade mobile

**ğŸ  Estrutura principal:**
```typescript
<html lang="pt-BR">
  <body className="min-h-screen bg-background font-sans antialiased">
    <Web3Provider>
      <main className="relative flex min-h-screen flex-col">
        {children}
      </main>
      <Toaster />
    </Web3Provider>
  </body>
</html>
```

**ğŸ“– ExplicaÃ§Ã£o de cada elemento:**

- **`<html lang="pt-BR">`**: Define idioma para acessibilidade
- **`<body>`**: Estilos bÃ¡sicos (altura, fonte, suavizaÃ§Ã£o)
- **`<Web3Provider>`**: **CHAVE!** Envolve tudo com funcionalidades Web3
- **`<main>`**: Ãrea principal das pÃ¡ginas
- **`{children}`**: ConteÃºdo das pÃ¡ginas (page.tsx)
- **`<Toaster />`**: NotificaÃ§Ãµes de transaÃ§Ãµes

---

### ğŸ’» **Passo 7: Implementar Interface na page.tsx**

Agora vamos criar a interface principal que usa todos os componentes e hooks que criamos. A `page.tsx` Ã© como a **"sala principal"** da casa onde tudo se conecta.

#### **ğŸ¤” O que vamos implementar na page.tsx?**

**ğŸ¯ Funcionalidades principais:**
- Sistema de conexÃ£o/desconexÃ£o de carteira
- VerificaÃ§Ã£o de rede (deve estar na Sepolia)
- Cards de mÃ©tricas em tempo real
- Lista de tarefas com dados da blockchain
- Modal para criar novas tarefas
- Sistema de notificaÃ§Ãµes

#### **ğŸ“ 7.1 ImplementaÃ§Ã£o da `app/page.tsx`**

```typescript
// app/page.tsx - Interface principal do DApp

"use client"

import { useState } from "react"
import { useConnect, useDisconnect, useChainId } from 'wagmi'
import { Button } from "@/components/ui/button"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { AlertCircle, CheckCircle2, ListTodo, Loader, Coins, PlusCircle, Wallet } from "lucide-react"

// ğŸ”§ Hooks customizados que criamos
import { useWeb3Status, useContractBalance, useTaskMetrics } from '@/hooks/useTaskManager'
import { CreateTaskModal } from '@/components/CreateTaskModal'
import { TaskItem } from '@/components/TaskItem'
import { sepolia } from 'wagmi/chains'

export default function Web3TodoPage() {
  const [showCreateModal, setShowCreateModal] = useState(false)
  
  // ğŸ”— Hooks Web3 simplificados
  const { connectors, connect } = useConnect()
  const { disconnect } = useDisconnect()
  const { isConnected, shortAddress } = useWeb3Status()
  const { refetchBalance } = useContractBalance()
  const chainId = useChainId()
  
  // ğŸš€ Hook central que faz tudo
  const {
    total, concluidas, pendentes, weiInStake, tasks,
    isLoading: loadingTasks, refetch: refetchTasks
  } = useTaskMetrics()
  
  // ğŸŒ VerificaÃ§Ã£o de rede
  const isCorrectNetwork = chainId === sepolia.id
  const networkName = chainId === sepolia.id ? 'Sepolia' : `Rede ${chainId}`

  // ğŸ”„ FunÃ§Ã£o para conectar/desconectar
  const handleConnectWallet = () => {
    if (isConnected) {
      disconnect()
    } else {
      const metamask = connectors.find(c => c.name === 'MetaMask')
      if (metamask) connect({ connector: metamask })
    }
  }

  return (
    <TooltipProvider>
      <div className="min-h-screen bg-gray-50 text-gray-900">
        <main className="container mx-auto p-4 sm:p-6 lg:p-8">
          
          {/* ğŸ¯ CABEÃ‡ALHO */}
          <header className="mb-8">
            <div className="flex flex-col sm:flex-row justify-between items-center gap-4">
              <h1 className="text-3xl font-bold text-gray-800">WEB3 TODO</h1>
              
              <div className="flex items-center gap-2">
                {isConnected && (
                  <div className="flex flex-col items-end text-sm">
                    <span className="text-green-600 font-medium">{shortAddress}</span>
                    <div className="flex items-center gap-1">
                      <div className={`w-2 h-2 rounded-full ${isCorrectNetwork ? 'bg-green-500' : 'bg-red-500'}`}></div>
                      <span className={`text-xs ${isCorrectNetwork ? 'text-green-600' : 'text-red-600'}`}>
                        {networkName}
                      </span>
                    </div>
                  </div>
                )}
                
                <Button
                  onClick={handleConnectWallet}
                  className={`transition-all duration-300 ${
                    isConnected ? "bg-green-600 hover:bg-green-700" : "bg-violet-600 hover:bg-violet-700"
                  }`}
                >
                  <Wallet className="mr-2 h-4 w-4" />
                  {isConnected ? "Carteira Conectada" : "Conectar Carteira"}
                </Button>
              </div>
            </div>
            
            {/* âš ï¸ Alertas */}
            {!isConnected && (
              <Alert variant="destructive" className="mt-4 border-yellow-500/50 text-yellow-700">
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>
                  Conecte sua carteira para gerenciar suas tarefas na blockchain.
                </AlertDescription>
              </Alert>
            )}

            {isConnected && !isCorrectNetwork && (
              <Alert variant="destructive" className="mt-4">
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>
                  VocÃª estÃ¡ na rede {networkName}. Mude para Sepolia para usar este DApp.
                </AlertDescription>
              </Alert>
            )}
          </header>

          {/* ğŸ“Š SEÃ‡ÃƒO DE MÃ‰TRICAS */}
          <section className="mb-10">
            <div className="grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-4">
              <MetricCard
                title="Total de Tarefas"
                value={total}
                icon={<ListTodo className="h-6 w-6 text-violet-500" />}
                tooltip="NÃºmero total de tarefas criadas"
              />
              <MetricCard
                title="Tarefas ConcluÃ­das"
                value={concluidas}
                icon={<CheckCircle2 className="h-6 w-6 text-cyan-500" />}
                tooltip="Tarefas finalizadas no prazo - stake devolvido"
              />
              <MetricCard
                title="Tarefas Pendentes"
                value={pendentes}
                icon={<Loader className="h-6 w-6 text-yellow-500" />}
                tooltip="Tarefas ainda nÃ£o concluÃ­das"
              />
              <MetricCard
                title="ETH em Stake"
                value={`${weiInStake.toFixed(6)} ETH`}
                icon={<Coins className="h-6 w-6 text-indigo-500" />}
                tooltip="Valor total apostado em tarefas pendentes"
              />
            </div>
          </section>

          {/* ğŸ“‹ SEÃ‡ÃƒO DE TAREFAS */}
          <section>
            <div className="flex justify-between items-center mb-6">
              <h2 className="text-2xl font-semibold text-gray-800">Tarefas</h2>
              
              <Button 
                disabled={!isConnected} 
                className="bg-violet-600 hover:bg-violet-700 disabled:opacity-50"
                onClick={() => setShowCreateModal(true)}
              >
                <PlusCircle className="mr-2 h-4 w-4" />
                Nova Tarefa
              </Button>
            </div>
            
            <div className="space-y-4">
              {loadingTasks && isConnected ? (
                <div className="text-center p-8">
                  <Loader className="animate-spin h-8 w-8 mx-auto mb-4" />
                  <p>Carregando tarefas da blockchain...</p>
                </div>
              ) : (!tasks || tasks.length === 0) && isConnected ? (
                <div className="text-center p-8">
                  <p className="text-gray-500">VocÃª ainda nÃ£o tem tarefas. Crie sua primeira!</p>
                </div>
              ) : isConnected && tasks ? (
                tasks.map((task: any) => (
                  <TaskItem 
                    key={Number(task.id)} 
                    task={task}
                    isConnected={isConnected}
                  />
                ))
              ) : null}
              
              {!isConnected && (
                <div className="text-center p-8">
                  <AlertCircle className="h-12 w-12 mx-auto mb-4 text-gray-400" />
                  <p className="text-gray-500">Conecte sua carteira para ver suas tarefas</p>
                </div>
              )}
            </div>
          </section>
        </main>
      </div>
      
      {/* Modal de Criar Tarefa */}
      <CreateTaskModal 
        open={showCreateModal} 
        onClose={() => setShowCreateModal(false)} 
      />
    </TooltipProvider>
  )
}

// ğŸ¨ Componente reutilizÃ¡vel para cards de mÃ©tricas
function MetricCard({ title, value, icon, tooltip }) {
  const content = (
    <Card className="transition-shadow duration-300 hover:shadow-lg cursor-pointer">
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium text-gray-500">{title}</CardTitle>
        {icon}
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
      </CardContent>
    </Card>
  )

  if (tooltip) {
    return (
      <Tooltip>
        <TooltipTrigger asChild>{content}</TooltipTrigger>
        <TooltipContent><p>{tooltip}</p></TooltipContent>
      </Tooltip>
    )
  }

  return content
}
```

#### **ğŸ“– ExplicaÃ§Ã£o detalhada dos pontos-chave:**

**ğŸ”Œ Gerenciamento de Estado:**
```typescript
const [showCreateModal, setShowCreateModal] = useState(false)
```
- **Estado local**: Controla se o modal de criar tarefa estÃ¡ aberto
- **Simples e efetivo**: Apenas true/false

**ğŸ£ Uso dos Hooks Customizados:**
```typescript
const { isConnected, shortAddress } = useWeb3Status()
const { total, concluidas, pendentes, weiInStake, tasks } = useTaskMetrics()
```
- **useWeb3Status()**: Sabe se carteira estÃ¡ conectada
- **useTaskMetrics()**: Pega todos os dados e calcula mÃ©tricas automaticamente
- **Simplicidade**: Um hook faz todo o trabalho pesado

**ğŸŒ VerificaÃ§Ã£o Inteligente de Rede:**
```typescript
const isCorrectNetwork = chainId === sepolia.id
const networkName = chainId === sepolia.id ? 'Sepolia' : `Rede ${chainId}`
```
- **SeguranÃ§a**: SÃ³ funciona na Sepolia (rede de teste)
- **UX**: Mostra alerta se estiver na rede errada

**âš¡ RenderizaÃ§Ã£o Condicional Inteligente:**
```typescript
{loadingTasks && isConnected ? (
  <LoadingSpinner />
) : (!tasks || tasks.length === 0) && isConnected ? (
  <EmptyState />
) : isConnected && tasks ? (
  <TasksList />
) : (
  <NotConnectedState />
)}
```
- **4 estados diferentes**: Loading, Empty, WithData, NotConnected
- **UX fluida**: UsuÃ¡rio sempre vÃª algo apropriado

---

### ğŸ“ **Passo 7.2: Criando Modal de Tarefas (CreateTaskModal.tsx)**

O modal de criaÃ§Ã£o Ã© como um **"formulÃ¡rio inteligente"** que coleta informaÃ§Ãµes do usuÃ¡rio e as envia diretamente para a blockchain.

#### **ğŸ¤” Por que precisamos de um modal separado?**

**Analogia**: Ã‰ como ter um **"balcÃ£o de atendimento especializado"** numa agÃªncia bancÃ¡ria - ao invÃ©s de misturar tudo na mesma tela, vocÃª tem um espaÃ§o dedicado para cada operaÃ§Ã£o especÃ­fica.

**ğŸ¯ Vantagens do modal:**
- **Foco**: UsuÃ¡rio se concentra apenas na criaÃ§Ã£o
- **ValidaÃ§Ã£o**: Dados sÃ£o verificados antes do envio
- **UX limpa**: Interface principal nÃ£o fica poluÃ­da
- **ReutilizaÃ§Ã£o**: Pode ser usado em vÃ¡rias pÃ¡ginas

#### **ğŸ“ 7.2.1 Anatomia do `components/CreateTaskModal.tsx`**

```typescript
// components/CreateTaskModal.tsx - Modal para criar tarefas

'use client'

import { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Label } from '@/components/ui/label'
import { Loader } from 'lucide-react'
import { useCreateTask } from '@/hooks/useTaskManager'

interface CreateTaskModalProps {
  open: boolean
  onClose: () => void
}
```

#### **ğŸ“– ExplicaÃ§Ã£o dos imports e interface:**

**ğŸ­ Componentes UI:**
- **`Dialog`**: "Janela flutuante" que sobrepÃµe a tela principal
- **`Button, Input, Textarea, Label`**: PeÃ§as do formulÃ¡rio
- **`Loader`**: Ãcone de carregamento animado

**ğŸ£ Hook customizado:**
- **`useCreateTask`**: Nosso "assistente especializado" em criar tarefas

**ğŸ“‹ Interface (Contrato):**
```typescript
interface CreateTaskModalProps {
  open: boolean    // Modal estÃ¡ aberto? (true/false)
  onClose: () => void  // FunÃ§Ã£o para fechar modal
}
```
- **Analogia**: Como **"instruÃ§Ãµes de operaÃ§Ã£o"** de uma mÃ¡quina - deve receber um botÃ£o liga/desliga e um botÃ£o de emergÃªncia

#### **ğŸ“Š 7.2.2 Estados do Modal - A "MemÃ³ria" do FormulÃ¡rio**

```typescript
export function CreateTaskModal({ open, onClose }: CreateTaskModalProps) {
  const [title, setTitle] = useState('')
  const [description, setDescription] = useState('')
  const [deadline, setDeadline] = useState('')
  const [stakeAmount, setStakeAmount] = useState('0.001')
  
  const { createTask, isPending } = useCreateTask()
```

**ğŸ“ ExplicaÃ§Ã£o dos estados:**

**`useState('')` para textos:**
- **`title`**: Nome da tarefa (ex: "Estudar Solidity")
- **`description`**: Detalhes da tarefa
- **`deadline`**: Data limite no formato HTML datetime-local
- **`stakeAmount`**: Valor apostado (padrÃ£o: 0.001 ETH)

**Analogia**: Como **"campos de um formulÃ¡rio de papel"** que vocÃª vai preenchendo aos poucos - cada campo tem seu prÃ³prio espaÃ§o na memÃ³ria.

**Hook de criaÃ§Ã£o:**
```typescript
const { createTask, isPending } = useCreateTask()
```
- **`createTask`**: FunÃ§Ã£o que envia dados para blockchain
- **`isPending`**: `true` enquanto transaÃ§Ã£o estÃ¡ sendo processada

#### **âš¡ 7.2.3 LÃ³gica de Envio - "Entregando o FormulÃ¡rio"**

```typescript
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault() // Impede recarregar a pÃ¡gina
  
  try {
    const deadlineDate = new Date(deadline)
    await createTask(title, description, deadlineDate, stakeAmount)
    
    // Limpa formulÃ¡rio e fecha modal
    setTitle('')
    setDescription('')
    setDeadline('')
    setStakeAmount('0.001')
    onClose()
    
  } catch (error) {
    console.error('Erro ao criar tarefa:', error)
  }
}
```

**ğŸ“– ExplicaÃ§Ã£o linha por linha:**

**1. `e.preventDefault()`:**
- **O que faz**: Impede comportamento padrÃ£o do formulÃ¡rio HTML
- **Por que**: Sem isso, pÃ¡gina recarregaria e perderia dados
- **Analogia**: Como **"segurar a porta"** para nÃ£o fechar sozinha

**2. `const deadlineDate = new Date(deadline)`:**
- **O que faz**: Converte string datetime-local para objeto Date
- **Exemplo**: "2024-12-25T15:30" â†’ Date object
- **Por que**: Smart contract precisa de timestamp unix (nÃºmero)

**3. `await createTask(...)`:**
- **O que faz**: Chama nosso hook para enviar Ã  blockchain
- **ParÃ¢metros**: Todos os dados coletados no formulÃ¡rio
- **`await`**: Espera transaÃ§Ã£o ser processada antes de continuar

**4. Limpeza do formulÃ¡rio:**
```typescript
setTitle('')           // Limpa campo tÃ­tulo
setDescription('')     // Limpa campo descriÃ§Ã£o
setDeadline('')        // Limpa campo prazo
setStakeAmount('0.001') // Volta ao valor padrÃ£o
onClose()              // Fecha o modal
```
- **Analogia**: Como **"jogar o papel usado fora"** e preparar formulÃ¡rio novo para prÃ³xima pessoa

#### **ğŸ“… 7.2.4 ValidaÃ§Ã£o de Data - "Detector de Viagem no Tempo"**

```typescript
// Gera data mÃ­nima (hoje + 1 hora)
const minDateTime = new Date(Date.now() + 60 * 60 * 1000).toISOString().slice(0, 16)
```

**ğŸ“– ExplicaÃ§Ã£o da matemÃ¡tica temporal:**
- **`Date.now()`**: Agora em milissegundos (ex: 1703980800000)
- **`+ 60 * 60 * 1000`**: Soma 1 hora (60 min Ã— 60 seg Ã— 1000 ms)
- **`.toISOString()`**: Converte para formato ISO ("2024-12-25T15:30:00.000Z")
- **`.slice(0, 16)`**: Pega sÃ³ "2024-12-25T15:30" (formato datetime-local)

**ğŸš« Por que 1 hora mÃ­nima?**
- **Evita prazos impossÃ­veis**: NÃ£o pode criar tarefa para "agora" ou passado
- **Buffer de seguranÃ§a**: DÃ¡ tempo para escrever descriÃ§Ã£o e enviar transaÃ§Ã£o
- **UX melhor**: ForÃ§a usuÃ¡rio a pensar em prazo realista

#### **ğŸ¨ 7.2.5 Interface do Modal - "BalcÃ£o de Atendimento"**

```typescript
return (
  <Dialog open={open} onOpenChange={onClose}>
    <DialogContent className="sm:max-w-[500px]">
      <DialogHeader>
        <DialogTitle>ğŸ¯ Nova Tarefa na Blockchain</DialogTitle>
      </DialogHeader>
      
      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Campos do formulÃ¡rio */}
      </form>
    </DialogContent>
  </Dialog>
)
```

**ğŸ“– Componentes explicados:**

**`Dialog`**: Container principal
- **`open={open}`**: Controla se modal estÃ¡ visÃ­vel
- **`onOpenChange={onClose}`**: Fecha quando clica fora ou ESC

**`DialogContent`**: Ãrea do formulÃ¡rio
- **`sm:max-w-[500px]`**: Largura mÃ¡xima em telas pequenas

**`form onSubmit={handleSubmit}`**: FormulÃ¡rio inteligente
- **Ao pressionar Enter**: Chama `handleSubmit`
- **Ao clicar "Criar Tarefa"**: Chama `handleSubmit`

#### **ğŸ“ 7.2.6 Campos do FormulÃ¡rio - "Fichas de Cadastro"**

**1. Campo TÃ­tulo:**
```typescript
<div className="space-y-2">
  <Label htmlFor="title">TÃ­tulo da Tarefa</Label>
  <Input
    id="title"
    value={title}
    onChange={(e) => setTitle(e.target.value)}
    placeholder="Ex: Estudar Solidity"
    required
  />
</div>
```

**2. Campo DescriÃ§Ã£o:**
```typescript
<Textarea
  id="description"
  value={description}
  onChange={(e) => setDescription(e.target.value)}
  placeholder="Descreva o que precisa ser feito..."
  rows={3}
  required
/>
```

**3. Campo Prazo:**
```typescript
<Input
  id="deadline"
  type="datetime-local"
  value={deadline}
  onChange={(e) => setDeadline(e.target.value)}
  min={minDateTime}  // âš¡ NÃ£o permite data passada
  required
/>
```

**4. Campo Stake:**
```typescript
<Input
  id="stake"
  type="number"
  step="0.001"        // Incrementos de 0.001
  min="0.001"         // Valor mÃ­nimo
  value={stakeAmount}
  onChange={(e) => setStakeAmount(e.target.value)}
  required
/>
<p className="text-xs text-gray-500">
  ğŸ’¡ MÃ­nimo: 0.001 ETH â€¢ VocÃª recupera se completar no prazo!
</p>
```

#### **ğŸ”˜ 7.2.7 BotÃµes de AÃ§Ã£o - "DecisÃµes Finais"**

```typescript
<div className="flex justify-end gap-3 pt-4">
  <Button type="button" variant="outline" onClick={onClose}>
    Cancelar
  </Button>
  <Button type="submit" disabled={isPending} className="bg-violet-600 hover:bg-violet-700">
    {isPending ? (
      <>
        <Loader className="mr-2 h-4 w-4 animate-spin" />
        Criando...
      </>
    ) : (
      'Criar Tarefa'
    )}
  </Button>
</div>
```

**ğŸ“– LÃ³gica dos botÃµes:**

**BotÃ£o Cancelar:**
- **`type="button"`**: NÃ£o submete formulÃ¡rio
- **`onClick={onClose}`**: Fecha modal sem salvar

**BotÃ£o Criar:**
- **`type="submit"`**: Submete formulÃ¡rio (chama `handleSubmit`)
- **`disabled={isPending}`**: Desabilitado enquanto processa
- **Estado dinÃ¢mico**:
  - **Normal**: "Criar Tarefa"
  - **Processando**: Spinner + "Criando..."

**Analogia**: Como **"botÃµes de um caixa eletrÃ´nico"** - um para cancelar operaÃ§Ã£o, outro para confirmar e processar.

---

### ğŸ“‹ **Passo 7.3: Componente de Item de Tarefa (TaskItem.tsx)**

Cada tarefa Ã© exibida atravÃ©s de um componente especializado que funciona como um **"cartÃ£o inteligente"** - mostra informaÃ§Ãµes e permite aÃ§Ãµes especÃ­ficas.

#### **ğŸ¤” Por que um componente separado para cada tarefa?**

**Analogia**: Ã‰ como ter **"fichas individuais"** numa agenda mÃ©dica - cada paciente tem sua prÃ³pria ficha com dados especÃ­ficos e aÃ§Ãµes possÃ­veis (consultar, remarcar, etc.).

**ğŸ¯ Vantagens do componente isolado:**
- **ReutilizaÃ§Ã£o**: Uma tarefa = um componente
- **Responsabilidade Ãºnica**: SÃ³ cuida de mostrar/gerenciar uma tarefa
- **Estilo dinÃ¢mico**: Visual muda conforme status da tarefa
- **AÃ§Ãµes contextuais**: BotÃµes aparecem/somem conforme necessÃ¡rio

#### **ğŸ“ 7.3.1 Estrutura do `components/TaskItem.tsx`**

```typescript
'use client'

import { Card, CardContent } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip'
import { CheckSquare, Loader, Coins } from 'lucide-react'
import { useCompleteTask } from '@/hooks/useTaskManager'

interface TaskItemProps {
  task: any // Dados completos da tarefa da blockchain
  isConnected: boolean
  onTaskUpdate?: () => void // Callback para atualizar lista
}
```

#### **ğŸ“– ExplicaÃ§Ã£o da interface:**

**`TaskItemProps` - "InstruÃ§Ãµes de Uso":**
- **`task`**: Objeto com todos os dados da tarefa (vem da blockchain)
- **`isConnected`**: Se usuÃ¡rio estÃ¡ com carteira conectada
- **`onTaskUpdate?`**: FunÃ§Ã£o opcional para atualizar lista apÃ³s aÃ§Ãµes

**ğŸ­ Imports especializados:**
- **`Card, Badge, Button`**: Componentes visuais
- **`Tooltip`**: Dicas contextuais ao passar mouse
- **`CheckSquare, Loader, Coins`**: Ãcones especÃ­ficos
- **`useCompleteTask`**: Hook para completar tarefas

#### **âš¡ 7.3.2 Processamento de Dados - "Tradutor de Blockchain"**

```typescript
export function TaskItem({ task, isConnected, onTaskUpdate }: TaskItemProps) {
  const { completeTask, isPending } = useCompleteTask()

  // Processar dados da tarefa
  const now = Math.floor(Date.now() / 1000)
  const isOverdue = now > Number(task.deadline) && !task.status
  const isCompleted = task.status
  const createdDate = new Date(Number(task.createdAt) * 1000)
  const deadlineDate = new Date(Number(task.deadline) * 1000)
  const stakeInEth = Number(task.stakeAmount) / 1e18
```

**ğŸ“– ExplicaÃ§Ã£o das conversÃµes:**

**Tempo atual em segundos:**
```typescript
const now = Math.floor(Date.now() / 1000)
```
- **`Date.now()`**: Agora em milissegundos
- **`/ 1000`**: Converte para segundos (formato blockchain)
- **`Math.floor()`**: Remove decimais (sÃ³ nÃºmeros inteiros)

**LÃ³gica de atraso:**
```typescript
const isOverdue = now > Number(task.deadline) && !task.status
```
- **`now > Number(task.deadline)`**: Agora Ã© depois do prazo?
- **`&& !task.status`**: E ainda nÃ£o foi concluÃ­da?
- **Resultado**: `true` = atrasada, `false` = nÃ£o atrasada

**ConversÃ£o de timestamps:**
```typescript
const createdDate = new Date(Number(task.createdAt) * 1000)
const deadlineDate = new Date(Number(task.deadline) * 1000)
```
- **`Number(task.createdAt)`**: Timestamp da blockchain (segundos)
- **`* 1000`**: Converte para milissegundos (formato JavaScript)
- **`new Date()`**: Cria objeto Date para formataÃ§Ã£o

**ConversÃ£o Wei â†’ ETH:**
```typescript
const stakeInEth = Number(task.stakeAmount) / 1e18
```
- **`1e18`**: 1 seguido de 18 zeros (1 ETH = 1.000.000.000.000.000.000 wei)
- **Exemplo**: 1000000000000000 wei Ã· 1e18 = 0.001 ETH

#### **ğŸ¯ 7.3.3 FunÃ§Ã£o de Completar - "BotÃ£o de FinalizaÃ§Ã£o"**

```typescript
const handleComplete = async () => {
  if (!isConnected) return
  
  try {
    await completeTask(Number(task.id))
    // Atualizar lista apÃ³s completar
    setTimeout(() => {
      onTaskUpdate && onTaskUpdate()
    }, 2000)
  } catch (error) {
    console.error('Erro ao completar tarefa:', error)
  }
}
```

**ğŸ“– ExplicaÃ§Ã£o da lÃ³gica:**

**VerificaÃ§Ã£o de seguranÃ§a:**
```typescript
if (!isConnected) return
```
- **ProteÃ§Ã£o**: SÃ³ executa se carteira estiver conectada
- **UX**: Evita erros confusos para usuÃ¡rio

**Chamada para blockchain:**
```typescript
await completeTask(Number(task.id))
```
- **`Number(task.id)`**: Converte ID para formato correto
- **`await`**: Espera transaÃ§Ã£o ser confirmada

**AtualizaÃ§Ã£o inteligente:**
```typescript
setTimeout(() => {
  onTaskUpdate && onTaskUpdate()
}, 2000)
```
- **Por que setTimeout?**: Blockchain precisa de tempo para processar
- **2 segundos**: Tempo tÃ­pico de confirmaÃ§Ã£o em redes de teste
- **`onTaskUpdate &&`**: SÃ³ chama se funÃ§Ã£o foi fornecida

#### **ğŸ¨ 7.3.4 RenderizaÃ§Ã£o DinÃ¢mica - "CamaleÃ£o Visual"**

```typescript
return (
  <Card className={`transition-all duration-300 ${
    isCompleted ? "bg-gray-100/80 border-gray-200" : 
    isOverdue ? "bg-red-50/80 border-red-200" : "bg-white"
  }`}>
```

**ğŸ¨ Sistema de cores por status:**

**âœ… Tarefa ConcluÃ­da:**
- **Fundo**: `bg-gray-100/80` (cinza claro com transparÃªncia)
- **Borda**: `border-gray-200` (cinza mÃ©dio)
- **Significado**: "Tarefa finalizada, fora de foco"

**âŒ Tarefa Atrasada:**
- **Fundo**: `bg-red-50/80` (vermelho muito claro)
- **Borda**: `border-red-200` (vermelho claro)
- **Significado**: "AtenÃ§Ã£o! Prazo vencido"

**â³ Tarefa Pendente:**
- **Fundo**: `bg-white` (branco normal)
- **Borda**: PadrÃ£o do Card
- **Significado**: "Tarefa ativa, precisa de atenÃ§Ã£o"

**ğŸ”„ TransiÃ§Ã£o suave:**
- **`transition-all duration-300`**: Cores mudam suavemente em 0.3s
- **UX**: MudanÃ§as visuais nÃ£o sÃ£o bruscas

#### **ğŸ“ 7.3.5 Ãrea de InformaÃ§Ãµes - "CartÃ£o de Dados"**

```typescript
<div className="flex flex-col sm:flex-row justify-between items-start gap-4">
  <div className="flex-1">
    <div className="flex items-center gap-3 mb-2">
      <h3 className={`text-lg font-semibold ${
        isCompleted ? "text-gray-500 line-through" : "text-gray-900"
      }`}>
        {task.title}
      </h3>
      <Badge
        variant={isCompleted ? "default" : isOverdue ? "destructive" : "secondary"}
        className={`text-xs font-medium ${
          isCompleted
            ? "bg-cyan-100 text-cyan-800 border-cyan-200"
            : isOverdue 
              ? "bg-red-100 text-red-800 border-red-200"
              : "bg-yellow-100 text-yellow-800 border-yellow-200"
        }`}
      >
        {isCompleted ? "ConcluÃ­do" : isOverdue ? "Atrasada" : "Pendente"}
      </Badge>
    </div>
```

**ğŸ“– ExplicaÃ§Ã£o dos elementos:**

**Layout responsivo:**
- **`flex-col sm:flex-row`**: Coluna no mobile, linha no desktop
- **`justify-between`**: Espalha conteÃºdo pelas extremidades
- **`gap-4`**: EspaÃ§amento entre elementos

**TÃ­tulo dinÃ¢mico:**
```typescript
<h3 className={`text-lg font-semibold ${
  isCompleted ? "text-gray-500 line-through" : "text-gray-900"
}`}>
```
- **Tarefa concluÃ­da**: Texto cinza + riscado (`line-through`)
- **Tarefa pendente**: Texto escuro normal
- **Analogia**: Como **"riscar item da lista de compras"**

**Badge de status:**
```typescript
{isCompleted ? "ConcluÃ­do" : isOverdue ? "Atrasada" : "Pendente"}
```
- **LÃ³gica ternÃ¡ria**: if-else encadeado
- **3 estados**: ConcluÃ­do (azul) â†’ Atrasada (vermelho) â†’ Pendente (amarelo)

#### **ğŸ“„ 7.3.6 DescriÃ§Ã£o e Metadados - "Detalhes da Tarefa"**

```typescript
<p className={`text-sm text-gray-600 mb-3 ${
  isCompleted ? "text-gray-500" : ""
}`}>
  {task.description}
</p>

<div className="flex flex-wrap gap-x-4 gap-y-1 text-xs text-gray-500">
  <span>Criado: {createdDate.toLocaleDateString("pt-BR")}</span>
  <span>Prazo: {deadlineDate.toLocaleDateString("pt-BR")}</span>
  <span className="flex items-center gap-1">
    <Coins className="h-3 w-3" /> 
    {stakeInEth.toFixed(6)} ETH
  </span>
</div>
```

**ğŸ“– ExplicaÃ§Ã£o dos metadados:**

**FormataÃ§Ã£o de datas:**
```typescript
{createdDate.toLocaleDateString("pt-BR")}
```
- **`.toLocaleDateString("pt-BR")`**: Formato brasileiro (dd/mm/aaaa)
- **Exemplo**: 2024-12-25 â†’ 25/12/2024

**FormataÃ§Ã£o de ETH:**
```typescript
{stakeInEth.toFixed(6)} ETH
```
- **`.toFixed(6)`**: Mostra 6 casas decimais
- **Exemplo**: 0.001000 ETH (mais preciso)

**Layout flexÃ­vel:**
- **`flex flex-wrap`**: Quebra linha quando necessÃ¡rio
- **`gap-x-4 gap-y-1`**: EspaÃ§amento horizontal e vertical diferentes

#### **ğŸ”˜ 7.3.7 BotÃ£o de AÃ§Ã£o - "Centro de Controle"**

```typescript
{!isCompleted && (
  <Tooltip>
    <TooltipTrigger asChild>
      <div className="inline-block">
        <Button
          variant="outline"
          size="icon"
          onClick={handleComplete}
          disabled={!isConnected || isPending}
          aria-label="Concluir Tarefa"
          className="border-violet-300 text-violet-600 hover:bg-violet-50 hover:text-violet-700 disabled:opacity-50"
        >
          {isPending ? (
            <Loader className="h-5 w-5 animate-spin" />
          ) : (
            <CheckSquare className="h-5 w-5" />
          )}
        </Button>
      </div>
    </TooltipTrigger>
    <TooltipContent>
      <p>
        {!isConnected 
          ? "Conecte a carteira para concluir" 
          : isPending 
            ? "Processando transaÃ§Ã£o..."
            : "Concluir Tarefa"
        }
      </p>
    </TooltipContent>
  </Tooltip>
)}
```

**ğŸ“– ExplicaÃ§Ã£o dos estados do botÃ£o:**

**Visibilidade condicional:**
```typescript
{!isCompleted && (
```
- **SÃ³ aparece se**: Tarefa NÃƒO estÃ¡ concluÃ­da
- **LÃ³gica**: Tarefas concluÃ­das nÃ£o precisam de botÃ£o

**Estados do botÃ£o:**
- **Normal**: Ãcone de check + hover violeta
- **Processando**: Spinner animado + desabilitado
- **Desconectado**: Desabilitado com dica

**Tooltip inteligente:**
```typescript
{!isConnected 
  ? "Conecte a carteira para concluir" 
  : isPending 
    ? "Processando transaÃ§Ã£o..."
    : "Concluir Tarefa"
}
```
- **3 mensagens diferentes** conforme contexto
- **UX**: UsuÃ¡rio sempre sabe o que fazer

**Acessibilidade:**
- **`aria-label`**: Para leitores de tela
- **`disabled`**: Previne cliques invÃ¡lidos
- **`Tooltip`**: Dicas visuais claras

#### **ğŸ¯ 7.3.8 Fluxo Completo do Componente**

**ğŸ“Š SequÃªncia de funcionamento:**

```
1. ğŸ“¥ Recebe dados da blockchain
     â†“
2. ğŸ§® Processa e calcula status
     â†“
3. ğŸ¨ Aplica estilos conforme status
     â†“
4. ğŸ“º Renderiza informaÃ§Ãµes
     â†“
5. ğŸ”˜ Mostra botÃ£o (se aplicÃ¡vel)
     â†“
6. ğŸ‘† UsuÃ¡rio clica "Concluir"
     â†“
7. âš¡ Envia transaÃ§Ã£o blockchain
     â†“
8. ğŸ”„ Atualiza interface
```

**âœ… Resultado**: Um cartÃ£o que **"vive e respira"** com os dados da blockchain, sempre mostrando informaÃ§Ãµes atualizadas e aÃ§Ãµes contextuais!

---

### ğŸ§ª **Passo 8: Testando a IntegraÃ§Ã£o**

#### **ğŸ“‹ Checklist de Teste Completo**

**ğŸ”Œ Conectividade:**
- [ ] âœ… BotÃ£o "Conectar Carteira" abre MetaMask
- [ ] âœ… EndereÃ§o aparece formatado (0x1234...abcd)
- [ ] âœ… Indicador de rede mostra "Sepolia"
- [ ] âœ… Alerta aparece se rede estiver errada

**ğŸ“Š Funcionalidades Core:**
- [ ] âœ… Cards de mÃ©tricas mostram dados corretos
- [ ] âœ… Modal "Nova Tarefa" abre e funciona
- [ ] âœ… Lista de tarefas carrega automaticamente
- [ ] âœ… TransaÃ§Ãµes sÃ£o assinadas no MetaMask
- [ ] âœ… Interface atualiza apÃ³s transaÃ§Ãµes

**ğŸš¨ Estados de Erro:**
- [ ] âœ… Loading spinner aparece durante carregamento
- [ ] âœ… Mensagem amigÃ¡vel quando nÃ£o hÃ¡ tarefas
- [ ] âœ… Alerta para conectar carteira quando desconectado
- [ ] âœ… Tooltips funcionam nos cards de mÃ©tricas

---

### ğŸ‰ **ConclusÃ£o da Aula 3**

**ğŸ† ParabÃ©ns! VocÃª construiu um DApp completo!**

#### **âœ… O que conquistamos:**

1. **ğŸ“ ABI e ConfiguraÃ§Ã£o**: Copiamos dados do contrato e configuramos conexÃ£o
2. **ğŸ”Œ Componente de ConexÃ£o**: Sistema inteligente de conexÃ£o de carteira
3. **ğŸ­ Providers Organizados**: Infraestrutura Web3 distribuÃ­da por toda aplicaÃ§Ã£o
4. **ğŸ£ Hooks Customizados**: LÃ³gica organizada e reutilizÃ¡vel
5. **ğŸ”§ Layout Integrado**: FiaÃ§Ã£o principal da aplicaÃ§Ã£o
6. **ğŸ’» Interface Funcional**: PÃ¡gina principal completa e responsiva
7. **ğŸ§ª Sistema Testado**: Checklist completo de funcionalidades

#### **ğŸ§© Stack TecnolÃ³gica Dominada:**
- **Frontend**: Next.js 15 + TypeScript + Tailwind CSS
- **UI Components**: shadcn/ui + Radix UI + Lucide Icons
- **Web3**: wagmi + viem + TanStack Query
- **Blockchain**: Ethereum Sepolia + Infura
- **Smart Contract**: Solidity + Foundry
- **Carteira**: MetaMask

#### **ğŸš€ PrÃ³ximos Passos:**
- Deploy em produÃ§Ã£o no Vercel
- Migrar para mainnet Ethereum
- Adicionar funcionalidades avanÃ§adas
- Implementar notificaÃ§Ãµes push
- Adicionar temas dark/light

#### **ğŸ“ VocÃª agora domina:**
- ğŸ”§ **ConfiguraÃ§Ã£o Web3**: Setup completo de provedores e conexÃµes
- ğŸ£ **Hooks Customizados**: OrganizaÃ§Ã£o e reutilizaÃ§Ã£o de lÃ³gica Web3
- âš¡ **Performance**: Cache automÃ¡tico e otimizaÃ§Ãµes
- ğŸ’» **IntegraÃ§Ã£o Full-Stack**: React + TypeScript + Blockchain
- ğŸ§ª **Testes e Debug**: ValidaÃ§Ã£o de funcionalidades Web3

**ğŸ¯ Seu DApp estÃ¡ pronto para o mundo! ğŸŒ**

---

# ğŸ’¡ Este repositÃ³rio Ã© parte dos cursos, workshops ou bootcamps da NearX School.

Quer acompanhar a aula completa em vÃ­deo e entrar na comunidade? 
ğŸ‘‰ https://nearx.com.br/register | Comunidade: https://discord.com/invite/wavXA98gd8

_NearX School: Aprenda o futuro, hoje._
